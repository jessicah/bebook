<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Game Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheGameKit.html" title="The Game Kit" /><link rel="prev" href="BStreamingGameSound.html" title="BStreamingGameSound" /><link rel="next" href="TheGameKit_Functions.html" title="Global Functions" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BStreamingGameSound.html" title="BStreamingGameSound"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheGameKit.html" title="The Game Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheGameKit_Functions.html" title="Global Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Game Kit</div></div><div id="headerB">Prev: <a href="BStreamingGameSound.html">BStreamingGameSound</a>  Up: <a href="TheGameKit.html">The Game Kit</a>  Next: <a href="TheGameKit_Functions.html">Global Functions</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen"></a>BWindowScreen</h2></div></div></div><a id="id953067" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td><a class="link" href="BWindow.html" title="BWindow">BWindow</a></td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">game/WindowScreen.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libgame.so</code></td></tr><tr><td>Allocation:</td><td>–</td></tr></tbody></table></td><td>
<a class="link overview" href="BWindowScreen_Overview.html" title="BWindowScreen">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BWindowScreen.html#BWindowScreen_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BWindowScreen.html#BWindowScreen_HookFunctions">Hook Functions</a></span></li><li><span class="section"><a href="BWindowScreen.html#BWindowScreen_MemberFunctions">Member Functions</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_Constructor"></a>BWindowScreen()</h4></div></div></div><code class="constructorsynopsis cpp"><span class="methodname">BWindowScreen</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">char* </span><span class="parameter">title</span></span>,<br />              <span class="methodparam"><span class="type">uint32 </span><span class="parameter">space</span></span>,<br />              <span class="methodparam"><span class="type">status_t* </span><span class="parameter">error</span></span>,<br />              <span class="methodparam"><span class="type">bool </span><span class="parameter">debugging</span><span class="initializer"> = <span class="constant">false</span></span></span>);</code><p>Initializes the <code class="classname">BWindowScreen</code> object by
assigning the window a <code class="parameter">title</code> and specifying a
<code class="parameter">space</code> configuration for the screen. The window won't
have a visible border or a tab in which to display the title to the user.
However, others—such as the <span class="application">Workspaces</span>
application—can use the title to identify the window.</p><p>The window is constructed to fill the screen; its frame rectangle
contains every screen pixel when the screen is configured according to the
<code class="parameter">space</code> argument. That argument describes the pixel dimensions and
bits-per-pixel depth of the screen that the
<code class="classname">BWindowScreen</code> object should establish when it
obtains direct access to the frame buffer. It should be one of the
following constants:</p><pre class="screen"><code class="constant">B_8_BIT_640x480</code>    <code class="constant">B_16_BIT_640x480</code>    <code class="constant">B_32_BIT_640x480</code>
<code class="constant">B_8_BIT_800x600</code>    <code class="constant">B_16_BIT_800x600</code>    <code class="constant">B_32_BIT_800x600</code>
<code class="constant">B_8_BIT_1024x768</code>   <code class="constant">B_16_BIT_1024x768</code>   <code class="constant">B_32_BIT_1024x768</code>
<code class="constant">B_8_BIT_1152x900</code>   <code class="constant">B_16_BIT_1152x900</code>   <code class="constant">B_32_BIT_1152x900</code>
<code class="constant">B_8_BIT_1280x1024</code>  <code class="constant">B_16_BIT_1280x1024</code>  <code class="constant">B_32_BIT_1280x1024</code>
<code class="constant">B_8_BIT_1600x1200</code>  <code class="constant">B_16_BIT_1600x1200</code>  <code class="constant">B_32_BIT_1600x1200</code></pre><p>These are the same constants that can be passed to
<a class="link" href="TheInterfaceKit_Functions.html#set_screen_space" title="set_screen_space()"><code class="methodname">set_screen_space()</code></a>,
the <a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a>
function that preference applications call to configure
the screen.</p><p>The <code class="parameter">space</code> configuration applies only
while the <code class="classname">BWindowScreen</code> object is in
control of the screen. When it gives up control, the previous
configuration is restored.</p><p>The constructor assigns the window to the active workspace
(<code class="constant">B_CURRENT_WORKSPACE</code>). It fails if another
<code class="classname">BWindowScreen</code> object in any
application is already assigned to the same workspace.</p><p>To be sure there wasn't an error in constructing the object, check
the <code class="parameter">error</code> argument. If all goes well, the
constructor sets the <code class="parameter">error</code> variable to
<code class="constant">B_OK</code>. If not, it sets it to
<code class="constant">B_ERROR</code>. If there's an error, it's likely to occur in
this constructor, not the inherited
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> constructor.
Since the underlying window will probably exist, you'll need to instruct
it to quit. For example:</p><pre class="programlisting example cpp"><span class="type">status_t</span> <code class="varname">error</code>;
<span class="type">MyWindowScreen*</span> <code class="varname">screen</code> =
            new <code class="classname">MyWindowScreen</code>("Glacier", <code class="constant">B_8_BIT_1024x768</code>, &amp;<code class="varname">error</code>);

if ( <code class="varname">error</code> != <code class="constant">B_OK</code> )
   <code class="varname">screen</code>-&gt;<code class="methodname">PostMessage</code>(<code class="constant">B_QUIT_REQUESTED</code>, <code class="varname">screen</code>);</pre><p>If the <code class="parameter">debugging</code> flag is <code class="constant">true</code>, the
<code class="classname">BWindowScreen</code> is constructed in
debugging mode. This modifies its behavior and enables three functions,
<a class="link" href="BWindowScreen.html#BWindowScreen_RegisterThread" title="RegisterThread(), Suspend(), SuspensionHook()"><code class="methodname">RegisterThread()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_Suspend"><code class="methodname">Suspend()</code></a>, and
<a class="link" href="BWindowScreen.html#BWindowScreen_SuspensionHook"><code class="methodname">SuspensionHook()</code></a>.
The debugging regime is described under those functions.</p><p>See also: the
<a class="link" href="BScreen.html" title="BScreen"><code class="classname">BScreen</code></a> class in the
<a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_Destructor"></a>~BWindowScreen()</h4></div></div></div><code class="destructorsynopsis cpp"><span class="modifier">virtual </span><span class="methodname">~BWindowScreen</span>();</code><p>
Closes the clone of the graphics card driver (through which the
<code class="classname">BWindowScreen</code> object established its connection to the screen), unloads
it from the application, and cleans up after it.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_HookFunctions"></a>Hook Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_ScreenConnected"></a>ScreenConnected()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">ScreenConnected</span>(<span class="methodparam"><span class="type">bool </span><span class="parameter">connected</span></span>);</code><p>
Implemented by derived classes to take action when the application gains
direct access to the screen and when it's about to lose that access.
</p><p>
This function is called with the <code class="parameter">connected</code> flag set to <code class="constant">true</code> immediately
after the <code class="classname">BWindowScreen</code> object becomes the active window and establishes
a direct connection to the graphics card driver for the screen. At that
time, the <span class="application">Application Server</span>'s connection to the screen is suspended;
drawing can only be accomplished through the screen access that the
<code class="classname">BWindowScreen</code> object provides.
</p><p>
<code class="methodname">ScreenConnected()</code> is called with a flag of <code class="constant">false</code> just before the
<code class="classname">BWindowScreen</code> object is scheduled to lose its control over the screen and
the <span class="application">Application Server</span>'s control is reasserted. The <code class="classname">BWindowScreen</code>'s
connection to the screen will not be broken until this function returns.
It should delay returning until the application has finished all current
drawing and no longer needs direct screen access.
</p><p>
Note that whenever <code class="methodname">ScreenConnected()</code> is called, the <code class="classname">BWindowScreen</code> object
is guaranteed to be connected to the screen; if <code class="parameter">connected</code> is <code class="constant">true</code>, it
just became connected, if <code class="parameter">connected</code> is <code class="constant">false</code>, it's still connected but
will be disconnected when the function returns.
</p><p>
Derived classes typically use this function to regulate access to the
screen. For example, they may acquire a semaphore when the <code class="parameter">connected</code> flag
is <code class="constant">false</code>, so that application threads won't attempt direct drawing when
the connection isn't in place, and release the semaphore for drawing
threads to acquire when the flag is <code class="constant">true</code>. For example:
</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">MyWindowScreen</code>::<code class="methodname">ScreenConnected</code>(<span class="type">bool</span> <code class="parameter">connected</code>)
{
   if ( <code class="parameter">connected</code> == <code class="constant">false</code> )
      <code class="function">acquire_sem</code>(<code class="varname">directDrawingSemaphore</code>);
   else
      <code class="function">release_sem</code>(<code class="varname">directDrawingSemaphore</code>);
}</pre><p>
See also: <a class="link" href="BWindowScreen.html#BWindowScreen_Disconnect" title="Disconnect()"><code class="methodname">Disconnect()</code></a>
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_CanControlFrameBuffer"></a>CanControlFrameBuffer()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">CanControlFrameBuffer</span>();</code><p>
Returns <code class="constant">true</code> if the graphics card driver permits applications to control
the configuration of the frame buffer, and <code class="constant">false</code> if not. Control is
exercised through these two functions:
</p><ul class="itemizedlist"><li><p><a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a></p></li><li><p><a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">MoveDisplayArea()</code></a></p></li></ul><p>
A return of <code class="constant">true</code> means that these functions can communicate with the
graphics card driver and at least the first will do something useful. A
return of <code class="constant">false</code> means that neither of them will work.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_CardHookAt"></a>CardHookAt()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type"><a class="link" href="TheGameKit_DefinedTypes.html#graphics_card_hook" title="graphics_card_hook">graphics_card_hook</a> </span><span class="methodname">CardHookAt</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">index</span></span>);</code><p>Returns a pointer to the graphics card "hook" function
that's located at <code class="parameter">index</code> in its list of hook
functions. The function returns <code class="constant">NULL</code> if the graphics
card driver doesn't implement a function at that index or the index is out
of range.</p><p>The hook functions provide accelerated drawing capabilities. They're
documented under
"<a class="link" href="TheGameKit_CardHooks.html" title="Graphics Card Hook Functions">Graphics Card Hook Functions</a>".
The first three hook functions (indices 0, 1, and 2) are not available
through the Game Kit; if you pass an index of 0, 1, or 2 to
<code class="methodname">CardHookAt()</code>, it will return
<code class="constant">NULL</code> even if the function is implemented.</p><p>An application can cache the pointers that <code class="methodname">CardHookAt()</code> returns, but it
should ask for a new set each time the depth or dimensions of the screen
changes and each time the <code class="classname">BWindowScreen</code> object releases or regains
control of the screen. You'd typically call <code class="methodname">CardHookAt()</code> in your
implementation of
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_CardInfo"></a>CardInfo()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type"><a class="link" href="TheGameKit_DefinedTypes.html#graphics_card_info" title="graphics_card_info">graphics_card_info</a>* </span><span class="methodname">CardInfo</span>();</code><p>Returns a description of the current configuration of the graphics card,
as kept by the driver for the card. The returned
<span class="type"><a class="link" href="TheGameKit_DefinedTypes.html#graphics_card_info" title="graphics_card_info">graphics_card_info</a></span>
structure is defined in <code class="filename">addons/graphics/GraphicsCard.h</code></p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>The information returned by this function is only valid when the
<code class="classname">BWindowScreen</code> is connected to the display.</p></div></div></div><p>See also:
<a class="link" href="BWindowScreen.html#BWindowScreen_FrameBufferInfo" title="FrameBufferInfo()"><code class="methodname">FrameBufferInfo()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_Disconnect"></a>Disconnect()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">Disconnect</span>();</code><p>Forces the <code class="classname">BWindowScreen</code> object to disconnect
itself from the screen—to give up its authority over the graphics
card driver, allowing the <span class="application">Application Server</span> to
reassert control. Normally, you'd disconnect the
<code class="classname">BWindowScreen</code> only when hiding the game, reducing it
to an ordinary window in the background, or quitting. The
<a class="link" href="BWindowScreen.html#BWindowScreen_Hide" title="Hide(), Show()"><code class="methodname">Hide()</code></a> and
<a class="link" href="BWindowScreen.html#BWindowScreen_Quit" title="Quit()"><code class="methodname">Quit()</code></a>
functions automatically disconnect the <code class="classname">BWindowScreen</code>
as part of the process of hiding and quitting.
<a class="link" href="BWindowScreen.html#BWindowScreen_Disconnect" title="Disconnect()"><code class="methodname">Disconnect()</code></a>
allows you to sever the connection before calling those functions.</p><p>Before breaking the screen connection,
<a class="link" href="BWindowScreen.html#BWindowScreen_Disconnect" title="Disconnect()"><code class="methodname">Disconnect()</code></a>
causes the <code class="classname">BWindowScreen</code> object to receive a
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>
notification with a flag of <code class="constant">false</code>. It doesn't return until
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>
returns and the connection is broken.
<a class="link" href="BWindowScreen.html#BWindowScreen_Hide" title="Hide(), Show()"><code class="methodname">Hide()</code></a> and
<a class="link" href="BWindowScreen.html#BWindowScreen_Quit" title="Quit()"><code class="methodname">Quit()</code></a>
share this behavior.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_FrameBufferInfo"></a>FrameBufferInfo()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type"><a class="link" href="TheGameKit_DefinedTypes.html#frame_buffer_info" title="frame_buffer_info">frame_buffer_info</a>* </span><span class="methodname">FrameBufferInfo</span>();</code><p>
Returns a pointer to the
<span class="type"><a class="link" href="TheGameKit_DefinedTypes.html#frame_buffer_info" title="frame_buffer_info">frame_buffer_info</a></span>
structure that holds the
driver's current conception of the frame buffer. The structure is defined
in <code class="filename">addons/graphics/GraphicsCard.h</code></p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>The information returned by this function is only valid if
<a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a>
has been called.</p></div></div></div><p>
See also:
<a class="link" href="BWindowScreen.html#BWindowScreen_SetSpace" title="SetSpace()"><code class="methodname">SetSpace()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">MoveDisplayArea()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_CardInfo" title="CardInfo()"><code class="methodname">CardInfo()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_Hide"></a><a id="BWindowScreen_Show"></a>
Hide(), Show()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Hide</span>();</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Show</span>();</code><p>
These functions augment their
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> counterparts to make sure that the
<code class="classname">BWindowScreen</code> is disconnected from the screen before it's hidden and that
it's ready to establish a connection when it becomes the active window.
</p><p>
<code class="methodname">Hide()</code> calls
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> (with an argument of <code class="constant">false</code>) and breaks the
connection to the screen when <a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> returns. It then hides
the window.
</p><p>
<code class="methodname">Show()</code> shows the window on-screen and makes it the active window, which
will cause it to establish a direct connection to the graphics card
driver for the screen. Unlike <code class="methodname">Hide()</code>, it may return before
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>
is called (with an argument of <code class="constant">true</code>).
</p><p>
See also:
<a class="link" href="BWindow.html#BWindow_Hide"><code class="methodname">BWindow::Hide()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_IOBase"></a>IOBase()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">void* </span><span class="methodname">IOBase</span>();</code><p>
Returns a pointer to the base address for the input/output registers on
the graphics card. Registers are addressed by 16-bit offsets from this
base address. (This function may not be supported in future releases.)
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_MoveDisplayArea"></a>MoveDisplayArea()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">MoveDisplayArea</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">x</span></span>,<br />                         <span class="methodparam"><span class="type">int32 </span><span class="parameter">y</span></span>);</code><p>
Relocates the display area, the portion of the frame buffer that's mapped
to the screen. This function moves the area's left-top corner to (<code class="parameter">x</code>, <code class="parameter">y</code>);
by default, the corner lies at (0, 0). The display area must lie entirely
within the frame buffer.
</p><p>
<code class="methodname">MoveDisplayArea()</code> only works if the graphics card driver permits
application control over the frame buffer. It must also permit a frame
buffer with a total area larger than the display area. If successful in
relocating the display area, this function returns <code class="constant">B_OK</code>; if not, it
returns <code class="constant">B_ERROR</code>.
</p><p>
See also:
<a class="link" href="BWindowScreen.html#BWindowScreen_CanControlFrameBuffer" title="CanControlFrameBuffer()"><code class="methodname">CanControlFrameBuffer()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_Quit"></a>Quit()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Quit</span>();</code><p>
Augments the <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>
version of <code class="methodname">Quit()</code> to force the <code class="classname">BWindowScreen</code> object
to disconnect itself from the screen, so that it doesn't quit while in
control of the frame buffer.
</p><p>
Although <code class="methodname">Quit()</code> disconnects the object before quitting, this may not be
soon enough for your application. For example, if you need to destroy
some drawing threads before the <code class="classname">BWindowScreen</code> object is itself destroyed,
you should get rid of them after the screen connection is severed. You
can force the object to disconnect itself by calling
<a class="link" href="BWindowScreen.html#BWindowScreen_Disconnect" title="Disconnect()"><code class="methodname">Disconnect()</code></a>. For
example:
</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">MyWindowScreen</code>::<code class="methodname">Quit</code>()
{
   <code class="methodname">Disconnect</code>();
   <code class="function">kill_thread</code>(<code class="varname">drawing_thread_a</code>);
   <code class="function">kill_thread</code>(<code class="varname">drawing_thread_b</code>);
   <code class="classname">BWindowScreen</code>::<code class="methodname">Quit</code>();
}</pre><p>
If the screen connection is still in place when <code class="methodname">Quit()</code> is called, it
calls <a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> with a flag of <code class="constant">false</code>. It doesn't return until
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> returns and the connection is broken.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_RegisterThread"></a><a id="BWindowScreen_Suspend"></a>
<a id="BWindowScreen_SuspensionHook"></a>
RegisterThread(), Suspend(), SuspensionHook()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">RegisterThread</span>(<span class="methodparam"><span class="type">thread_id </span><span class="parameter">thread</span></span>);</code><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">Suspend</span>(<span class="methodparam"><span class="type">char* </span><span class="parameter">label</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">void* </span><span class="methodname">SuspensionHook</span>(<span class="methodparam"><span class="type">bool </span><span class="parameter">suspended</span></span>);</code><p>
These three functions aid in debugging a game application. They have
relevance only if the <code class="classname">BWindowScreen</code> is running in debugging mode. To set
up the mode, you must:
</p><div class="orderedlist"><ol><li><p>
Construct the <code class="classname">BWindowScreen</code> with the <code class="parameter">debugging</code> flag set to <code class="constant">true</code>. The
flag is <code class="constant">false</code> by default.
</p></li><li><p>
Register all drawing threads (all threads that can touch the frame
buffer in any way) by passing the <span class="type">thread_id</span> to
<a class="link" href="BWindowScreen.html#BWindowScreen_RegisterThread" title="RegisterThread(), Suspend(), SuspensionHook()"><code class="methodname">RegisterThread()</code></a>
immediately after the thread is spawned—before <code class="methodname">resume_thread()</code> is
called to start the thread's execution. The window thread for the
<code class="classname">BWindowScreen</code> object should not draw and should not be registered.
</p></li><li><p>
Launch the application from the command line in a
<span class="application">Terminal</span> window. The window will collect
debugging output from the application while the
<code class="classname">BWindowScreen</code> runs in a different workspace,
generally the one at the immediately preceding index. For example, if the
<span class="application">Terminal</span> window is in the fifth workspace
(<span class="keycap">Command</span>+<span class="keycap">F5</span>), the
game will run in the fourth
(<span class="keycap">Command</span>+<span class="keycap">F4</span>); if the
<span class="application">Terminal</span> is in the fourth
(<span class="keycap">Command</span>+<span class="keycap">F4</span>), the
game runs in the third
(<span class="keycap">Command</span>+<span class="keycap">F3</span>); and so
on. However, if the <span class="application">Terminal</span> window is in the
first workspace
(<span class="keycap">Command</span>+<span class="keycap">F1</span>), the
game runs in the second
(<span class="keycap">Command</span>+<span class="keycap">F2</span>).
</p></li></ol></div><p>
The <span class="application">Terminal</span> window is the destination for all messages the game writes
to the standard error stream or to the standard output—from
<code class="function">printf()</code>, for example. You can switch back and forth between the game and
<span class="application">Terminal</span> workspaces to check the messages and run your application. When
you switch from the game workspace to the <span class="application">Terminal</span> workspace, all
registered threads are suspended and the graphics context is saved. When
you switch back to the game, the graphics context is restored and the
threads are resumed.
</p><p>
Calling <code class="methodname">Suspend()</code> switches to the <span class="application">Terminal</span> workspace programmatically,
just as pressing the correct Command—function key combination
would. Registered threads are suspended, the <span class="application">Terminal</span> workspace is
activated, and the <code class="parameter">label</code> passed as an argument is displayed in a message
in the <span class="application">Terminal</span> window. You can resume the game by manually switching
back to its workspace.
</p><p>
<code class="methodname">SuspensionHook()</code> is called whenever the game is suspended or
resumed—whether by the user switching workspaces or by <code class="methodname">Suspend()</code>.
It gives you an opportunity to save and restore any state that would
otherwise be lost. <code class="methodname">SuspensionHook()</code> is called with a <code class="parameter">suspended</code> flag of
<code class="constant">true</code> just after the application is suspended and with a flag of <code class="constant">false</code>
just before it's about to be resumed.
</p><p>
<code class="methodname">ScreenConnected()</code> is not called when you switch between the <span class="application">Terminal</span> and
game workspaces while in debugging mode. However, it is called for all
normal game activities—when the <code class="classname">BWindowScreen</code> is first activated
and when it hides or quits, for example.
</p><p>
Debugging mode can also preserve some information in case of a crash.
Hold down all the left modifier keys (<span class="keycap">Shift</span>, <span class="keycap">Control</span>, <span class="keycap">Option</span>, <span class="keycap">Command</span>,
<span class="keycap">Alt</span>, or whatever the keys may happen to be on your keyboard), and press
the <span class="keycap">F12</span> key. This restarts the screen with a 640 * 480 resolution and
displays a debugger window. You should then be able to switch to the
<span class="application">Terminal</span> workspace to check the last set of messages before the crash,
modify your code, and start again.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_ScreenChanged"></a>ScreenChanged()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">ScreenChanged</span>(<span class="methodparam"><span class="type"><a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a> </span><span class="parameter">frame</span></span>,<br />                           <span class="methodparam"><span class="type">color_space </span><span class="parameter">mode</span></span>);</code><p>
Overrides the <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> version of <a class="link" href="BWindow.html#BWindow_ScreenChanged" title="ScreenChanged()"><code class="methodname">ScreenChanged()</code></a> so that it does nothing.
This function is called automatically when the screen configuration
changes. It's not one that you should call in application code or
reimplement for the game.
</p><p>
See also: <a class="link" href="BWindow.html#BWindow_ScreenChanged" title="ScreenChanged()"><code class="methodname">BWindow::ScreenChanged()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_SetColorList"></a><a id="BWindowScreen_ColorList"></a>
SetColorList(), ColorList()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetColorList</span>(<span class="methodparam"><span class="type">rgb_color* </span><span class="parameter">colors</span></span>,<br />                  <span class="methodparam"><span class="type">int32 </span><span class="parameter">first</span><span class="initializer"> = 0</span></span>,<br />                  <span class="methodparam"><span class="type">int32 </span><span class="parameter">last</span><span class="initializer"> = 255</span></span>);</code><code class="methodsynopsis cpp"><span class="type">rgb_color* </span><span class="methodname">ColorList</span>();</code><p>
These functions set and return the list of 256 colors that can be
displayed when the frame buffer has a depth of 8 bits per pixel (the
<code class="constant">B_CMAP8</code> color space). <code class="methodname">SetColorList()</code>
is passed an array of one or more
colors to replace the colors currently in the list. The first color in
the array replaces the color in the list at the specified <code class="parameter">first</code> index;
all colors up through the <code class="parameter">last</code> specified index are modified. It fails if
either index is out of range.
</p><p>
<code class="methodname">SetColorList()</code> alters the list of colors kept on the graphics card. If
the <code class="classname">BWindowScreen</code> isn't connected to the screen, the new list takes
effect when it becomes connected.
</p><p>
<code class="methodname">ColorList()</code> returns a pointer to the entire list of 256 colors. This is
not the list kept by the graphics card driver, but a local copy. It
belongs to the <code class="classname">BWindowScreen</code> object and should be altered only by calling
<code class="methodname">SetColorList()</code>.
</p><p>
See also:
<a class="link" href="BScreen.html#BScreen_ColorMap" title="ColorMap(), IndexForColor(), ColorForIndex()"><code class="methodname">BScreen::ColorMap()</code></a> in the <a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_SetFrameBuffer"></a>SetFrameBuffer()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetFrameBuffer</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">width</span></span>,<br />                        <span class="methodparam"><span class="type">int32 </span><span class="parameter">height</span></span>);</code><p>
Configures the frame buffer on the graphics card so that it's <code class="parameter">width</code> pixel
columns wide and <code class="parameter">height</code> pixel rows high. This function works only if the
driver for the graphics card allows custom configurations (as reported by
<a class="link" href="BWindowScreen.html#BWindowScreen_CanControlFrameBuffer" title="CanControlFrameBuffer()"><code class="methodname">CanControlFrameBuffer()</code></a>) and the <code class="classname">BWindowScreen</code> object is currently
connected to the screen.
</p><p>
The new dimensions of the frame buffer must be large enough to hold all
the pixels displayed on-screen—that is, they must be at least as
large as the dimensions of the display area. If the driver can't
accommodate the proposed width and height,
<a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a> returns
<code class="constant">B_ERROR</code>. If the change is made, it returns <code class="constant">B_OK</code>.
</p><p>
This function doesn't alter the depth of the frame buffer or the size or
location of the display area.
</p><p>
See also:
<a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">MoveDisplayArea()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">SetSpace()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_SetSpace"></a>SetSpace()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetSpace</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">space</span></span>);</code><p>
Configures the screen space to one of the standard combinations of width,
height, and depth. The configuration is first set by the class
constructor—permitted <code class="parameter">space</code> constants are documented
there—and it may be altered after construction only by this
function.
</p><p>
Setting the screen space sets the dimensions of the frame buffer and
display area. For example, if <code class="parameter">space</code> is <code class="constant">B_32_BIT_800x600</code>, the frame buffer
will be 32 bits deep and at least 800 pixel columns wide and 600 pixel
rows high. The display area (the area of the frame buffer mapped to the
screen) will also be 800 pixels * 600 pixels. After setting the screen
space, you can enlarge the frame buffer by calling
<a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a> and
relocate the display area in the larger buffer by calling
<a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">MoveDisplayArea()</code></a>.
</p><p>
If the requested configuration is refused by the graphics card driver,
<code class="constant">SetSpace()</code> returns <code class="constant">B_ERROR</code>. If all goes well, it returns <code class="constant">B_OK</code>.
</p><p>
See also: the <code class="classname">BWindowScreen</code>
<a class="link" href="BWindowScreen.html#BWindowScreen_Constructor" title="BWindowScreen()">constructor</a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_SetFrameBuffer" title="SetFrameBuffer()"><code class="methodname">SetFrameBuffer()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_MoveDisplayArea" title="MoveDisplayArea()"><code class="methodname">MoveDisplayArea()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_WindowActivated"></a>WindowActivated()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">WindowActivated</span>(<span class="methodparam"><span class="type">bool </span><span class="parameter">active</span></span>);</code><p>
Overrides the <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> version of <a class="link" href="BWindow.html#BWindow_WindowActivated" title="WindowActivated()"><code class="methodname">WindowActivated()</code></a> to connect the
<code class="classname">BWindowScreen</code> object to the screen (give it control over the graphics
card driver) when the <code class="parameter">active</code> flag is <code class="constant">true</code>.
</p><p>
This function doesn't disconnect the <code class="classname">BWindowScreen</code> when the flag is
<code class="constant">false</code>, because there's no way for the window to cease being the active
window without the connection already having been lost.
</p><p>
Don't reimplement this function in your application, even if you call the
inherited version; rely instead on
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> for accurate
notifications of when the <code class="classname">BWindowScreen</code> gains and loses control of the
screen.
</p><p>
See also:
<a class="link" href="BWindow.html#BWindow_WindowActivated" title="WindowActivated()"><code class="methodname">BWindow::WindowActivated()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BWindowScreen_WorkspaceActivated"></a>WorkspaceActivated()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">WorkspaceActivated</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">workspace</span></span>,<br />                                <span class="methodparam"><span class="type">bool </span><span class="parameter">active</span></span>);</code><p>
Overrides the <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> version of <a class="link" href="BWindow.html#BWindow_WorkspaceActivated" title="WorkspaceActivated()"><code class="methodname">WorkspaceActivated()</code></a> to connect the
<code class="classname">BWindowScreen</code> object to the screen when the <code class="parameter">active</code> flag is <code class="constant">true</code> and to
disconnect it when the flag is <code class="constant">false</code>. User's typically activate the game
by activating the workspace in which it's running, and deactivate it by
moving to another workspace.
</p><p>
Don't override this function in your application; implement
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a> instead.
</p><p>
See also:
<a class="link" href="BWindow.html#BWindow_WorkspaceActivated" title="WorkspaceActivated()"><code class="methodname">BWindow::WorkspaceActivated()</code></a>,
<a class="link" href="BWindowScreen.html#BWindowScreen_ScreenConnected" title="ScreenConnected()"><code class="methodname">ScreenConnected()</code></a>
</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BStreamingGameSound.html">BStreamingGameSound</a>  Up: <a href="TheGameKit.html">The Game Kit</a>  Next: <a href="TheGameKit_Functions.html">Global Functions</a> </div><div id="footerB"><div id="footerBL"><a href="BStreamingGameSound.html" title="BStreamingGameSound"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheGameKit.html" title="The Game Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheGameKit_Functions.html" title="Global Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
