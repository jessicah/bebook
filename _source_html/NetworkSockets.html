<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Network Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheNetworkKit.html" title="The Network Kit" /><link rel="prev" href="BNetEndpoint.html" title="BNetEndpoint" /><link rel="next" href="TheOpenGLKit.html" title="The OpenGL Kit" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BNetEndpoint.html" title="BNetEndpoint"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheNetworkKit.html" title="The Network Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheOpenGLKit.html" title="The OpenGL Kit"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Network Kit</div></div><div id="headerB">Prev: <a href="BNetEndpoint.html">BNetEndpoint</a>  Up: <a href="TheNetworkKit.html">The Network Kit</a>  Next: <a href="TheOpenGLKit.html">The OpenGL Kit</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="NetworkSockets"></a>Network Sockets</h2></div></div></div><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Declared In:</td><td><code class="filename">kit/net/socket.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libnet.so</code></td></tr></tbody></table></div><p>A socket is an entry onto a network. To transmit data to another
computer, you create a socket, tell it how to find the other computer,
and then tell it to send. To receive data, you create a socket, tell it
which computer to listen to (in some cases), and then wait for data to
come pouring in.</p><p>The socket story starts with the
<a class="link" href="NetworkSockets.html#socket" title="socket(), closesocket()"><code class="function">socket()</code></a>
function. The set of functions you need to call after that depends on the
type of socket you're creating (as explained in
<a class="link" href="NetworkSockets.html#socket" title="socket(), closesocket()"><code class="function">socket()</code></a>).</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="socket"></a><a id="closesocket"></a>
socket(), closesocket()</h3></div></div></div><a id="id1214435" class="indexterm"></a><a id="id1214442" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">socket</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">family</span></span>,<br />           <span class="methodparam"><span class="type">int </span><span class="parameter">type</span></span>,<br />           <span class="methodparam"><span class="type">int </span><span class="parameter">protocol</span></span>);</code><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">closesocket</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>);</code><p>The <code class="function">socket()</code> function returns a token (a non-negative integer) that
represents the local end of a connection to another machine (0 is a valid
socket token).</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Socket tokens are not file descriptors (this violates the BSD
tradition).</p></div></div></div><p>Freshly returned, a socket token is abstract and unusable; to put the
token to use, you have to pass it as an parameter to other
functions—such as
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a> and
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>—that
know how to establish a connection over the network. The function's
parameters, which are examined in detail in
"<a class="xref" href="NetworkSockets.html#NetworkSockets_Functions_TheSocketParameters" title="The socket() Parameters">The socket() Parameters</a>",
accept these values:</p><div class="informaltable"><table border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Parameter</th><th>Acceptable Values</th></tr></thead><tbody><tr><td><code class="parameter">family</code></td><td><code class="constant">AF_INET</code></td></tr><tr><td><code class="parameter">type</code></td><td><code class="constant">SOCK_STREAM</code>, <code class="constant">SOCK_DGRAM</code></td></tr><tr><td><code class="parameter">protocol</code></td><td>0, <code class="constant">IPPROTO_TCP</code>,
<code class="constant">IPPROTO_UDP</code>,
<code class="constant">IPPROTO_ICMP</code></td></tr></tbody></table></div><p>The most typical socket calls are:</p><pre class="programlisting example c"><span class="comment">/* Create a stream TCP socket. */</span>
<span class="type">int</span> <code class="varname">tcp_socket</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_STREAM</code>, 0);

<span class="comment">/* Create a datagram UDP socket. */</span>
<span class="type">int</span> <code class="varname">udp_socket</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_DGRAM</code>, 0);</pre><p><acronym class="acronym" title="Internet Control Message Protocol">ICMP</acronym>
messages are normally sent through "raw" sockets; however, the
Network Kit doesn't currently support raw sockets, so you should use a
datagram socket instead:</p><pre class="programlisting example c"><span class="comment">/* Create a datagram icmp socket. */</span>
<span class="type">long</span> <code class="varname">icmp_socket</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_DGRAM</code>, <code class="constant">IPPROTO_ICMP</code>);</pre><p><code class="function">closesocket()</code> closes a socket's connection (if it's the type of socket
that can hold a connection) and frees the resources that have been
assigned to the socket. When you're done with the sockets that you've
created, you should pass each socket token to <code class="function">closesocket()</code>. No socket is
exempt from the need to be closed. This extends to sockets that are
created for you by the
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
function.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="NetworkSockets_Functions_TheSocketParameters"></a>The socket() Parameters</h4></div></div></div><p><code class="function">socket()</code>'s three parameters, all of which take predefined constants as
values, describe the type of communication the socket can handle:</p><table class="variablelist parameters"><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="parameter">family</code></span></p></td><td><p>Describes the network address format that the socket
understands. Currently, it must be <code class="constant">AF_INET</code> (the Internet address
format).</p></td></tr><tr><td><p><span class="term"><code class="parameter">type</code></span></p></td><td><p>Describes the persistence of the connection that can be formed
through this socket. It must be either <code class="constant">SOCK_STREAM</code>
or <code class="constant">SOCK_DGRAM</code>.
<code class="constant">SOCK_STREAM</code> means the connection (which is formed
through a
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
or <a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
call) remains open until told to close. <code class="constant">SOCK_DGRAM</code> describes
a datagram socket that's only open while data is being sent or received
(typically through
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a> and
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>).
It's closed at all other
times. Keep in mind that you still have to call <code class="function">closesocket()</code> on a
datagram socket when you're done with it.</p></td></tr><tr><td><p><span class="term"><code class="parameter">protocol</code></span></p></td><td><p>Describes the messaging protocol, which is closely related to the
socket type. Although there are four acceptable values (0,
<code class="constant">IPPROTO_TCP</code>, <code class="constant">IPPROTO_UDP</code>,
and <code class="constant">IPPROTO_ICMP</code>), the only values that you should
actually use are 0 or <code class="constant">IPPROTO_ICMP</code>. 0 tells the
socket to choose the correct protocol based on the socket type: If you set
the type to <code class="constant">SOCK_STREAM</code>, then a protocol of 0
automatically sets the messaging protocol to
<code class="constant">IPPROTO_TCP</code>. Similarly,
<code class="constant">IPPROTO_UDP</code> is the correct protocol for
<code class="constant">SOCK_DGRAM</code>. It's an error to ask for a "udp
stream" or a "tcp datagram."</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="NetworkSockets_Functions_SortsOfSockets"></a>Sorts of Sockets</h4></div></div></div><p>There are only two socket type constants:
<code class="constant">SOCK_STREAM</code> and <code class="constant">SOCK_DGRAM</code>.
However, if we look at the way sockets are used, we see that there are
really five different categories of sockets, as illustrated below.</p><p>The labelled ovals represent individual computers that are attached to
the network. The solid circles represent individual sockets. The numbers
near the sockets are keys to the socket categories, which are:</p><div class="orderedlist"><ol><li><p>The stream listener socket. A stream listener socket provides
access to a service that's running on the "listener" machine (you might
want to think of the machine as a "server.") The listener socket waits
for client machines to "call in" and ask to be served. In order to listen
for clients, the listener must call
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>,
which "binds" the socket to
an IP address and machine-specific port, and then
<a class="link" href="NetworkSockets.html#listen" title="listen(), accept()"><code class="function">listen()</code></a>.
Thus primed,
the socket waits for a client message to show up by sitting in an
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
call.</p></li><li><p>The stream client socket. A stream client socket asks for service
from a server machine by attempting to connect to the server's listener
socket. It does this through the
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
function. A stream client can be bound (you can call
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
on it), but it's not mandatory.</p></li><li><p>The "accept" socket. When a stream listener hears a client in an
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
call, the function call creates yet another socket called the
"accept" socket. Accept sockets are valid sockets, just like those you
create through
<code class="function">socket()</code>.
In particular, you have to remember to close accept sockets (through
<code class="function">closesocket()</code>)
just as you would the sockets you
explicitly create. Note that you can't bind an accept socket—the
socket is bound automatically by the system.</p></li><li><p>The datagram receiver socket. A datagram receiver socket is sort of
like a stream listener: It calls
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
and waits for "senders" to send
messages to it. Unlike the stream listener, the datagram receiver doesn't
call
<a class="link" href="NetworkSockets.html#listen" title="listen(), accept()"><code class="function">listen()</code></a> or
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>.
Furthermore, when a datagram sender sends a
message to the receiver, there's no ancillary socket created to handle
the message (there's no <acronym class="acronym">UDP</acronym> analog to the
<acronym class="acronym">TCP</acronym> accept socket).</p></li><li><p>The datagram sender socket. A datagram sender is the simplest type
of socket—all it has to do is identify a datagram receiver and send
messages to it, through the
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a>
function. Binding a datagram sender socket is optional.</p></li></ol></div><p>TCP communication is two-way. Once the link between a client and the
listener has been established (through
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>/<a class="link" href="NetworkSockets.html#listen" title="listen(), accept()"><code class="function">listen()</code></a>/<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
on the listener side, and
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
on the client side), the two machines can
talk to each other through respective and complementary
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
calls.</p><p>Communication along a <acronym class="acronym">UDP</acronym> path, on the other
hand, is one-way. The datagram sender can send messages (through
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a>),
and the datagram receiver can receive them (through
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>),
but the receiver can't
send message back to the sender. However, you can simulate a two-way <acronym class="acronym">UDP</acronym>
conversation by binding both sockets. This doesn't change the definition
of the <acronym class="acronym">UDP</acronym> path, or the capabilities of the two types of datagram
sockets, it simply means that a bound datagram socket can act as a
receiver (it can call
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>)
or as a sender (it can call
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a>).</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>To be complete, it should be mentioned that datagram sockets can also
invoke
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
and then pass messages through
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>.
The datagram use of these functions is a convenience; its advantages are
explained in the description of the
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a>
function.</p></div></div></div></div><p>Upon failure, <code class="function">socket()</code> returns a
negative value and sets <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EAFNOSUPPORT</code></span></p></td><td><p><code class="parameter">format</code> was other than
<code class="constant">AF_INET</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">EPROTOTYPE</code></span></p></td><td><p><code class="parameter">type</code> and <code class="parameter">protocol</code>
mismatch.</p></td></tr><tr><td><p><span class="term"><code class="constant">EPROTONOSUPPORT</code></span></p></td><td><p>Unrecognized <code class="parameter">type</code> or
<code class="parameter">protocol</code> value.</p></td></tr></tbody></table><p><code class="function">closesocket()</code> returns a negative value if
its parameter is invalid.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="bind"></a>bind()</h3></div></div></div><a id="id1215375" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">bind</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">family</span></span>,<br />         <span class="methodparam"><span class="modifier">const </span><span class="type">struct sockaddr* </span><span class="parameter">interface</span></span>,<br />         <span class="methodparam"><span class="type">int </span><span class="parameter">size</span></span>);</code><p>The <code class="function">bind()</code> function creates an association between a socket and an
"interface," where an interface is a combination of an IP address and a
port number. Binding is, primarily, useful for receiving messgaes: When a
message sender (whether it's a stream client or a datagram sender) sends
a message, it tags the message with an IP address and a port number. The
receiving machine—the machine with the tagged IP
address—delivers the message to the socket that's bound to the
tagged port.</p><p>The necessity of the bind operation depends on the type of socket;
referring to the five categories of sockets enumerated in the
<a class="link" href="NetworkSockets.html#socket" title="socket(), closesocket()"><code class="function">socket()</code></a>
function description (and illustrated in the charming diagram found
there), the "do I need to bind?" question is answered thus:</p><div class="orderedlist"><ol><li><p>Stream listener sockets must be bound. Furthermore, after binding a
listener socket, you must then call listen() and, when a client calls,
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>.</p></li><li><p>Stream client sockets can be bound, but they don't have to be. If
you're going to bind a client socket, you should do so before you call
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>.
The advantages of binding a stream client escape me at the
moment. In any case, the client doesn't have to bind to the same port
number as the listener—the listener's binding and the client's
binding are utterly separate entities (let alone that they are on
different machines). However, the client does connect to the interface
that the listener is bound to.</p></li><li><p>Stream attach sockets must not be bound.</p></li><li><p>Datagram receiver sockets must be bound.</p></li><li><p>Datagram sender sockets don't have to be bound… but if you're
going to turn around and use the socket as a receiver, then you'll have
to bind it.</p></li></ol></div><p>Once you've bound a socket, you can't unbind it. If you no longer want
the socket to be bound to its interface, the only thing you can do is
close the socket
(<a class="link" href="NetworkSockets.html#closesocket"><code class="function">closesocket()</code></a>)
and start all over again.</p><p>Also, a particular interface can be bound by only one socket at a time
and a single socket can only bind to one interface at a time. If your
socket needs to bind to more than one interface, you need to create more
than one socket and bind each one separately. An example of this is given
later in this function description.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>The 1-to-1 binding differs with the BSD socket implementation, which
expects a socket to be able to bind to more than one interface. Consider
it a bug that will be fixed in a subsequent release.</p></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="bind_Parameters"></a>The bind() Parameters</h4></div></div></div><p><code class="function">bind()</code>'s first parameter is the socket that you're attempting to bind.
This is, typically, a socket of type <code class="constant">SOCK_STREAM</code>. The interface parameter
is the address/port combination (or "interface") to which you're binding
the socket. The parameter is typed as a <span class="type">sockaddr</span> structure, but, in
reality, you have to create and pass a <span class="type">sockaddr_in</span> structure cast as a
<span class="type">sockaddr</span>. The <span class="type">sockaddr_in</span> structure is defined as:</p><pre class="programlisting definition c"><span class="type">struct sockaddr_in</span> {
   <span class="type">unsigned short</span> <code class="varname">sin_family</code>;
   <span class="type">unsigned short</span> <code class="varname">sin_port</code>;
   <span class="type">struct in_addr</span> <code class="varname">sin_addr</code>;
   <span class="type">char</span> <code class="varname">sin_zero</code>[4];
};</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">sin_family</code></span></p></td><td><p>Is the same as the address format constant that used to
create the socket (the first parameter to
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>).
Currently, it's always <code class="constant">AF_INET</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">sin_port</code></span></p></td><td><p>Is the port number that the socket will bind to, given in
network byte order. Valid port numbers are between 1 and 65535; numbers
up to 1024 are reserved for services such as ftp and telnet. If you're
not implementing a standard service, you should choose a port number
greater than 1024. The actual value of the port number is meaningless,
but keep in mind that the port number must be unique for a particular
address; only one socket can be bound to a particular address/port
combination.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Currently, there's no system-defined mechanism for allowing a
client/sender machine to ask a listener/receiver machine for its port
numbers. Therefore, when you create a networked application, you either
have to hard-code the port numbers or, better yet, provide default port
numbers that the user (or a system administrator) can easily change.</p></div></div></div></td></tr><tr><td><p><span class="term"><code class="varname">sin_addr</code></span></p></td><td><p>Is an <span class="type">in_addr</span> structure that stores, in its <span class="type">s_addr</span> field,
the IP address of the socket's machine. As always, the address is in
network byte order. You can use an address of 0 to tell the binding
mechanism to find an address for you. By convention, binding to address
0 (which is conveniently symbolized by the <code class="constant">INADDR_ANY</code> address) means
that you want to bind to every address by which your computer is known,
including the "loopback" (address 127.0.0.1, or the constant
<code class="constant">INADDR_LOOPBACK</code>).</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>The BeOS does not currently implement global binding. When you bind to
<code class="constant">INADDR_ANY</code>, the <code class="function">bind()</code> function binds to the first available interface
(where "availability" means the address/port combination is currently
unbound). Internet interfaces are considered before the loopback
interface. If you want to bind to all interfaces, you have to create a
separate socket for each. An example of this is given later.</p></div></div></div></td></tr><tr><td><p><span class="term"><code class="varname">sin_zero</code></span></p></td><td><p>Is padding. To be safe, you should fill it with zeros.</p></td></tr></tbody></table><p>The <code class="parameter">size</code> parameter is the size, in
bytes, of the second parameter.</p><p>If the <code class="function">bind()</code> call is successful, the
<code class="parameter">interface</code> parameter is set to contain the actual
address that was used. If the socket can't be bound, the function returns a
negative value, and sets the global
<code class="varname">errno</code> to <code class="constant">EABDF</code>
if the <code class="parameter">socket</code> parameter is invalid; for all other
errors, <code class="varname">errno</code> is set to
-1.</p><p>The following example shows a typical use of the <code class="function">bind()</code> function. The
example uses the fictitious <code class="function">gethostaddr()</code> function that's defined in the
description of the <code class="function">gethostname()</code> function.</p><pre class="programlisting example c"><span class="type">struct sockaddr_in</span> <code class="varname">sa</code>;
<span class="type">int</span> <code class="varname">sock</code>;
<span class="type">long</span> <code class="varname">host_addr</code>;

<span class="comment">/* Create the socket. */</span>
if ((<code class="varname">sock</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_STREAM</code>, 0)) &lt; 0) {
   <span class="comment">/* error */</span>
}

<span class="comment">/* Set the address format for the imminent bind. */</span>
<code class="varname">sa</code>.<code class="varname">sin_family</code> = <code class="constant">AF_INET</code>;

<span class="comment">/* We'll choose an arbitrary port number translated to network byte
order. */</span>
<code class="varname">sa</code>.<code class="varname">sin_port</code> = <code class="function">htonl</code>(2125);

<span class="comment">/* Get the address of the local machine. If the address can't
* be found (the function looks it up based on the host name),
* then we use address INADDR_ANY.
*/</span>
if ((<code class="varname">host_addr</code> = (<span class="type">ulong</span>) <code class="function">gethostaddr</code>()) == -1) {
   <code class="varname">host_addr</code> = <code class="constant">INADDR_ANY</code>;
}
<code class="varname">sa</code>.<code class="varname">sin_addr</code>.<code class="varname">s_addr</code> = <code class="varname">host_addr</code>;

<span class="comment">/* Clear sin_zero. */</span>
<code class="function">memset</code>(<code class="varname">sa</code>.<code class="varname">sin_zero</code>, 0, <code class="function">sizeof</code>(<code class="varname">sa</code>.<code class="varname">sin_zero</code>));

<span class="comment">/* Bind the socket. */</span>
if (<code class="function">bind</code>(<code class="varname">sock</code>, (<span class="type">struct sockaddr*</span>) &amp;<code class="varname">sa</code>, <code class="function">sizeof</code>(<code class="varname">sa</code>)) &lt; 0) {
   <span class="comment">/* error */</span>
}</pre><p>As mentioned earlier, the bind-to-all-interfaces convention (by asking to
bind to address 0) isn't currently implemented. Thus, if the
<code class="function">gethostaddr()</code>
call fails in the example, the socket will be bound to the
first address by which the local computer is known.</p><p>But let's say that you really do want to bind to all interfaces. To do
this, you have to create separate sockets for each interface, then call
<code class="function">bind()</code> on each one. In the example below we create a series of sockets
and then bind each one to an interface that specifies address 0. In doing
this, we depend on the "first available interface" rule to find the next
interface for us. Keep in mind that a successful <code class="function">bind()</code> rewrites the
contents of the <span class="type">sockaddr</span> parameter (most importantly, it resets the 0
address component). Thus, we have to reinitialize the structure each time
through the loop:</p><pre class="programlisting example c"><span class="comment">/* Declare an array of sockets. */</span>
#define <code class="constant">MAXSOCKETS</code> 4
<span class="type">int</span> <code class="varname">socks</code>[<code class="constant">MAXSOCKETS</code>];
<span class="type">int</span> <code class="varname">sockN</code>;
<span class="type">int</span> <code class="varname">bind_res</code>;

<span class="type">struct sockaddr_in</span> <code class="varname">sock_addr</code>;

for (<code class="varname">sockN</code> = 0; <code class="varname">sockN</code> &lt; <code class="constant">MAXSOCKETS</code>; <code class="varname">sockN</code>++)
{
   (<code class="varname">socks</code>[<code class="varname">sockN</code>] = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_STREAM</code>, 0));
   if (<code class="varname">socks</code>[<code class="varname">sktr</code>] &lt; 0) {
      <code class="function">perror</code>("socket");
      goto <code class="varname">sock_error</code>;
   }

   <span class="comment">/* Initialize the structure. */</span>
   <code class="varname">sa</code>.<code class="varname">sin_family</code> = <code class="constant">AF_INET</code>;
   <code class="varname">sa</code>.<code class="varname">sin_port</code> = <code class="function">htonl</code>(2125);
   <code class="varname">sa</code>.<code class="varname">sin_addr</code>.<code class="varname">s_addr</code> = 0;
   <code class="function">memset</code>(<code class="varname">sa</code>.<code class="varname">sin_zero</code>, 0, <code class="function">sizeof</code>(<code class="varname">sa</code>.<code class="varname">sin_zero</code>));

   <code class="varname">bind_res</code> = <code class="function">bind</code>(<code class="varname">socks</code>[<code class="varname">sockN</code>],
               (<span class="type">struct sockaddr*</span>) &amp;<code class="varname">sa</code>,
               <code class="function">sizeof</code>(<code class="varname">sa</code>));

   <span class="comment">/* A bind error means we've run out of addresses. */</span>
   if (<code class="varname">bind_res</code> &lt; 0) {
      <code class="function">closesocket</code>(<code class="varname">socks</code>[<code class="varname">sockN</code>--]);
      break;
   }
}

<span class="comment">/* Use the bound socket (listen, accept, recv/send). */</span>
...

sock_error:
   for (;<code class="varname">sockN</code> &gt;=0 <code class="varname">sockN</code>--)
      <code class="function">closesocket</code>(<code class="varname">socks</code>[<code class="varname">sockN</code>]);</pre></div><p>To ask a socket about the address and port to which it is bound you use
the getsockname()
function, described later in this section.</p><p>Upon failure, <code class="function">bind()</code> returns a negative value
and sets <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EABDF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="connect"></a>connect()</h3></div></div></div><a id="id1216387" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">connect</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />            <span class="methodparam"><span class="modifier">const </span><span class="type">struct sockaddr* </span><span class="parameter">remote_interface</span></span>,<br />            <span class="methodparam"><span class="type">int </span><span class="parameter">remote_size</span></span>);</code><p>The meaning of the <code class="function">connect()</code> function depends on the type of socket
that's passed as the first parameter:</p><ul class="itemizedlist"><li><p>If it's a stream client, then <code class="function">connect()</code> attempts to form a connection
to the socket that's specified by <code class="parameter">remote_interface</code>. The remote socket
must be a bound stream listener. A client socket can only be connected
to one listener at a time. Note that you can't call <code class="function">connect()</code> on a
stream listener.</p></li><li><p>If it's a datagram socket (either a sender or a receiver), <code class="function">connect()</code>
simply caches the <code class="parameter">remote_interface</code> information in anticipation of
subsequent
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
calls. By using <code class="function">connect()</code>, a datagram
avoids the fuss of filling in the remote information that's needed by
the "normal" datagram message functions,
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a> and
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>.
Note that a datagram may only call
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
if it has first called <code class="function">connect()</code>.</p></li></ul><p>The <code class="parameter">remote_interface</code> parameter is
a pointer to a <span class="type">sockaddr_in</span> structure
cast as a <span class="type">sockaddr</span> pointer. The <code class="parameter">remote_size</code> value gives the size of
<code class="parameter">remote_interface</code>. See the
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
function for a description of the
<span class="type">sockaddr_in</span> structure.</p><p>Currently, you can't disconnect a connected socket. If you want to
connect to a different listener, or reset a datagram's interface
information, you have to close the socket and start over.</p><p>When you attempt to <code class="function">connect()</code> a stream client, the listener must respond
with an
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
call. Having gone through this dance, the two sockets
can then pass messages to each other through complementary
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
calls. If the listener doesn't respond immediately to a client's
attempt to connect, the client's <code class="function">connect()</code> call will block. If the
listener doesn't respond within (about) a minute, the connection will
time out. If the listener's acceptance queue is full, the client will be
refused and <code class="function">connect()</code> will return immediately.</p><p>If the socket is in no-block mode (as set through
setsockopt()),
and blocking would occur otherwise, connect() returns immediately with a
result of <code class="constant">EWOULDBLOCK</code>.</p><p>Upon failure, <code class="function">connect()</code> returns a negative
number and sets <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EWOULDBLOCK</code></span></p></td><td><p>The connection attempt would block.</p></td></tr><tr><td><p><span class="term"><code class="constant">EISCONN</code></span></p></td><td><p>The socket is already connected.</p></td></tr><tr><td><p><span class="term"><code class="constant">ECONNREFUSED</code></span></p></td><td><p>The listener rejected the connection.</p></td></tr><tr><td><p><span class="term"><code class="constant">ETIMEDOUT</code></span></p></td><td><p>The connection attempt timed out.</p></td></tr><tr><td><p><span class="term"><code class="constant">ENETUNREACH</code></span></p></td><td><p>The client can't get to the network.</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="getpeername"></a><a id="getsockname"></a>
getpeername(), getsockname()</h3></div></div></div><a id="id1216788" class="indexterm"></a><a id="id1216795" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">getpeername</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />                <span class="methodparam"><span class="type">struct sockaddr* </span><span class="parameter">interface</span></span>,<br />                <span class="methodparam"><span class="type">int* </span><span class="parameter">size</span></span>);</code><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">getsockname</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />                <span class="methodparam"><span class="type">struct sockaddr* </span><span class="parameter">interface</span></span>,<br />                <span class="methodparam"><span class="type">int* </span><span class="parameter">size</span></span>);</code><p><code class="function">getsockname()</code> returns, by reference
in <code class="parameter">interface</code>, a <span class="type">sockaddr_in</span> structure
that contains the interface information for the bound socket given by
<code class="parameter">socket</code>.</p><p><code class="function">getpeername()</code> returns, in the structure
pointed to by the <code class="parameter">interface</code>
parameter, a <span class="type">sockaddr_in</span> structure that describes the remote interface to
which the socket is connected.</p><p>In both cases, the *<code class="parameter">size</code> parameter gives
the size of the <code class="parameter">interface</code>
structure; *<code class="parameter">size</code> is reset, on the way out, to the size of the <code class="parameter">interface</code>
parameter as it's passed back. Note that the <span class="type">sockaddr_in</span> pointer that you
pass as the second parameter must be cast as a pointer to a <span class="type">sockaddr</span>
structure:</p><pre class="programlisting example c"><span class="type">struct sockaddr_in</span> <code class="varname">interface</code>;
<span class="type">int</span> <code class="varname">size</code> = <code class="function">sizeof</code>(<code class="varname">interface</code>);

<span class="comment">/* We'll assume "sock" is a valid socket token. */</span>
if (<code class="function">getsockname</code>(<code class="varname">sock</code>, (<span class="type">struct sockaddr*</span>) &amp;<code class="varname">interface</code>, &amp;<code class="varname">size</code>) &lt; 0)
   <span class="comment">/* error */</span></pre><p>Upon failure, <code class="function">getsockname()</code> and
<code class="function">getpeername()</code> return negative numbers and
set <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EINVAL</code></span></p></td><td><p>The *<code class="parameter">size</code> value (going in) wasn't big enough.</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="listen"></a><a id="accept"></a>
listen(), accept()</h3></div></div></div><a id="id1217096" class="indexterm"></a><a id="id1217103" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">listen</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />           <span class="methodparam"><span class="type">int </span><span class="parameter">acceptance_count</span></span>);</code><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">accept</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />           <span class="methodparam"><span class="type">struct sockaddr* </span><span class="parameter">client_interface</span></span>,<br />           <span class="methodparam"><span class="type">int* </span><span class="parameter">client_size</span></span>);</code><p>After you've bound a stream listener socket to an interface (through
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>),
you then tell the socket to start listening for clients that are
trying to connect. You then pass the socket to <code class="function">accept()</code> which blocks
until a client connects to the listener (the client does this by calling
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>,
passing it a description of the interface to which the listener is bound).</p><p>When <code class="function">accept()</code> returns, the value that it returns directly is a new socket
token; this socket token represents an "accept" socket that was created
as a proxy (on the local machine) for the client. To receive a message
from the client, or to send a message to the client, the listener must
pass the accept socket to the respective stream messaging functions,
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a> and
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a>.</p><p>A listener only needs to invoke <code class="function">listen()</code> once; however, it can accept
more than one client at a time. Often, a listener will spawn an "accept"
thread that loops over the <code class="function">accept()</code> call.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Only stream listeners need to invoke <code class="function">listen()</code>
and <code class="function">accept()</code>. None of the
other socket types (enumerated in the
<a class="link" href="NetworkSockets.html#socket" title="socket(), closesocket()"><code class="function">socket()</code></a>
description) need to call these functions.</p></div></div></div><p><code class="function">listen()</code> takes two parameters: The first is
the socket that you want to have start listening. The second is the length
of the listener's "acceptance count." This is the number of
clients that the listener is willing to accept at a time. If too many
clients try to connect at the same time, the excess clients will be
refused—the connection isn't automatically retried later.</p><p>After the listener starts listening, it must process the client
connections within a certain amount of time, or the connection attempts
will time out.</p><p>If <code class="function">listen()</code> succeeds, the function returns
0; otherwise it returns a negative result and sets the global
<code class="varname">errno</code> to a descriptive constant. Currently, the
only <code class="varname">errno</code> value that
<code class="function">listen()</code> uses, other than -1, is
<code class="constant">EBADF</code>, which means the socket parameter is
invalid.</p><p>The parameters to <code class="function">accept()</code> are the socket
token of the listener (<code class="parameter">socket</code>), a pointer to a <span class="type">sockaddr_in</span>
structure cast as a <span class="type">sockaddr</span> structure
(<code class="parameter">client_interface</code>), and a pointer to an integer
that gives the size of the <code class="parameter">client_interface</code>
parameter (<code class="parameter">client_size</code>).</p><p>The <code class="parameter">client_interface</code> structure returns
interface information (IP address and port number) of the client that's
attempting to connect. See the
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
function for an examination of the <span class="type">sockaddr_in</span> structure.</p><p>The *<code class="parameter">client_size</code> parameter is reset to
give the size of <code class="parameter">client_interface</code> as it's passed
back by the function.</p><p>The value that <code class="parameter">accept()</code> returns directly
is a token that represents the accept socket. After checking the token
value (where a negative result indicates an error), you must cache the
token so you can use it in subsequent
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
calls.</p><p>When you're done talking to the client, remember to call
<a class="link" href="NetworkSockets.html#closesocket"><code class="function">closesocket()</code></a>
on the accept socket that <code class="function">accept()</code> returned. This frees a slot in the
listener's acceptance queue, allowing a possibly frustrated client to
connect to the listener.</p><p>Upon failure, <code class="function">listen()</code> and <code class="function">accept()</code>
return &lt; 0 and set <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">EINVAL</code></span></p></td><td><p>(<code class="function">accept()</code> only) The listener socket isn't bound.</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>(<code class="function">accept()</code> only) The acceptance queue is full.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="select"></a>select()</h3></div></div></div><a id="id1217537" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">select</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket_range</span></span>,<br />           <span class="methodparam"><span class="type">struct fd_set* </span><span class="parameter">read_bits</span></span>,<br />           <span class="methodparam"><span class="type">struct fd_set* </span><span class="parameter">write_bits</span></span>,<br />           <span class="methodparam"><span class="type">struct fd_set* </span><span class="parameter">exception_bits</span></span>,<br />           <span class="methodparam"><span class="type">struct timeval* </span><span class="parameter">timeout</span></span>);</code><p>The <code class="function">select()</code> function returns information about selected sockets. The
<code class="parameter">socket_range</code> parameter tells the function how many sockets to check: It
checks socket numbers up to (<code class="parameter">socket_range</code> - 1). Traditionally, the
<code class="parameter">socket_range</code> parameter is set to 32.</p><p>The <span class="type">fd_set</span> structure that types the next three parameters is a 32-bit mask
that encodes the sockets that you're interested in; this refines the
range of sockets that was specified in the first parameter. You should use
the <code class="function">FD_OP()</code> macros to manipulate the structures that you pass in:</p><table class="variablelist macros"><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="code"><code class="function">FD_ZERO</code>(<code class="parameter">set</code>)</span></span></p></td><td><p>Clears the mask given by set.</p></td></tr><tr><td><p><span class="term"><span class="code"><code class="function">FD_SET</code>(<code class="parameter">socket</code>, <code class="parameter">set</code>)</span></span></p></td><td><p>Adds a socket to the mask.</p></td></tr><tr><td><p><span class="term"><span class="code"><code class="function">FD_CLEAR</code>(<code class="parameter">socket</code>, <code class="parameter">set</code>)</span></span></p></td><td><p>Clears a socket from the mask.</p></td></tr><tr><td><p><span class="term"><span class="code"><code class="function">FD_ISSET</code>(<code class="parameter">socket</code>, <code class="parameter">set</code>)</span></span></p></td><td><p>Returns non-zero if the given socket is already in the mask.</p></td></tr></tbody></table><p>The function passes socket information back to you by resetting the three
<span class="type">fd_set</span> parameters. The parameters themselves represent the types of
information that you can check:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="parameter">read_bits</code></span></p></td><td><p>Tells you if a socket is "ready to read." In other words,
it tells you if a socket has a in-coming message waiting to be read.</p></td></tr><tr><td><p><span class="term"><code class="parameter">write_bits</code></span></p></td><td><p>Tells you if a socket is "ready to write."</p></td></tr><tr><td><p><span class="term"><code class="parameter">exception_bits</code></span></p></td><td><p>Tells you if there's an exception pending on the socket.</p></td></tr></tbody></table><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Currently, only <code class="parameter">read_bits</code> is implemented.
You should pass <code class="constant">NULL</code> as the
<code class="parameter">write_bits</code> and <code class="parameter">exception_bits</code>
parameters.</p></div></div></div><p><code class="function">select()</code> doesn't return until at least
one of the <span class="type">fd_set</span>-specified
sockets is ready for one of the requested operations. To avoid blocking
forever, you can provide a time limit in the final parameter, passed as a
<span class="type">timeval</span> structure.</p><p>In the following example, we check if a given datagram socket has a
message waiting to be read. The <code class="function">select()</code> times out after two seconds:</p><pre class="programlisting example c"><span class="type">bool</span> <code class="function">can_read_datagram</code>(<span class="type">int</span> <code class="parameter">s</code>)
{
   <span class="type">struct timeval</span> <code class="varname">tv</code>;
   <span class="type">struct fd_set</span> <code class="varname">fds</code>;

   <code class="varname">tv</code>.<code class="varname">tv_sec</code> = 2;
   <code class="varname">tv</code>.<code class="varname">tv_usec</code> = 0;

   <span class="comment">/* Initialize (clear) the socket mask. */</span>
   <code class="function">FD_ZERO</code>(&amp;<code class="varname">fds</code>);

   <span class="comment">/* Set the socket in the mask. */</span>
   <code class="function">FD_SET</code>(<code class="parameter">s</code>, &amp;<code class="varname">fds</code>);
   <code class="function">select</code>(32, &amp;<code class="varname">fds</code>, <code class="constant">NULL</code>, <code class="constant">NULL</code>, &amp;<code class="varname">tv</code>);

   <span class="comment">/* If the socket is still set, then it's ready to read. */</span>
   return <code class="function">FD_ISSET</code>(<code class="parameter">s</code>, &amp;<code class="varname">fds</code>);
}</pre><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term">-1</span></p></td><td><p><code class="function">select()</code> failed.</p></td></tr><tr><td><p><span class="term">0</span></p></td><td><p><code class="function">select()</code> timed out.</p></td></tr><tr><td><p><span class="term">1</span></p></td><td><p>Any of the selected sockets was found to be ready.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="send"></a><a id="recv"></a>
send(), recv()</h3></div></div></div><a id="id1218074" class="indexterm"></a><a id="id1218081" class="indexterm"></a><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">send</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />             <span class="methodparam"><span class="modifier">const </span><span class="type">void* </span><span class="parameter">buf</span></span>,<br />             <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>,<br />             <span class="methodparam"><span class="type">int </span><span class="parameter">flags</span></span>);</code><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">send</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />             <span class="methodparam"><span class="type">void* </span><span class="parameter">buf</span></span>,<br />             <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>,<br />             <span class="methodparam"><span class="type">int </span><span class="parameter">flags</span></span>);</code><p>These functions are used to send data to a remote socket, and to
receive data that was sent by a remote socket.
<code class="function">send()</code> and <code class="function">recv()</code> calls
must be complementary: after socket A sends to socket B, socket B needs to
call <code class="function">recv()</code> to pick up the data that A sent.
<code class="function">send()</code> sends its data and returns immediately.
<code class="function">recv()</code> will block until it has some data to
return.</p><p>The <code class="function">send()</code> and
<code class="function">recv()</code> functions can be called by stream or
datagram sockets. However, there are some differences between the way the
functions work when used by these two types of socket:</p><ul class="itemizedlist"><li><p>For a stream listener and a stream client to transmit messages, the
listener must have previously called
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>,
<a class="link" href="NetworkSockets.html#listen" title="listen(), accept()"><code class="function">listen()</code></a>,
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>,
and the client must have called
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>.
Having been properly connected, the two sockets can send and receive as if they were peers.</p></li><li><p>For stream sockets, <code class="function">send()</code> and <code class="function">recv()</code>
can both block: <code class="function">send()</code> blocks
if the amount of data that's sent overwhelms the receiver's ability to
read it, and <code class="function">recv()</code> blocks if there's no message waiting to be read.
You can tell these functions to be non-blocking by setting the sending
socket's no-block socket option (see
<a class="link" href="NetworkSockets.html#setsockopt" title="setsockopt()"><code class="function">setsockopt()</code></a>).</p></li><li><p>If you want to call <code class="function">send()</code> or
<code class="function">recv()</code> through a datagram socket, you
must first
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
the socket. In addition, a receiving datagram
socket must also be bound to an interface (through
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>).
See the
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
description for more information on what that function means
to a datagram socket.</p></li><li><p>Datagram sockets never block on <code class="function">send()</code>, but they can block in a
<code class="function">recv()</code> call. As with stream sockets, you can set a datagram socket to
be non-blocking (for the <code class="function">recv()</code>, as well as for
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>)
through
<a class="link" href="NetworkSockets.html#setsockopt" title="setsockopt()"><code class="function">setsockopt()</code></a>.</p></li></ul><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id1218378"></a>The Parameters</h4></div></div></div><p>The parameters to <code class="function">send()</code> and <code class="function">recv()</code> are:</p><table class="variablelist parameters"><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="parameter">socket</code></span></p></td><td><p>Is, for datagrams and stream client sockets, the local socket
token. In other words, when a datagram or stream client wants to send
or receive data, it passes its own socket token as the first parameter.
The recipient of a <code class="function">send()</code>, or the sender of a <code class="function">recv()</code> is, for these
sockets, already known: It's the socket that's identified by the
previous
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
call.</p><p>For a stream listener, <code class="parameter">socket</code> is the
"accept socket" that was previously returned by an
<a class="link" href="NetworkSockets.html#accept"><code class="function">accept()</code></a>
call. A stream listener can send and
receive data from more than one client at the same time (or, at least,
in rapid succession).</p></td></tr><tr><td><p><span class="term"><code class="parameter">buf</code></span></p></td><td><p>Is a pointer to the data that's being sent, or is used to hold a
copy of the data that was received.</p></td></tr><tr><td><p><span class="term"><code class="parameter">size</code></span></p></td><td><p>Is the allocated size of <code class="parameter">buf</code>, in bytes.</p></td></tr><tr><td><p><span class="term"><code class="parameter">flags</code></span></p></td><td><p>Is currently unused. For now, set it to 0.</p></td></tr></tbody></table></div><p>A successful <code class="function">send()</code> returns the number of bytes that were sent; a
successful <code class="function">recv()</code> returns the number of bytes that were received. Upon
failure, the functions return negative numbers and set
<code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EWOULDBLOCK</code></span></p></td><td><p>The call would block on a non-blocking socket.</p></td></tr><tr><td><p><span class="term"><code class="constant">EINTR</code></span></p></td><td><p>The local socket was interrupted.</p></td></tr><tr><td><p><span class="term"><code class="constant">ECONNRESET</code></span></p></td><td><p>The remote socket disappeared (<code class="function">send()</code> only).</p></td></tr><tr><td><p><span class="term"><code class="constant">ENOTCONN</code></span></p></td><td><p>The socket isn't connected.</p></td></tr><tr><td><p><span class="term"><code class="constant">EADDRINUSE</code></span></p></td><td><p>The interface is busy (datagram sockets only).</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sendto"></a><a id="recvfrom"></a>
sendto(), recvfrom()</h3></div></div></div><a id="id1218671" class="indexterm"></a><a id="id1218678" class="indexterm"></a><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">sendto</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />               <span class="methodparam"><span class="modifier">const </span><span class="type">void* </span><span class="parameter">buf</span></span>,<br />               <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>,<br />               <span class="methodparam"><span class="type">int </span><span class="parameter">flags</span></span>,<br />               <span class="methodparam"><span class="type">struct sockaddr* </span><span class="parameter">to</span></span>,<br />               <span class="methodparam"><span class="type">int </span><span class="parameter">toLen</span></span>);</code><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">recvfrom</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />                 <span class="methodparam"><span class="type">void* </span><span class="parameter">buf</span></span>,<br />                 <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>,<br />                 <span class="methodparam"><span class="type">int </span><span class="parameter">flags</span></span>,<br />                 <span class="methodparam"><span class="type">struct sockaddr* </span><span class="parameter">from</span></span>,<br />                 <span class="methodparam"><span class="type">int* </span><span class="parameter">fromLen</span></span>);</code><p>These functions are used by datagram sockets (only) to send and receive
messages. The functions encode all the information that's needed to find
the recipient or the sender of the desired message, so you don't need to
call
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
before invoking these functions. However, a datagram
socket that wants to receive messages must first call
<a class="link" href="NetworkSockets.html#bind" title="bind()"><code class="function">bind()</code></a>
(in order to
fix itself to an interface that can be specified in a remote socket's
<code class="function">sendto()</code> call).</p><p>The four initial parameters to these function are similar to those for
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>;
the additional parameters are the interface specifications:</p><ul class="itemizedlist"><li><p>For <code class="function">sendto()</code>, the
<code class="parameter">to</code> parameter is a <span class="type">sockaddr_in</span>
structure pointer (cast as a pointer to a <span class="type">sockaddr</span>
structure) that specifies the interface of the remote socket that you're
sending to. The <code class="parameter">toLen</code> parameter is the size of
the <code class="parameter">to</code> parameter.</p></li><li><p>For <code class="function">recvfrom()</code>, the
<code class="parameter">from</code> parameter returns the interface for the
remote socket that sent the message that
<code class="function">recvfrom()</code> received.
*<code class="parameter">fromLen</code> is set to the size of the from
structure. As always, the interface structure is a
<span class="type">sockaddr_in</span> cast as a pointer to a
<span class="type">sockaddr</span>.</p></li></ul><p><code class="function">sendto()</code> never blocks.
<code class="function">recvfrom()</code>, on the other hand, will block until a
message arrives, unless you set the socket to be non-blocking through the
<a class="link" href="NetworkSockets.html#setsockopt" title="setsockopt()"><code class="function">setsockopt()</code></a>
function.</p><p>You can broadcast a message to all interfaces that can be found by
setting <code class="function">sendto()</code>'s target address to
<code class="constant">INADDR_BROADCAST</code>.</p><p>As an alternative to these functions, you can call
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
on a datagram socket and then call
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>.
The
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
call caches the interface information provided in its parameters, and uses this
information the subsequent
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> and
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
calls to "fake" the analogous <code class="function">sendto()</code>
and <code class="function">recvfrom()</code> invocations. For sending, the
implication is obvious: The target of the
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a>
is the interface supplied in the
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>.
The implication for receiving bears description: when you
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
and then call
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>
on a datagram socket, the socket will only accept messages from the interface given in
the
<a class="link" href="NetworkSockets.html#connect" title="connect()"><code class="function">connect()</code></a>
call.</p><p>You can mix <code class="function">sendto()</code>/<code class="function">recvfrom()</code>
calls with
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a>/<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a>.
In other words, connecting a datagram socket doesn't prevent you from calling
<code class="function">sendto()</code> and <code class="function">recvfrom()</code>.</p><p>A successful <code class="function">sendto()</code> returns the number of bytes that were sent; a
successful <code class="function">recvfrom()</code> returns the number of bytes that were received.
Upon failure, the functions return negative numbers and set
<code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EWOULDBLOCK</code></span></p></td><td><p>The call would block on a non-blocking socket.</p></td></tr><tr><td><p><span class="term"><code class="constant">EINTR</code></span></p></td><td><p>The local socket was interrupted.</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">EADDRNOTAVAIL</code></span></p></td><td><p>The specified interface is unrecognized.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code></span></p></td><td><p>All other errors.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="setsockopt"></a>setsockopt()</h3></div></div></div><a id="id1219214" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">setsockopt</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">socket</span></span>,<br />               <span class="methodparam"><span class="type">int </span><span class="parameter">level</span></span>,<br />               <span class="methodparam"><span class="type">int </span><span class="parameter">option</span></span>,<br />               <span class="methodparam"><span class="modifier">const </span><span class="type">void* </span><span class="parameter">buf</span></span>,<br />               <span class="methodparam"><span class="type">uint </span><span class="parameter">size</span></span>);</code><p><code class="function">setsockopt()</code> lets you set certain options that are associated with a
socket. Currently, the Network Kit only recognizes one option: It lets
you declare a socket to be blocking or non-blocking. A blocking socket
will block in a
<a class="link" href="NetworkSockets.html#recv"><code class="function">recv()</code></a> or
<a class="link" href="NetworkSockets.html#recvfrom"><code class="function">recvfrom()</code></a>
call if there's no data to retrieve.</p><p>A blocking socket will block in a
<a class="link" href="NetworkSockets.html#send" title="send(), recv()"><code class="function">send()</code></a> or
<a class="link" href="NetworkSockets.html#sendto" title="sendto(), recvfrom()"><code class="function">sendto()</code></a>
call if the send would overrun the network's ability to keep up with the data.</p><p>A non-blocking socket returns immediately, even if it comes back
empty-handed or is unable to send the data.</p><p>The function's parameters are:</p><table class="variablelist parameters"><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="parameter">socket</code></span></p></td><td><p>Is the socket that you're attempting to affect.</p></td></tr><tr><td><p><span class="term"><code class="parameter">level</code></span></p></td><td><p>Is a constant that indicates where the option is enforced.
Currently, level should always be <code class="constant">SOL_SOCKET</code>.</p></td></tr><tr><td><p><span class="term"><code class="parameter">option</code></span></p></td><td><p>Is a constant that represents the option you're interested in.
The only option constant that does anything right now is <code class="constant">SO_NONBLOCK</code>.
(Two other constants—<code class="constant">SO_REUSEADDR</code> and
<code class="constant">SO_DEBUG</code>—are
recognized, but they aren't currently implemented.)</p></td></tr><tr><td><p><span class="term"><code class="parameter">data</code></span></p></td><td><p>Points to a buffer that's used to toggle or otherwise inform the
option. For the <code class="constant">SO_NONBLOCK</code> option (and other boolean options), you
fill the buffer with zeroes if you want to turn the option off (the
socket will block), and non-zeros if you want to turn it on (the socket
won't block). In the case of a boolean option, a single byte of
zero/non-zero will do.</p></td></tr><tr><td><p><span class="term"><code class="parameter">size</code></span></p></td><td><p>Is the size of the <code class="parameter">data</code> buffer.</p></td></tr></tbody></table><p>Upon failure, <code class="function">setsockopt()</code> returns a
negative number and sets <code class="varname">errno</code> to…</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">EINTR</code></span></p></td><td><p>The local socket was interrupted.</p></td></tr><tr><td><p><span class="term"><code class="constant">EBADF</code></span></p></td><td><p>The <code class="parameter">socket</code> parameter is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">ENOPROTOOPT</code></span></p></td><td><p>Unknown option.</p></td></tr></tbody></table></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BNetEndpoint.html">BNetEndpoint</a>  Up: <a href="TheNetworkKit.html">The Network Kit</a>  Next: <a href="TheOpenGLKit.html">The OpenGL Kit</a> </div><div id="footerB"><div id="footerBL"><a href="BNetEndpoint.html" title="BNetEndpoint"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheNetworkKit.html" title="The Network Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheOpenGLKit.html" title="The OpenGL Kit"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
