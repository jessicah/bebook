<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - System Overview - The Interface Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheInterfaceKit_Overview.html" title="The Interface Kit" /><link rel="prev" href="TheInterfaceKit_Character_Encoding.html" title="Character Encoding" /><link rel="next" href="BAlert_Overview.html" title="BAlert" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="TheInterfaceKit_Character_Encoding.html" title="Character Encoding"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheInterfaceKit_Overview.html" title="The Interface Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BAlert_Overview.html" title="BAlert"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - System Overview - The Interface Kit</div></div><div id="headerB">Prev: <a href="TheInterfaceKit_Character_Encoding.html">Character Encoding</a>  Up: <a href="TheInterfaceKit_Overview.html">The Interface Kit</a>  Next: <a href="BAlert_Overview.html">BAlert</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop"></a>Drag And Drop</h2></div></div></div><p>This is the reference document for constructing
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> objects as used
in BeOS' standard negotiated drag'n'drop actions. If you're reading it
for the first time, you should probably read the entire thing. If you
want to look up something and you're reading this with a browser, you can
jump to any of the following:</p><div class="orderedlist"><ol><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_SimplevsNegotiated" title="Simple vs. Negotiated Drag'n'Drop">Simple vs. Negotiated Drag'n'Drop</a></p></li><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_Basics" title="Basics of Drag and Drop">Basics of Drag and Drop</a></p></li><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_BMessageFormats" title="BMessage Formats in Negotiated Drag'n'Drop">BMessage Formats in Negotiated Drag'n'Drop</a></p><div class="orderedlist"><ol><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_ProtocolForTheDragMessage" title="Protocol for the Drag Message">Protocol for the Drag Message</a></p></li><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_ProtocolForTheNegotiationMessage" title="Protocol for the Negotiation Message">Protocol for the Negotiation Message</a></p></li><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_ProtocolForTheDataMessage" title="Protocol for the Data Message">Protocol for the Data Message</a></p></li></ol></div></li><li><p><a class="xref" href="DragAndDrop.html#DragAndDrop_Summary" title="Summary of the Negotiated Drag'n'Drop Protocol">Summary of the Negotiated Drag'n'Drop Protocol</a></p></li></ol></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_Prerequisites"></a>Prerequisites</h3></div></div></div><p>Drag and Drop makes use of a number of elements of the BeOS programming
kit, and you'll need to be at least reasonably familiar with the
following topics, in order to be comfortable reading this document:</p><ul class="itemizedlist"><li><p>The <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
class, since dragged objects are sent to their targets
as <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
objects. You should understand what a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
is, how to add data to a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
or extract data from it, how to send a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>,
and where to put code to handle incoming
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>s.</p></li><li><p>The <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
class. The drag and drop action is fundamentally a
<acronym class="acronym" title="Graphical User Interface">GUI</acronym>
operation, and
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
objects are the most important objects in handling
<acronym class="acronym">GUI</acronym> events; subclasses of
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
are where you will most often define
code to both initiate a drag, and handle a drop.</p></li><li><p>The Translation Kit, if you wish to make use of the BeOS' built-in
translation abilities to (for example) drag a
<acronym class="acronym" title="Joint Photographics Expert Group">JPEG</acronym> image from an
application, to another application that only understands raw bitmaps.</p></li></ul></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_SimplevsNegotiated"></a>Simple vs. Negotiated Drag'n'Drop</h3></div></div></div><p>Roughly speaking, you can do two different kinds of drag and drop
operations; both appear the same to the user, but they differ in the
complexity of the background communication between the source of the
drag, and the drop target.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id543251"></a>Simple Drag'n'Drop</h4></div></div></div><p>A simple drag'n'drop is one where the action of dragging and dropping
corresponds internally to a single
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
being sent, from the origin
of the drag to the drop target. This was the original drag'n'drop
protocol for the BeOS, and is still highly useful in dragging and
dropping which takes place within a single application, or within a
tightly coupled set of applications which "know about" one another. For
example, you could drag around drawing elements of a drawing program
using this protocol; each drag operation would result in the drawing
application sending a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
within itself, and that
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> would
contain the data necessary to indicate which drawing element had been
moved, and to where. Using the built in drag'n'drop abilities of the BeOS
in this manner will lessen your own workload, since many of the most
basic aspects, such as visually dragging a bitmap around on the screen,
are handled automatically.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_Negotiated"></a>Negotiated Drag'n'Drop</h4></div></div></div><p>A negotiated drag and drop is used in a more general context, when the
originator of a drag and the receiver (drop target) of that drag do not
necessarily know anything about one another. This more general
drag'n'drop is necessary if we wish to make usage of the BeOS,
particularly it's media-related applications, as intuitive to the user as
possible. For example, the user should expect to be able to drag an image
from one graphics program (say a viewer) to another graphics program
(such as a paint program) with no difficulty. However, there are many
different underlying data formats for representing images, and the two
graphics programs will have to negotiate (with the aid of the Translation
kit) for the most suitable or desirable format.</p><p>Note that the negotiated drag'n'drop protocol is not a "hard and fast"
requirement; it is not enforced by the system, and could easily be
modified; for example, you might need a particularly complex negotiation
that takes more steps than defined in the standard. The major user of
negotiated drag'n'drop you are likely to encounter right now is in
Tracker, and we will talk about that in more detail later. Other
applications may support negotiated drag'n'drop or may not. Also note
that a simpler protocol was originally defined, and may still be used by
older applications. It's easy to make your code handle this older
protocol; see the later section on
"<a class="link" href="DragAndDrop.html#DragAndDrop_HandlingDropsFromOldApplications" title="Handling Drops from 'Old' Applications">Handling
the Old Drag'n'Drop Protocol</a>".</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_Basics"></a>Basics of Drag and Drop</h3></div></div></div><p>Let's assume the user is working with two applications, and is going to
drag something from the first application (which we'll call the sender
application) to the second application (which we'll call the receiver
application.) In a nutshell, here are the steps that make up this entire
process:</p><div class="orderedlist"><ol><li><p>Detection: Code in a
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
object of the sender application notices
that the user has clicked on something of interest, and started dragging
it. The monitoring code that notices this is usually spread out between
the
<a class="link" href="BView.html#BView_MouseDown" title="MouseDown()"><code class="methodname">BView::MouseDown()</code></a>
and
<a class="link" href="BView.html#BView_MouseMoved" title="MouseMoved()"><code class="methodname">BView::MouseMoved()</code></a>
functions, and typically
has to differentiate between the start of a real drag and drop, or a
click that might (for example) select an object without dragging it, but
that moves just one or two pixels because the user has a slightly jittery
hand. The drag detection code will typically have to use
<a class="link" href="BView.html#BView_SetMouseEventMask"><code class="methodname">BView::SetMouseEventMask()</code></a>
to temporarily enable full reporting of mouse
movement (which is not normally reported to the application, for
efficiency reasons).</p></li><li><p>Initiation: Once the sender application's detection code has
decided a drag and drop action has been started, it initiates the drag
and drop internally, by creating a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
object containing information
about the nature of the object being dragged, and then passing that
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> to the
<a class="link" href="BView.html#BView_DragMessage" title="DragMessage()"><code class="methodname">BView::DragMessage()</code></a>
function.
<a class="link" href="BView.html#BView_DragMessage" title="DragMessage()"><code class="methodname">BView::DragMessage()</code></a> also
determines how the object being dragged appears visually to the user; you
can pass it a
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a>,
in which case it will drag a cool picture around
the screen, or you can pass it a
<a class="link" href="BRect.html" title="BRect"><code class="classname">BRect</code></a>,
in which case it will drag a
boring old rectangular outline. After calling
<code class="methodname">DragMessage()</code>, the sender's
code should remember to delete its own copy of the
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>. Note: The
sender should not delete the
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a>
it passes to <code class="methodname">DragMessage()</code>; this will
be done by the system</p></li><li><p>Drag: This is the easy part; once the sender application has
initiated the drag, as described in the previous step, dragging a visual
representation around the screen is handled by the system. The next time
application code is invoked is on the . . .</p></li><li><p>Drop: The user releases the mouse button while the mouse is in a
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
of the receiver application. This causes the
<a class="link" href="BView.html#BView_MessageReceived" title="MessageReceived()"><code class="methodname">MessageReceived()</code></a>
function of the recipient <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
to be invoked, with the dragged
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
as its received message. This is the first of three
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> objects that
can be sent as part of a single drag and drop action. We'll call this
first message the drag message. In a simple drag'n'drop, the drag message
can contain just about anything you want it to; since both the sender and
the receiver "know about" one another, they presumably have a common
private protocol, and the receiver can analyze the message and do
whatever is required. In a negotiated drag'n'drop, the drag message does
not typically carry the data that defines the object being dropped; for
example, if you drop a block of text, the message that is dropped
normally does not contain the text that was dragged. Instead, the drag
message contains information about the different formats and methods by
which the sender application may supply the data to the receiver
application, and about which actions the receiver application can request
of the sender application.</p></li><li><p>Negotiation [optional, used in negotiated drag'n'drop]: The
receiver application replies to the drag message with a second message,
which is dispatched back to the sender application using the
<a class="link" href="BMessage.html#BMessage_SendReply" title="SendReply()"><code class="methodname">BMessage::SendReply()</code></a>
function. We'll call this second message the
negotiation message. The receiver creates the negotiation message by
looking through the options supplied by the sender in the drag message,
choosing one or more, and including those option in the message so that
the sender will know which of its possible replies is actually desired.
The negotiation message also contains information about what the receiver
would like the sender to do with the dragged data; for example, if you
drag a file to the Trash, the negotiation message sent back "from" the
Trash will include a request that the sender delete the dragged data.</p></li><li><p>Data Transmission [optional, used in negotiated drag'n'drop]: The
sender examines the negotiation message sent back to it by the receiver,
to find out which available data format the receiver wants the data in.
The sender then packages up the data, and dispatches it off to the
receiver in the data message. (Optionally, the sender can, at the request
of the receiver, create a file through which it passes the data to the
receiver, rather than passing the data directly in the BMessage. We'll
talk about this when we discuss the details of the drop, negotiation, and
data messages.)</p></li><li><p>Completion [optional, used in negotiated drag'n'drop]: The receiver
gets the data message from the sender, extracts the desired data, and
uses it in whatever way it wants.</p></li></ol></div><p>This sounds more complex than it is. A picture is worth a thousand words,
so here is a simplified schematic of the process:</p><div class="mediaobject"><img src="./images/drag_drop_schematic.png" alt="Drag And Drop Schematic" /></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_Example"></a>Example: Simple Drag'n'Drop</h3></div></div></div><p>Before going on to more complex matters, let's see just how simple
"simple" drag'n'drop can be. The code below defines a very simple
application, which lets one drag around a black square in a window. The
application is both the sender (i.e., you click on the square in the
application window to start the drag), and the receiver (you release the
mouse button within the application window, to reposition the square).
Most of the program code is "boilerplate", similar to what would be found
in any application involving a
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>.
Those parts of the code pertaining
specifically to the drag and drop are given in bold.</p><pre class="programlisting example cpp"><span class="comment">/* Drag the black square around using drag'n'drop--a very
   simple-minded program. The DETECTION, INITIATIOIN, DRAG,
   and DROP steps correspond to those of the same name given
   in the overview section, "Basics of Drag and Drop". */</span>

#include &lt;Application.h&gt;
#include &lt;InterfaceKit.h&gt;

<span class="type">rgb_color</span> <code class="varname">black</code> = {0, 0, 0, 64};
<span class="type">const char *</span><code class="constant">APP_SIGNATURE</code> = "application/x-vnd.Be-MyDragnDrop";
<span class="comment">/* The constant below is arbitrary--the fact that is is 'drag' is
   meaningless. However, it MUST be chosen so as not to conflict
   with system-wide BMessage 'what' values--see the BMessage
   documentation for details. */</span>
<span class="bold"><strong><span class="type">const uint32</span> <code class="constant">MY_DRAG_ACTION</code> = 'drag';</strong></span>

class <code class="classname">MyDragDropView</code> : public <code class="classname">BView</code> {
private:
   <code class="classname">BPoint</code> <code class="varname">_button_click</code>;
   <code class="classname">BRect</code> <code class="varname">_SquareSides</code>;

public:
   <code class="methodname">MyDragDropView</code>(<code class="classname">BRect</code> <code class="parameter">rect</code>) : <code class="classname">BView</code>(<code class="parameter">rect</code>, "",
                     <code class="constant">B_FOLLOW_ALL_SIDES</code>, <code class="constant">B_WILL_DRAW</code>) {
      <code class="varname">_SquareSides</code> = <code class="classname">BRect</code>(20, 20, 90, 90);
   }

   <span class="type">void</span> <code class="methodname">Draw</code>(<code class="classname">BRect</code> <code class="parameter">where</code>) {
      <code class="methodname">SetHighColor</code>(<code class="varname">black</code>);
      <code class="methodname">FillRect</code>(<code class="varname">_SquareSides</code>);
   }

   <span class="type">void</span> <code class="methodname">MouseDown</code>( <code class="classname">BPoint</code> <code class="parameter">where</code> ) {
      <span class="bold"><strong><span class="comment">/* 1. DETECTION : Our detection code is pretty
         simple-minded; if the user clicks in the black square,
         they're starting a drag. */</span>
      if (<code class="varname">_SquareSides</code>.<code class="methodname">Contains</code>(<code class="parameter">where</code>)) {
         <span class="comment">// Turn on the event mask for all pointer events,
         // so we'll know when</span>
         <span class="comment">// the user lets go of the mouse button.</span>
         <code class="methodname">SetMouseEventMask</code>( <code class="constant">B_POINTER_EVENTS</code>, 0 );

         <span class="comment">/* 2. INITIATION : Create a BMessage instance, and
            pass it to BView::DragMessage() to start the drag. */</span>
         <span class="type">BMessage*</span> <code class="varname">drag_message</code> = new <code class="classname">BMessage</code>( <code class="constant">MY_DRAG_ACTION</code> );
         <span class="comment">/* Remember, in the drag message,
            where the drag started */</span>
         <code class="varname">drag_message</code>-&gt;<code class="methodname">AddPoint</code>("click_location", <code class="parameter">where</code>);
         <code class="methodname">DragMessage</code>( <code class="varname">drag_message</code>, <code class="varname">_SquareSides</code>, <code class="varname">this</code> );
         <span class="comment">/* 3. DRAG : this is handled by the user and system, we
            don't write any code at all to do the dragging. The
            next step will take place in the MessageReceived()
            function. */</span>

         <span class="comment">/* DON'T FORGET TO DELETE THE MESSAGE AFTER
            YOU'RE DONE*/</span>
         delete <code class="varname">drag_message</code>;</strong></span>
      }
   }; <span class="comment">/* end of MouseDown() */</span>

   <span class="type">void</span> <code class="methodname">MessageReceived</code>(<span class="type">BMessage *</span><code class="parameter">msg</code>) {
      <span class="bold"><strong><span class="comment">/* 4. DROP : MessageReceived() can called for many
         different messages. We're only interested in ones with a
         'what' field of MY_DRAG_ACTION, as was created in
         the MouseDown() function. */</span>
      if (<code class="parameter">msg</code>-&gt;<code class="varname">what</code> == <code class="constant">MY_DRAG_ACTION</code>) {
         <code class="classname">BPoint</code> <code class="varname">clicked</code>;
         <span class="comment">/* We put "click_location" into the original message,
            now we can get it out */</span>
         <code class="parameter">msg</code>-&gt;<code class="methodname">FindPoint</code>("click_location", &amp;<code class="varname">clicked</code>);
         <code class="classname">BPoint</code> <code class="varname">whereto</code>;
         <span class="comment">/* The "_drop_point_" message field is automatically
            inserted by the OS; is is the screen point the
            mouse was on when the drag ended. */</span>
         <code class="parameter">msg</code>-&gt;<code class="methodname">FindPoint</code>("_drop_point_", &amp;<code class="varname">whereto</code>);
         <span class="comment">/* Convert "_drop_point_" to view coordinates. */</span>
         <code class="varname">whereto</code> = <code class="methodname">ConvertFromScreen</code>(<code class="varname">whereto</code>);
         <span class="comment">/* Move the square by the same amount the mouse moved
            in the drag. */</span>
         <code class="varname">_SquareSides</code>.<code class="methodname">OffsetBy</code>(<code class="varname">whereto</code>-<code class="varname">clicked</code>);
         <span class="comment">/* Ensure the view is redrawn */</span>
         <code class="methodname">Invalidate</code>();</strong></span>
      }
   }; <span class="comment">/* end of MessageReceived() */</span>
}; <span class="comment">/* end of MyDragDropView class */</span>

class <code class="classname">MyDragDropWindow</code> : public <code class="classname">BWindow</code> {
   public:
      <code class="methodname">MyDragDropWindow</code>(<code class="classname">BRect</code> <code class="parameter">frame</code>)
         : <code class="classname">BWindow</code>(<code class="parameter">frame</code>, "Drag'n'Drop Example",
                   <code class="constant">B_TITLED_WINDOW</code>, <code class="constant">B_NOT_ZOOMABLE</code>) {

         <code class="varname">interior</code> = new <code class="classname">MyDragDropView</code>(<code class="varname">this</code>-&gt;<code class="methodname">Bounds</code>());
         <code class="methodname">AddChild</code>(<code class="varname">interior</code>);
         <code class="methodname">Show</code>();
      }

      <span class="type">bool</span> <code class="methodname">QuitRequested</code>() {
         <code class="varname">be_app</code>-&gt;<code class="methodname">PostMessage</code>(<code class="constant">B_QUIT_REQUESTED</code>);
         return <code class="constant">true</code>;
      }
   private:
      <span class="type">BView*</span> <code class="varname">interior</code>;
}; <span class="comment">/* end of MyDragDropWindow class */</span>

class <code class="classname">MyDragDropApp</code> : public <code class="classname">BApplication</code> {
   public:
      <code class="classname">MyDragDropApp</code>::<code class="methodname">MyDragDropApp</code>() : <code class="classname">BApplication</code>(<code class="constant">APP_SIGNATURE</code>) {
         <code class="classname">BRect</code> <code class="varname">windowRect</code>;
         <code class="varname">windowRect</code>.<code class="methodname">Set</code>(50,50,349,399);
         new <code class="classname">MyDragDropWindow</code>(<code class="varname">windowRect</code>);
      }
   private:
      <span class="type">MyDragDropWindow*</span> <code class="varname">theWindow</code>;
}; <span class="comment">/* end of MyDragDropApp class */</span>

<span class="comment">/* The "main" function creates and runs the application.*/</span>
<span class="type">int</span> <code class="function">main</code>(<span class="type">void</span>) {
   <span class="type">MyDragDropApp *</span><code class="varname">theApp</code>;
   <code class="varname">theApp</code> = new(<code class="classname">MyDragDropApp</code>);
   <code class="varname">theApp</code>-&gt;<code class="methodname">Run</code>();
   delete <code class="varname">theApp</code>;
}</pre></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_BMessageFormats"></a>BMessage Formats in Negotiated Drag'n'Drop</h3></div></div></div><p>With simple drag and drop, you are free to use
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> more or less as
you wish; you simply define a <code class="varname">what</code> member constant which will uniquely
identify your dropped message to the target, and put whatever data you
wish into the body of the message. The receiver will examine the <code class="varname">what</code>
member of the message and, assuming it understands it at all, should then
know how to extract the data (if any) in the body of the message.</p><p>Negotiated drag and drop is different, since it assumes that the sender
and receiver have no implicit knowledge of each other. In order for the
two ends of the action to communicate effectively, they must agree on a
standard protocol between them. This protocol takes the form of an
agreed-up structure for each of the drag message, negotiation message,
and data message, as described in the following sections.</p><div class="admonition note"><div class="title">Hint</div><div class="graphic"><img class="icon" alt="Hint" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>There's a great little utility called
<a class="link" href="http://www.bebits.com/app/315"><span class="application">ViewIt</span></a>, which should be
available (as part of a package of utilities called Geb's Goodies) on the
usual download sites, such as <a class="link" href="http://www.bebits.com">www.bebits.com</a>.
You can drag anything onto
<span class="application">ViewIt</span>, and it will display the contents of the drag message.</p></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_ProtocolForTheDragMessage"></a>Protocol for the Drag Message</h4></div></div></div><p>The drag message is the one initially sent out by the sender application.
It must be assigned a <code class="varname">what</code> member of <code class="constant">B_SIMPLE_DATA</code> by you, the
programmer. The message fields in the drag message can be split into
those that are provided by you, and those that are filled in
automatically by the system. Let's take a look at each of these.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id544349"></a>Drag Message Fields Filled In by Your Code</h5></div></div></div><p>The following drag message fields will need to be filled in by your code.
Detailed descriptions of these fields are found below.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">be:types</code>, <code class="varname">be:filetypes</code>, and
<code class="varname">be:type_descriptions</code></span></p></td><td><p>These fields
indicates the formats the sender is willing to provide data in, and are
filled in together.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:actions</code></span></p></td><td><p>A list of actions the sender is willing to perform on its
data, at the request of the receiver.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:clip_name</code></span></p></td><td><p>A suggested name for the data being sent, which may be
used at the option of the receiver. This field is optional.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:originator</code>,
<code class="varname">be:originator_data</code></span></p></td><td><p>Used to preserve context
information across asynchronous message sendings.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:data</code></span></p></td><td><p>This was used by the old [obsolete] drag'n'drop protocol, to
contain the data being dragged. You don't need to use it with modern
applications.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id544486"></a>Drag Message Fields Filled In by the System</h5></div></div></div><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">_drop_point_</code>, <code class="varname">_drop_offset_</code></span></p></td><td><p>The values in these fields are set
automatically by the system; do not set them yourself. They give
information about where the drop took place on the screen.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id544524"></a>Detailed Description of the Drag Message Fields</h5></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id544530"></a><code class="varname">be:types</code>, <code class="varname">be:filetypes</code>, and
<code class="varname">be:type_descriptions</code> Fields</h6></div></div></div><p>The main purpose of negotiated drag'n'drop is to come up with an optimal
compromise between the data formats the sender application can provide
something in, and the data formats the receiver can accept that data in.
Accordingly, the three most important message fields in the drag message
are the <code class="varname">be:types</code>
and <code class="varname">be:filetypes</code>
fields; <code class="varname">be:type_descriptions</code>
accompanies the <code class="varname">be:filetypes</code> field, so we'll describe it here also.
Each of these fields is filled with a list of string values.</p><p>Values for these fields will typically be obtained from the Translation
Kit, by asking the Translation Kit which data formats it can provide the
dragged data in, and filling the fields in with the information returned
by the calls to the Translation Kit. (For example, if appropriate
translators are installed on the system, the Translation Kit might be
able to translate a bitmap into any of
<acronym class="acronym" title="Joint Photographics Expert Group">JPEG</acronym>,
<acronym class="acronym" title="Graphics Interchange Format">GIF</acronym>,
<acronym class="acronym" title="Portable Network Graphics">PNG</acronym>, or
<acronym class="acronym" title="Tagged Image File Format">TIFF</acronym> images.)</p><p>The specific meanings of these three fields are as follows:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">be:types</code></span></p></td><td><p>each value in this field indicates a data format the
sender is willing to provide its sent data in. This is a string value
(a MIME string, actually), but you won't normally need to know what the
string actually is, since you'll obtain it from the Translation Kit, or
from a predefined constant. If <code class="varname">be:types</code> consists of a single element
whose value is equal to that in the global variable <code class="constant">B_FILE_MIME_TYPE</code>,
then the sender application is not willing to provide its data in a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>;
the receiver must accept the data through a file, in one of
the formats specified in the <code class="varname">be:filetypes</code> field of this message. If
you want to indicate that your application is willing to send its data
via either of a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
or a file, then add <code class="constant">B_FILE_MIME_TYPE</code> as the
last element of <code class="varname">be:types</code>, after all of the types which can be sent in
a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:filetypes</code></span></p></td><td><p>Similar <code class="varname">be:types</code>, but a values in this field
indicate formats in which the sender is willing to provide its data via
a file. This can make a lot of sense; for example, if what the user is
dragging around is a 30 megabyte video clip, you probably don't want to
pass this in a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>.
In most cases, <code class="varname">be:filetypes</code> will be
identical to <code class="varname">be:types</code>. If your application isn't willing to pass data
via a file, then it doesn't matter what (if anything) you put into
<code class="varname">be:filetypes</code>.</p><div class="admonition important"><div class="title">Important</div><div class="graphic"><img class="icon" alt="Important" width="32" src="./images/admonitions/Warning_32.png" /><div class="text"><p>See the section below in
"<a class="xref" href="DragAndDrop.html#DragAndDrop_PassingDataInAFile" title="Passing Data in a File">Passing Data in a File</a>"
for further notes on this, if you plan to make use of it.</p></div></div></div></td></tr><tr><td><p><span class="term"><code class="varname">be:type_descriptions</code></span></p></td><td><p>This is just a user-friendly description of
the corresponding format in <code class="varname">be:filetypes</code>. It may be displayed
onscreen to the user when the user can choose between several different
data formats during a file save operation. It is not used otherwise.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id544808"></a>The <code class="varname">be:actions</code> Field</h6></div></div></div><p>In negotiated drag'n'drop, the sender and receiver negotiate not only the
format of the sent data, but also the action performed on that data.
Should the data be copied from the sender to the receiver, moved from the
sender to the receiver, or something else? The first part of this
"actions negotiation" takes place in the drag message via the
<code class="varname">be:actions</code> field.</p><p><code class="varname">be:actions</code> contains a list of values (32-bit integers actually) which
define the actions the sender is will to perform at the request of the
receiver. No action will actually be carried out until and unless the
receiver requests it. The possible action requests are given by the
following constants:</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_COPY_TARGET</code></span></p></td><td><p>The sender is willing to provide a copy of the
dragged object.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MOVE_TARGET</code></span></p></td><td><p>The sender is willing to move the target over to the
receiver; if the receiver requests this, then after the sender sends a
copy of the data, it will delete its own copy.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_LINK_TARGET</code></span></p></td><td><p>The sender is willing to provide a link to the
target. [xxx what does this mean exactly? If the sender is the Tracker,
I can understand it, but in Chris' document, <code class="constant">B_LINK_TARGET</code> is listed as
a general action, not one that is Tracker-specific.]</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TRASH_TARGET</code></span></p></td><td><p>The sender is willing to delete its data without
even sending it. This is useful if, for example, you want your user to
be able to drag something from the application to the Tracker's
wastebasket icon, and have the object removed from the application as a
result.</p></td></tr></tbody></table><p>In addition to the above four "standard" actions, there are a few actions
which can be carried out specifically when the Tracker is the sender
application [xxx does the Tracker have to be the receiver as well? If so,
should we even document these actions?]:</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_COPY_SELECTION_TO</code></span></p></td><td><p>One or more elements (files, directories) are
selected in a Tracker window; the Tracker is willing to copy these
files to an <span class="type">entry_ref</span> type destination, which will be supplied in a
<code class="varname">refs</code> field in the negotiation message, should the receiver
application choose this action.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MOVE_SELECTION_TO</code></span></p></td><td><p>One or more elements (files, directories) are
selected in a Tracker window; the Tracker is willing to move these
files to an <span class="type">entry_ref</span> type destination, which will be supplied in a
<code class="varname">refs</code> field in the negotiation message, should the receiver
application choose this action.</p></td></tr></tbody></table><p>[xxx Chris' document implies the Tracker can also make links due to a
specific Tracker action, is there something like a <code class="constant">B_LINK_SELECTION_TO</code>?]</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545017"></a>The <code class="varname">be:clip_name</code> Field</h6></div></div></div><p>This is an easy one. If present (it doesn't have to be), it contains a
string suggesting a name for the data which will be sent. This name may
be used by the receiver; for example, if data is dragged onto the
Tracker, the Tracker will try to use the value in <code class="varname">be:clip_name</code> as the
basis for the name of the clipping file it creates from the data.
However, the receiver is under no obligation to pay attention to
<code class="varname">be:clip_name</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545052"></a><code class="varname">be:originator</code> and
<code class="varname">be:originator_data</code> Fields</h6></div></div></div><p>Let's say you're a sender application, and you've asynchronously sent off
a drag message. Then you receive a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>.
Is it the reply to your
original message? And if so, how do you access data about the original
drag (such as where the mouse was clicked) you might need in order to
complete the data message? Since the original drag message was sent
asynchronously, your application went merrily on its way immediately
after sending, and no longer remembers what the heck it dragged off
before. What do you do? This is where <code class="varname">be:originator</code> and
<code class="varname">be:originator_data</code> come in.</p><ul class="itemizedlist"><li><p><code class="varname">be:originator</code> should be filled in with something that identifies
your application to itself; it doesn't really matter what. We'll see
how this is used in a second…</p></li><li><p><code class="varname">be:originator_data</code> can be filled in with data about the drag that
you'll need to use later on in the drag'n'drop negotiation. This could
be something as simple as the mouse position, or it could be a much
more complex piece of information about the context of the application
at the time the drag was started. It's up to you, and of course, you
don't have to use <code class="varname">be:orginator_data</code> at all.</p></li></ul><p>If you fill in <code class="varname">be:originator</code>
and <code class="varname">be:originator_data</code> properly on all
of your outgoing drag messages, then here is what your app can do when it
receives a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
that may be a negotiation message responding to a
previously sent (asynchronous) drag message:</p><div class="orderedlist"><ol><li><p>Your app checks to ensure that the incoming message has the correct
format for a negotiation message (we'll describe the format of
negotiation messages in a bit). If it does, then go on…</p></li><li><p>Your app uses
<a class="link" href="BMessage.html#BMessage_IsReply"><code class="methodname">BMessage::IsReply()</code></a>
to check if the incoming message
is a reply to a previous message.</p></li><li><p>If the incoming message is in fact a reply, your app uses
<a class="link" href="BMessage.html#BMessage_Previous"><code class="methodname">BMessage::Previous()</code></a>
to obtain the original message; the message the
incoming message was sent in reply to.</p></li><li><p>Now, your app can examine <code class="varname">be:originator</code> in the original message,
to see if it recognizes that value as indicating a drag message sent out
by itself. If it does, then the incoming <code class="classname">BMessage</code> is in fact a
negotiation message in response to your original drag message; your app
can extract necessary context data from <code class="varname">be:originator_data</code>, and go on
to construct and send the data message.</p></li></ol></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545245"></a>The <code class="varname">be:data</code> Field</h6></div></div></div><p>This field was used in the original drag'n'drop protocol to carry the
dragged data. It is not used in the negotiated drag'n'drop protocol.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545264"></a>The <code class="varname">_drop_point_</code> Field</h6></div></div></div><p>This field contains a BPoint giving the screen coordinate of the mouse
cursor, when the drag was ended (i.e. when the mouse button was released
and the data dropped.) It's added automatically by the system—you don't
create or add to it yourself.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545285"></a>The <code class="varname">_drop_offset_</code> Field</h6></div></div></div><p>Whether you have your application display a bitmap or a rectangular
outline during a drag, the dragged area occupies a rectangle. (Though it
may not appear so to the user, since with a bitmap, sections of the
bitmap can be transparent). <code class="varname">_drop_offset_</code> gives
as a <a class="link" href="BPoint.html" title="BPoint"><code class="classname">BPoint</code></a> the
distance from the top left point of the dragged area to the position of
the mouse cursor within that dragged area. [xxx I think this is correct
but just want to be sure.]It's added automatically by the system—you
don't create or add to it yourself.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_PassingDataInAFile"></a>Passing Data in a File</h5></div></div></div><p>Using a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
to pass a large amount of data from one application to
another may not be desirable; at the extreme, you may not have enough
memory to accommodate the entire BMessage. If you need to pass large
amounts of data in a drag'n'drop operation, you may prefer to do so via a
file.</p><p>As far as passing data by a file goes, the sender application can
indicate one of two things when sending the drag message to the receiver:</p><ul class="itemizedlist"><li><p>The sender can offer to pass the data in a file, as well as via a
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>.
The receiver then has the option of accepting the data either
through a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>,
or through a file.</p></li><li><p>The sender can state that it will only pass the data via a file. The
receiver app, if it wants the data, had better agree.</p></li></ul><p>In both cases, the sender's ability to send data via a file is indicated
by a value in the drag message's <code class="varname">be:types</code>
field of <code class="constant">B_FILE_MIME_TYPE</code>. If
<code class="constant">B_FILE_MIME_TYPE</code> is the first entry in the
<code class="varname">be:types</code> field, then the
sender will pass data only in a file, and anything else in
<code class="varname">be:types</code>
will be ignored; if there are entries in <code class="varname">be:types</code> before a value of
<code class="constant">B_FILE_MIME_TYPE</code>, then those entries are types with which the sender is
prepared to send data directly in the data message.</p><p>If the sender has indicated, via the presence of a <code class="constant">B_FILE_MIME_TYPE</code> value
in <code class="varname">be:types</code>, that it is willing to pass data via a file, then the
formats in which it can provide that file are listed in the
<code class="varname">be:filetypes</code> field. If a value of
<code class="constant">B_FILE_MIME_TYPE</code> is not present
somewhere in the <code class="varname">be:types</code> field, then the sender is not able to pass
data via a file, and any values in the <code class="varname">be:filetypes</code> field will be
ignored.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_ProtocolForTheNegotiationMessage"></a>Protocol for the Negotiation Message</h4></div></div></div><p>When the receiver application receives the initial drag message from the
sender application, it examines the data message in that message, to
ascertain what actions the sender application can carry out, and how it
can provide the desired data in the final drag message. Using this
information, the receiver application formulates the negotiation message,
which it sends back as a reply to the original drag message using the
<a class="link" href="BMessage.html#BMessage_SendReply" title="SendReply()"><code class="methodname">BMessage::SendReply()</code></a> function.</p><p>A Negotiation Message is Characterized by its <code class="varname">what</code> Member</p><p>Recall that the drag message constructed by the sender application
contained (among other things) a <code class="varname">be:actions</code> message field, which
indicated the actions the sender was willing to perform upon the dragged
data. The allowable actions (at the time of this writing—further actions
may be added in the future) are given by the following constants:</p><ul class="itemizedlist"><li><p><code class="constant">B_COPY_TARGET</code></p></li><li><p><code class="constant">B_MOVE_TARGET</code></p></li><li><p><code class="constant">B_LINK_TARGET</code></p></li><li><p><code class="constant">B_TRASH_TARGET</code></p></li><li><p><code class="constant">B_MOVE_SELECTION_TO</code> (for Tracker drags only.)</p></li><li><p><code class="constant">B_COPY_SELECTION_TO</code> (for Tracker drags only.)</p></li></ul><p>When constructing the negotiation message, the receiver application will
choose one of the actions listed in the data message's <code class="varname">be:types</code> message
field (remember, not all allowable actions will necessarily be listed in
this message field), and use that action as the value of the what member
in the negotiation message. This will inform the sender application of
which of the possible actions is desired by the receiver.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545603"></a>Message Fields in the Negotiation Message</h5></div></div></div><p>In addition to the action contained in the what member, the negotiation
message may also contain a number of message fields; exactly which
message fields are defined depends somewhat on the requested action. The
allowable message fields are:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">be:types</code></span></p></td><td><p>One or more strings denoting the data formats the
receiver is willing to accept the dragged data in, as part of the data
message. These should be chosen from the <code class="varname">be:types</code> field of the drag
message. If the <code class="varname">be:types</code> field of the negotiation message contains
more than one value, then the first value is the format the receiver
would prefer to get data in, but the sender may choose any of the
formats, at its discretion. Of course, if the sender has indicated in
the drag message that it will only pass data through a file, values in
the negotiation message's <code class="varname">be:types</code> message field will be ignored when
the negotiation message gets back to the sender.</p></td></tr><tr><td><p><span class="term"><code class="varname">be:filetypes</code></span></p></td><td><p>One or more strings denoting the data formats the
receiver is willing to accept file data in, assuming of course that the
sender indicated in its drag message that it was willing to provide the
dragged data via a file. The values in the negotiation message's
<code class="varname">be:filetypes</code> field should be chosen from those provided in the drag
message's <code class="varname">be:filetypes</code> field. It the negotiation message contains
more than one value in <code class="varname">be:filetypes</code>, then it would prefer to be given
a file in the first listed format, but the sender is free to use any of
the listed formats.</p></td></tr><tr><td><p><span class="term"><code class="varname">directory</code></span></p></td><td><p>If the sender decides to (or is forced to) pass data to
the receiver via a file, the <span class="type">entry_ref</span> stored in the <code class="varname">directory</code> field
of the negotiation message indicates the directory that the file should
be created in.</p></td></tr><tr><td><p><span class="term"><code class="varname">name</code></span></p></td><td><p>If the sender decides to (or is forced to) pass data to the
receiver via a file, the string in this field should be used as the
name of the file. Note: the receiver should create the file before
deciding on a file name, to ensure that file name is in fact available,
and will remain available.</p></td></tr></tbody></table><p>Of course, you can leave out fields that don't apply to a particular
action. For example, if the receiver chooses <code class="constant">B_TRASH_TARGET</code> as the action
(by putting a value of <code class="constant">B_TRASH_TARGET</code> into the <code class="varname">what</code> member of the
negotiation message), no message fields are required; in fact, the sender
doesn't even need to respond to a request of <code class="constant">B_TRASH_TARGET</code> with a data
message, it simply has to delete the dragged data.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_ProtocolForTheDataMessage"></a>Protocol for the Data Message</h4></div></div></div><p>The data message is the third and final message sent as part of a
negotiated drag'n'drop. It is sent in response to a negotiation message,
using the
<a class="link" href="BMessage.html#BMessage_SendReply" title="SendReply()"><code class="methodname">BMessage::SendReply()</code></a>
function, and is sent only if the sender
application has elected to pass the dragged data directly in a message.
If the sender application passes data to the receiver via a file, no data
message is sent. [xxx just want to check, is this correct? It would seem
you'd want to at least send confirmation that the write was successful.
Or should the receiver just do a node monitor kind of thing?]</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id545816"></a>When Data Is Sent in the Data Message</h5></div></div></div><p>If the sender elects to send the dragged data directly in the data
message, then the data message will be constructed with the following
structure:</p><ul class="itemizedlist"><li><p>A <code class="varname">what</code> member set to the value of the <code class="constant">B_MIME_DATA</code> constant.</p></li><li><p>A single message field, whose name indicates the type of mime data
being sent, and whose contents consist of the data itself. For example,
if you drag some text from one text processing window to another, the
final data message (after the drop and negotiation messages have been
sent) might contain a message field named "text/plain", which contains
the text being dragged. Alternatively, if you dragged text from an HTML
viewer, the data message might (depending on the negotiations) have a
single field called "text/html", which would contain the text including
the html formatting statements.</p></li></ul><p>Note that when the data messages arrives at the receiver, it may contain
more than the single message field described above; other message fields
might be added automatically, by parts of the system. However, the
message field above is the only one you add.</p></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_HandlingDropsFromOldApplications"></a>Handling Drops from 'Old' Applications</h3></div></div></div><p>Negotiated drag'n'drop was defined relatively recently; older
applications may still use the "old-style" drag'n'drop. It's simple for
your application to take into the account that it might be a receiver for
such a drop.</p><p>Under the old style drag'n'drop, a single message was sent from the
sender to the receiver, with a what member of <code class="constant">B_MIME_DATA</code>, and the value
of the dragged data in the <code class="varname">be:data</code> message field. [xxx how is the type
of the enclosed data determined?] Since your receiver application will
need to monitor for
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>s
with a what field of <code class="constant">B_MIME_DATA</code> (i.e. your
application will need to look for the data messages that might occur as
part of a negotiated drag'n'drop), it's simple to add in a bit more code
that handles the fact that such a message may occur without being part of
a negotiation, and may contain a <code class="varname">be:data</code> field.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_Summary"></a>Summary of the Negotiated Drag'n'Drop Protocol</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_DragMessage"></a>Drag Message</h4></div></div></div><p>The structure of a drag message is as follows:</p><ul class="itemizedlist"><li><p>A <code class="varname">what</code> member of <code class="constant">B_SIMPLE_DATA</code></p></li><li><p>Three message fields <code class="varname">be:types</code>, <code class="varname">be:filetypes</code> and
<code class="varname">be:type_descriptions</code>, which contain (respectively) formats the sender
is willing to pass data in via the data message, formats the sender is
willing to pass data via a file, and user-friendly descriptions of the
different formats.</p></li><li><p>A message field <code class="varname">be:actions</code> containing a list of actions the sender
is willing to perform at the request of the receiver.</p></li><li><p>An optional field <code class="varname">be:clip_name</code> indicating a suggested name for a
clipping.</p></li><li><p>Optional fields <code class="varname">be:originator</code> and <code class="varname">be:originator_data</code>, which may
be used to pass store context information during an asynchronous
drag'n'drop.</p></li><li><p><code class="varname">_drop_point_</code> and <code class="varname">_drop_offset_</code>, which are filled in by the
system, and provide information about where the mouse cursor was
positioned when the drop took place.</p></li></ul></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_NegotiationMessage"></a>Negotiation Message</h4></div></div></div><p>The structure of a negotiation message is as follows:</p><ul class="itemizedlist"><li><p>A <code class="varname">what</code> member, which is one of the values extracted from the
<code class="varname">be:actions</code> field of the drag message to which this negotiation
message is a reply.</p></li><li><p>A list of formats in the <code class="varname">be:types</code> message field, chosen from the
list provided in the <code class="varname">be:types</code> of the drag message. This indicates the
formats the receiver is willing to accept data in. If the value given
by the global constant <code class="constant">B_FILE_MIME_TYPE</code> is in the list, then the
receiver is willing to accept data through a file, as well as through
the data message. Note that values after an entry of <code class="constant">B_FILE_MIME_TYPE</code>
will be ignored; thus, if <code class="constant">B_FILE_MIME_TYPE</code> is the first element of
<code class="varname">be:types</code>, then the receiver is willing to accept data only through a
file. If there is more than one value in <code class="varname">be:types</code>, the first value is
the preferred format.</p></li><li><p>A list of formats in the <code class="varname">be:filetypes</code> message field, which
indicates file formats the receiver is willing to accept, if data is
passed in a file. This is meaningful only if <code class="varname">be:types</code> contains a
value of <code class="constant">B_FILE_MIME_TYPE</code> as one of its values. If there is more than
one value in <code class="varname">be:filetypes</code>, the first value is the preferred format.</p></li><li><p><code class="varname">directory</code> and <code class="varname">name</code> fields, which should be provided if the
negotiation message has stated that the receiver is willing to accept
data via a file. <code class="varname">directory</code> is an <span class="type">entry_ref</span> specifying where the file
should be placed, and <code class="varname">name</code> is a string specifying the desired name of
the file.</p></li></ul></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DragAndDrop_DataMessage"></a>Data Message</h4></div></div></div><p>The structure of a data message is as follows:</p><ul class="itemizedlist"><li><p>A <code class="varname">what</code> member of <code class="constant">B_MIME_DATA</code>.</p></li><li><p>A single data message field added by the program code; the name of
this field is the mime type of the enclosed data, and the value of this
field is the data itself. For example, a block of plain text would be
sent in a message field named "text/plain". The mime type for the
enclosed data is chosen from the list of formats in the <code class="varname">be:types</code>
field of the negotiation message to which this message is a reply.</p></li></ul></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="TheInterfaceKit_Character_Encoding.html">Character Encoding</a>  Up: <a href="TheInterfaceKit_Overview.html">The Interface Kit</a>  Next: <a href="BAlert_Overview.html">BAlert</a> </div><div id="footerB"><div id="footerBL"><a href="TheInterfaceKit_Character_Encoding.html" title="Character Encoding"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheInterfaceKit_Overview.html" title="The Interface Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BAlert_Overview.html" title="BAlert"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
