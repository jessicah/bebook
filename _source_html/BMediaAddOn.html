<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Media Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheMediaKit.html" title="The Media Kit" /><link rel="prev" href="BFileInterface.html" title="BFileInterface" /><link rel="next" href="BMediaBufferDecoder.html" title="BMediaBufferDecoder" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BFileInterface.html" title="BFileInterface"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BMediaBufferDecoder.html" title="BMediaBufferDecoder"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Media Kit</div></div><div id="headerB">Prev: <a href="BFileInterface.html">BFileInterface</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BMediaBufferDecoder.html">BMediaBufferDecoder</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn"></a>BMediaAddOn</h2></div></div></div><a id="id1131418" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td>–</td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">media/MediaAddOn.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libmedia.so</code></td></tr><tr><td>Allocation:</td><td>Constructor only</td></tr></tbody></table></td><td>
<a class="link overview" href="BMediaAddOn_Overview.html" title="BMediaAddOn">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BMediaAddOn.html#BMediaAddOn_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BMediaAddOn.html#BMediaAddOn_MemberFunctions">Member Functions</a></span></li><li><span class="section"><a href="BMediaAddOn.html#BMediaAddOn_GlobalFunctions">Global C Functions</a></span></li><li><span class="section"><a href="BMediaAddOn.html#BMediaAddOn_DefinedTypes">Defined Types</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_Constructor"></a>BMediaAddOn()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">explicit</h5></div></div></div><code class="constructorsynopsis cpp"><span class="methodname">BMediaAddOn</span>(<span class="methodparam"><span class="type">image_id </span><span class="parameter">image</span></span>);</code><p>This is the <code class="classname">BMediaAddOn</code> constructor; your derived class should perform
whatever initialization is necessary in the constructor, and handle any
activities necessary in order to properly comply with the media add-on
protocol.</p><p>The <span class="type">image_id</span> identifies the add-on image from which the add-on was
loaded. Your <code class="function">make_media_addon()</code> function should be sure to save the image
ID passed to it and pass that value through to the <code class="classname">BMediaAddOn</code>
constructor, or the Media Kit will be unhappy with you.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_Destructor"></a>~BMediaAddOn</h4></div></div></div><code class="destructorsynopsis cpp"><span class="methodname">~BMediaAddOn()</span>();</code><p>You should never delete a <code class="classname">BMediaAddOn</code> yourself; the Media Server will do
this when the add-on is no longer needed. However, if you're implementing
a media add-on, this is a good place to handle disposing of memory you've
allocated.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_AutoStart"></a>AutoStart()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">AutoStart</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">index</span></span>,<br />                           <span class="methodparam"><span class="type"><span class="classname">BMediaNode</span>** </span><span class="parameter">outNode</span></span>,<br />                           <span class="methodparam"><span class="type">int32* </span><span class="parameter">outInternalID</span></span>,<br />                           <span class="methodparam"><span class="type">bool* </span><span class="parameter">outHasMore</span></span>) <span class="modifier"> = 0</span>;</code><p>If
<a class="link" href="BMediaAddOn.html#BMediaAddOn_WantsAutoStart" title="WantsAutoStart()"><code class="methodname">WantsAutoStart()</code></a>
returns <code class="constant">true</code>, you'll get repeated calls to
<code class="methodname">AutoStart()</code> when your add-on is loaded.</p><p>Your <code class="methodname">AutoStart()</code> function should be implemented to instantiate nodes to
your liking, one for each call to <code class="methodname">AutoStart()</code>.
Each time <code class="methodname">AutoStart()</code> is
called, <code class="parameter">index</code> will be one higher than the previous pass. After creating
the new node, store a pointer to it in <code class="parameter">outNode</code>,
and set <code class="parameter">outInternalID</code> to
the internal ID of the flavor represented by that node.</p><p>Before returning, set <code class="parameter">outHasMore</code> to
<code class="constant">true</code> if there are more nodes to
start, and <code class="constant">false</code> if there aren't.</p><p>Return <code class="constant">B_OK</code> if you return a valid node. If there aren't any more nodes to
be started, return <code class="constant">B_BAD_INDEX</code>. If the specified index fails, but there
may be other nodes to start, return <code class="constant">B_ADDON_FAILED</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_CountFlavors"></a>CountFlavors()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">int32 </span><span class="methodname">CountFlavors</span>();</code><p>Implement this hook function to return the number of flavors your add-on
can deal with.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_GetConfigurationFor"></a>GetConfigurationFor()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetConfigurationFor</span>(<span class="methodparam"><span class="type"><span class="classname">BMediaNode</span>* </span><span class="parameter">node</span></span>,<br />                                     <span class="methodparam"><span class="type"><span class="classname">BMessage</span>* </span><span class="parameter">config</span></span>);</code><p>Implement this function to save information about how the given <code class="parameter">node</code> is
configured into the specified message. This lets the node's configuration
be saved to disk for future rehydration using
<a class="link" href="BMediaAddOn.html#BMediaAddOn_InstantiateNodeFor" title="InstantiateNodeFor()"><code class="methodname">InstantiateNodeFor()</code></a>.</p><p>Note that it's not reasonable to save information about what connections
are routed through the node, since the other nodes probably won't exist
when the node is rehydrated. It's up to the application to reconstruct
the connections itself, as it wishes.</p><p>If the configuration information is stashed into <code class="parameter">config</code> without errors,
return <code class="constant">B_OK</code>; otherwise, return an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_GetFileFormatList"></a>GetFileFormatList()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetFileFormatList</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">flavorID</span></span>,<br />                                   <span class="methodparam"><span class="type">media_file_format* </span><span class="parameter">outWritableFormats</span></span>,<br />                                   <span class="methodparam"><span class="type">int32 </span><span class="parameter">inWriteItems</span></span>,<br />                                   <span class="methodparam"><span class="type">int32* </span><span class="parameter">outWriteItems</span></span>,<br />                                   <span class="methodparam"><span class="type">media_file_format* </span><span class="parameter">outReadableFormats</span></span>,<br />                                   <span class="methodparam"><span class="type">int32 </span><span class="parameter">inReadItems</span></span>,<br />                                   <span class="methodparam"><span class="type">int32* </span><span class="parameter">outReadItems</span></span>,<br />                                   <span class="methodparam"><span class="type">void* </span><span class="parameter">reserved</span></span>);</code><p>If your add-on provides nodes that can either read or write media data
from files, you should implement this function to describe the
<span class="type">media_file_format</span>s you can read and write.</p><p>On input, the <code class="parameter">flavorID</code> argument
indicates which flavor you should return information about. You should fill
the array <code class="parameter">outWritableFormats</code> with a list of the
file formats the corresponding flavor can write, and the
<code class="parameter">outReadableFormats</code> array with a list of the file
formats the flavor can read. The <code class="parameter">inWriteItems</code>
and <code class="parameter">inReadItems</code> arguments indicate how many
items can be stored in each array.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Both <code class="parameter">outWritableFormats</code> and
<code class="parameter">outReadableFormats</code> can be <code class="constant">NULL</code>. Don't write
into these arrays if the corresponding pointer is <code class="constant">NULL</code>.</p></div></div></div><p>On output, you should set <code class="parameter">outWriteItems</code> to be the number of file formats
you can write—even if it's larger than <code class="parameter">inWriteItems</code>. This lets the
caller resize the array and call you back to get the complete list.
Likewise, <code class="parameter">outReadItems</code> should be set to the number of file formats you
can read.</p><p>The <code class="parameter">reserved</code> argument isn't currently used, and should always be
specified as <code class="constant">NULL</code>.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Only implement this function if your node derives from
<a class="link" href="BFileInterface.html" title="BFileInterface"><code class="classname">BFileInterface</code></a>.</p></div></div></div><p>If an error occurs, return an appropriate error code; otherwise, return
<code class="constant">B_OK</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_GetFlavorAt"></a>GetFlavorAt()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetFileFormatList</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">flavorNum</span></span>,<br />                                   <span class="methodparam"><span class="modifier">const </span><span class="type">flavor_info** </span><span class="parameter">outInfo</span></span>);</code><p>Implement <code class="methodname">GetFlavorAt()</code> to
store in <code class="parameter">outInfo</code> a pointer to a static
<span class="type"><a class="link" href="BMediaAddOn.html#flavor_info" title="flavor_info">flavor_info</a></span>
structure describing one flavor supported by your add-on. The
data pointed to by <code class="parameter">outInfo</code> will be copied by the Media Kit after
<code class="methodname">GetFlavorAt()</code> returns. For example, if your add-on only supports one
flavor:</p><pre class="programlisting example cpp"><span class="type">flavor_info</span> <code class="varname">flavorInfo</code>;

<span class="type">status_t</span> <code class="classname">MyMediaAddOn</code>::<code class="methodname">GetFlavorAt</code>(<span class="type">int32</span> <code class="parameter">n</code>, <span class="type">const flavor_info**</span> <code class="parameter">out_info</code>)
{
   if (<code class="parameter">n</code> != 0) {
      return <code class="constant">B_ERROR</code>;
   }

   <code class="varname">flavorInfo</code>-&gt;<code class="varname">internal_id</code> = <code class="parameter">n</code>;
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">name</code> = <code class="function">strdup</code>("My Media Node");
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">info</code> = <code class="function">strdup</code>("This node receives video from spy cameras
   at area pizza parlors and determines which one is the least busy.");
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">kinds</code> = <code class="constant">B_BUFFER_CONSUMER</code> | <code class="constant">B_PHYSICAL_OUTPUT</code>;
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">flavor_flags</code> = 0;
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">possible_count</code> = 0;

   <span class="comment">// Set up the list of input formats. We only support
   // raw video input.</span>

   <code class="varname">flavorInfo</code>-&gt;<code class="varname">in_format_count</code> = 1;
   <span class="type">media_format*</span> <code class="varname">aFormat</code> = new <span class="type">media_format</span>;
   <code class="varname">aFormat</code>-&gt;<code class="varname">type</code> = <code class="constant">B_MEDIA_RAW_VIDEO</code>;
   <code class="varname">aFormat</code>-&gt;<code class="varname">u</code>.<code class="varname">raw_video</code> = <span class="type">media_raw_video_format</span>::<code class="varname">wildcard</code>;
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">in_formats</code> = <code class="varname">aFormat</code>;

   <span class="comment">// We don't output.</span>

   <code class="varname">flavorInfo</code>-&gt;<code class="varname">out_format_count</code> = 0;
   <code class="varname">flavorInfo</code>-&gt;<code class="varname">out_formats</code> = 0;

   <span class="comment">// And set up the result pointer</span>

   *<code class="varname">out_info</code> = <code class="varname">flavorInfo</code>;
   return <code class="constant">B_OK</code>;
}</pre><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>If you allocate memory for the
<span class="type"><a class="link" href="BMediaAddOn.html#flavor_info" title="flavor_info">flavor_info</a></span>
structure, be sure to
discard it before your add-on is unloaded (the destructor is a good place
to do this). If you forget to discard the memory, you'll leak, and that
can be really embarrassing.</p></div></div></div><p>If <code class="parameter">flavorNum</code> is greater than
<code class="methodname">CountFlavors()</code>-1 (in other words, if the
requested number is larger than the number of flavors you support),
return <code class="constant">B_ERROR</code>. Otherwise, return
<code class="constant">B_OK</code> or, if an error occurs, an
appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_ImageID"></a>ImageID()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">image_id </span><span class="methodname">ImageID</span>();</code><p>Returns the add-on's image ID, as specified by the
<code class="classname">BMediaAddOn</code>
<a class="link" href="BMediaAddOn.html#BMediaAddOn_Constructor" title="BMediaAddOn()">constructor</a>.</p><p>Your <code class="function">make_media_addon()</code> function should be sure to save the image ID
passed to it and pass that value through to the <code class="classname">BMediaAddOn</code> constructor,
or the Media Kit will be unhappy with you.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_InitCheck"></a>InitCheck()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">InitCheck</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">char** </span><span class="parameter">outFailureText</span></span>);</code><p>Implement this hook function to set <code class="parameter">outFailureText</code> to point to a static
text buffer that contains a message explaining why your add-on failed the
most recent operation requested by the Media Server. This doesn't include
errors reported by nodes instantiated by your add-on, but only to errors
caused directly by your <code class="classname">BMediaAddOn</code>-derived object.</p><p>The buffer pointed to by <code class="parameter">outFailureText</code> shouldn't go away until the
add-on is reloaded or a new call to <code class="methodname">InitCheck()</code> is made.</p><p>Also returned is the actual result code from that operation; if all is
well, <code class="constant">B_OK</code> should be returned.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_InstantiateNodeFor"></a>InstantiateNodeFor()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type"><span class="classname">BMediaNode</span>* </span><span class="methodname">InstantiateNodeFor</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">flavor_info* </span><span class="parameter">info</span></span>,<br />                                       <span class="methodparam"><span class="type"><span class="classname">BMessage</span>* </span><span class="parameter">config</span></span>,<br />                                       <span class="methodparam"><span class="type">status_t* </span><span class="parameter">outError</span></span>);</code><p>Given the information in <code class="parameter">info</code> (which might be a copy of information you
previously returned from a
<a class="link" href="BMediaAddOn.html#BMediaAddOn_GetFlavorAt" title="GetFlavorAt()"><code class="methodname">GetFlavorAt()</code></a>
call), you should instantiate a
new object of the node class referenced by <code class="parameter">info</code>'s
<code class="varname">internal_id</code> field and
return a pointer to that node.</p><p>The <code class="parameter">config</code> message might contain
information saved by a previous instance of the same flavor node, and
should be used to configure the new node if possible.
<code class="parameter">config</code> will never be
<code class="constant">NULL</code>, although it may not have any fields of
interest in it.</p><p>The simplest implementation of this function, in which there's no
configuration possible, might look like this:</p><pre class="programlisting example cpp"><code class="classname">BMediaNode</code>* <code class="classname">BMyConsumerAddOn</code>::<code class="methodname">InstantiateNodeFor</code>(<span class="type">const flavor_info*</span> <code class="parameter">info</code>,
            <code class="classname">BMessage</code>* <code class="parameter">config</code>, <span class="type">status_t*</span> <code class="parameter">outError</code>) {
   return new <code class="classname">MyConsumerNode</code>((<span class="type">const char *</span>) "My Consumer Node");
}</pre><p>If a new instance can't be instantiated, set
<code class="parameter">outError</code> to an appropriate
error code and return <code class="constant">NULL</code>. Otherwise, set
<code class="parameter">outError</code> to <code class="constant">B_OK</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_SniffRef"></a><a id="BMediaAddOn_SniffType"></a>
<a id="BMediaAddOn_SniffTypeKind"></a>
SniffRef(), SniffType(), SniffTypeKind()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SniffRef</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">entry_ref&amp; </span><span class="parameter">file</span></span>,<br />                          <span class="methodparam"><span class="type"><span class="classname">BMimeType</span>* </span><span class="parameter">outMimeType</span></span>,<br />                          <span class="methodparam"><span class="type">float* </span><span class="parameter">outQuality</span></span>,<br />                          <span class="methodparam"><span class="type">int32* </span><span class="parameter">outInternalID</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SniffType</span>(<span class="methodparam"><span class="type"><span class="classname">BMimeType</span>&amp; </span><span class="parameter">mimeType</span></span>,<br />                           <span class="methodparam"><span class="type">float* </span><span class="parameter">outQuality</span></span>,<br />                           <span class="methodparam"><span class="type">int32* </span><span class="parameter">outInternalID</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SniffTypeKind</span>(<span class="methodparam"><span class="type"><span class="classname">BMimeType</span>&amp; </span><span class="parameter">mimeType</span></span>,<br />                               <span class="methodparam"><span class="type">uint64 </span><span class="parameter">inKinds</span></span>,<br />                               <span class="methodparam"><span class="type">float* </span><span class="parameter">outQuality</span></span>,<br />                               <span class="methodparam"><span class="type">int32* </span><span class="parameter">outInternalID</span></span>,<br />                               <span class="methodparam"><span class="type">void* </span><span class="parameter">reserved</span></span>);</code><p>If your add-on supports
<a class="link" href="BFileInterface.html" title="BFileInterface"><code class="classname">BFileInterface</code></a>
nodes, you may implement <code class="methodname">SniffRef()</code>. Given the
specified <code class="parameter">file</code>, examine the file and set
<code class="parameter">outMimeType</code> to describe the
<acronym class="acronym">MIME</acronym> type of the file.</p><p>Additionally, you can implement <code class="methodname">SniffType()</code> to report how well your
add-on can handle a file containing data of the MIME type specified by
<code class="parameter">mimeType</code>.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>If your node deals with both producers and consumers, you shouldn't
implement <code class="methodname">SniffType()</code>. Implement
<code class="methodname">SniffTypeKind()</code> instead. If
<code class="methodname">SniffTypeKind()</code> is implemented,
<code class="methodname">SniffType()</code> won't be called.</p></div></div></div><p><code class="methodname">SniffTypeKind()</code> limits the
search to the kinds indicated by <code class="parameter">inKinds</code>. This
lets the caller indicate whether it's looking for a consumer or a
producer, for example.</p><p>In any case, you should also store, in <code class="parameter">outQuality</code>, a value representing
the quality level at which your add-on can interpret the data in the file
(where 0.0 means you can't handle it well at all and 1.0 means you can
handle it perfectly), and in <code class="parameter">outInternalID</code>, the internal ID of the flavor
that handles the data.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Don't implement these functions if your add-on doesn't support
<a class="link" href="BFileInterface.html" title="BFileInterface"><code class="classname">BFileInterface</code></a>
nodes.</p></div></div></div><p>Return <code class="constant">B_OK</code> if you've successfully
identified the node; otherwise, return
an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_WantsAutoStart"></a>WantsAutoStart()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">bool </span><span class="methodname">WantsAutoStart</span>();</code><p>Implement this hook function to return <code class="parameter">true</code> if there are one or more node
flavors supported by your add-on that want to be instantiated
automatically when the add-on is loaded, instead of waiting until they're
explicitly instantiated by an application's request later. Return <code class="constant">false</code>
otherwise.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_GlobalFunctions"></a>Global C Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="make_media_addon"></a>make_media_addon()</h4></div></div></div><a id="id1133192" class="indexterm"></a><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype"><tr><td><code class="funcdef"><span class="type"><code class="classname">BMediaAddOn</code>*</span> <span class="function">make_media_addon</span>(</code></td></tr></table></div><p><code class="function">make_media_addon()</code> is the global C function your add-on needs to
implement in order to make itself available to the world. It will be
called when the Media Server loads your add-on, and you should return an
instance of your <code class="classname">BMediaAddOn</code>-derived class, with the appropriate
overrides to the hook functions.</p><p>The <code class="parameter">addonID</code> argument is your add-on's
image ID. Your <code class="function">make_media_addon()</code>
function should be sure to save the image ID passed to it and pass that
value through to the <code class="classname">BMediaAddOn</code>
<a class="link" href="BMediaAddOn.html#BMediaAddOn_Constructor" title="BMediaAddOn()">constructor</a>, or the Media Kit will be
unhappy with you.</p><p>This function can be quite simple:</p><pre class="programlisting example cpp"><code class="classname">BMediaAddOn</code>* <code class="function">make_media_addon</code>(<span class="type">image_id</span> <code class="parameter">myImage</code>) {
   return new <code class="classname">MyConsumerAddOn</code>(<code class="parameter">myImage</code>);
}</pre><p>It simply creates an instance of the add-on object (in this case,
<code class="classname">MyConsumerAddOn</code>), and returns it.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BMediaAddOn_DefinedTypes"></a>Defined Types</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="dormant_flavor_info"></a>dormant_flavor_info</h4></div></div></div><a id="id1133327" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaAddOn.h</code></p><pre class="programlisting definition cpp"><span class="type">struct dormant_flavor_info</span> : public <span class="type">flavor_info</span>, public <code class="classname">BFlattenable</code> {
   <code class="methodname">dormant_node_info()</code>;
   virtual <code class="methodname">~dormant_node_info()</code>;
   <code class="methodname">dormant_flavor_info</code>(<span class="type">const dormant_flavor_info&amp;</span>);
   <span class="type">dormant_flavor_info&amp;</span> <code class="methodname">operator=</code>(<span class="type">const dormant_flavor_info&amp;</span>);
   <span class="type">dormant_flavor_info&amp;</span> <code class="methodname">operator=</code>(<span class="type">const flavor_info&amp;</span>);

   <span class="type">dormant_node_info</span> node_info;

   <span class="type">void</span> <code class="methodname">set_name</code>(<span class="type">const char*</span> <code class="parameter">in_name</code>);
   <span class="type">void</span> <code class="methodname">set_info</code>(<span class="type">const char*</span> <code class="parameter">in_info</code>);
   <span class="type">void</span> <code class="methodname">add_in_format</code>(<span class="type">const media_format&amp;</span> <code class="parameter">in_format</code>);
   <span class="type">void</span> <code class="methodname">add_out_format</code>(<span class="type">const media_format&amp;</span> <code class="parameter">out_format</code>);

   virtual <span class="type">bool</span> <code class="methodname">IsFixedSize</code>() const;
   virtual <span class="type">type_code</span> <code class="methodname">TypeCode</code>() const;
   virtual <span class="type">ssize_t</span> <code class="methodname">FlattenedSize</code>() const;
   virtual <span class="type">status_t</span> <code class="methodname">Flatten</code>(<span class="type">void*</span> <code class="parameter">buffer</code>, <span class="type">ssize_t</span> <code class="parameter">size</code>) const;
   virtual <span class="type">status_t</span> <code class="methodname">Unflatten</code>(<span class="type">type_code</span> <code class="parameter">c</code>, <span class="type">const void*</span> <code class="parameter">buf</code>, <span class="type">ssize_t</span> <code class="parameter">size</code>);

private:
   <span class="type">void</span> <code class="methodname">assign_atoms</code>(<span class="type">const flavor_info&amp;</span> <code class="parameter">that</code>);
   <span class="type">media_addon_id</span> <code class="varname">addon</code>;
   <span class="type">int32</span> <code class="varname">flavor_id</code>;
   <span class="type">char</span> <code class="varname">name</code>[<code class="constant">B_MEDIA_NAME_LENGTH</code>];
private:
   <span class="type">char</span> <code class="varname">reserved</code>[128];
};</pre><p>The <span class="type">dormant_flavor_info</span> structure describes a flavor
in a dormant node.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="dormant_node_info"></a>dormant_node_info</h4></div></div></div><a id="id1133611" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaAddOn.h</code></p><pre class="programlisting definition cpp"><span class="type">struct dormant_node_info</span> {
   <code class="methodname">dormant_node_info</code>();
   <code class="methodname">~dormant_node_info</code>();
   <span class="type">media_addon_id</span> <code class="varname">addon</code>;
   <span class="type">int32</span> <code class="varname">flavor_id</code>;
   <span class="type">char</span> <code class="varname">name</code>[<code class="constant">B_MEDIA_NAME_LENGTH</code>];
private:
   <span class="type">char</span> <code class="varname">reserved</code>[128];
};</pre><p>The <span class="type">dormant_node_info</span> structure describes a node that resides in an
add-on and that may not be in memory. You might use it when issuing the
<a class="link" href="BMediaRoster.html#BMediaRoster_InstantiateDormantNode" title="InstantiateDormantNode()"><code class="methodname">BMediaRoster::InstantiateDormantNode()</code></a>
to instantiate a node, for example.</p><p>The <code class="varname">addon</code> field indicates the ID number of the media add-on in which the
node resides, and the <code class="varname">flavor_id</code> is the flavor ID internal to that add-on
indicating which flavor the node should represent. The <code class="varname">name</code> field is the
node's name.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="flavor_info"></a>flavor_info</h4></div></div></div><a id="id1133727" class="indexterm"></a><p>Declared in: <code class="filename">media/MediaAddOn.h</code></p><pre class="programlisting definition cpp"><span class="type">struct flavor_info</span> {
   <span class="type">char*</span> <code class="varname">name</code>;
   <span class="type">char*</span> <code class="varname">info</code>;
   <span class="type">uint64</span> <code class="varname">kinds</code>;
   <span class="type">uint32</span> <code class="varname">flavor_flags</code>;
   <span class="type">int32</span> <code class="varname">internal_id</code>;
   <span class="type">int32</span> <code class="varname">possible_count</code>;

   <span class="type">int32</span> <code class="varname">in_format_count</code>;
   <span class="type">uint32</span> <code class="varname">in_format_flags</code>;
   <span class="type">const media_format*</span> <code class="varname">in_formats</code>;

   <span class="type">int32</span> <code class="varname">out_format_count</code>;
   <span class="type">uint32</span> <code class="varname">out_format_flags</code>;
   <span class="type">const media_format*</span> <code class="varname">out_formats</code>;

   <span class="type">uint32</span> <code class="varname">_reserved_</code>[16];

private:
   <span class="type">flavor_info&amp;</span> <code class="methodname">operator=</code>(<span class="type">const flavor_info&amp;</span> <code class="parameter">other</code>);
};</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">name</code> and <code class="varname">info</code></span></p></td><td><p>Provide a human-readable name, and information
about the flavor.</p></td></tr><tr><td><p><span class="term"><code class="varname">kinds</code></span></p></td><td><p>Should be set to the node kind. See
<a class="link" href="TheMediaKit_Constants.html#Enums_node_kind" title="node_kind"><span class="type">node_kind</span></a></p></td></tr><tr><td><p><span class="term"><code class="varname">flavor_flags</code></span></p></td><td><p>Contains flags providing additional information
about the flavor.</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_FLAVOR_IS_GLOBAL</code></span></dt><dd><p>The flavor will be forced into the Media Add-on
Server, and only one instance of it will exist.</p></dd><dt><span class="term"><code class="constant">B_FLAVOR_IS_LOCAL</code></span></dt><dd><p>The flavor will be forced into the loading application,
and many instances of it may exist.</p></dd></dl><p>If neither flag is specified, the Media Kit will decide what to do with
the flavor.</p></td></tr><tr><td><p><span class="term"><code class="varname">internal_id</code></span></p></td><td><p>Is an internal ID number that your add-on can use to
identify the flavor; the flavor will be requested by the Media Kit using
this ID number.</p></td></tr><tr><td><p><span class="term"><code class="varname">possible_count</code></span></p></td><td><p>Specifies to the Media Kit the maximum number of
instances of your node can be in existence at the same time. For example,
if your node provides support for a particular sound card, this value
should be equal to the number of cards you support that are currently
installed in the computer.</p></td></tr><tr><td><p><span class="term"><code class="varname">in_format_count</code></span></p></td><td><p>Specifies how many input formats the flavor supports.</p></td></tr><tr><td><p><span class="term"><code class="varname">in_formats</code></span></p></td><td><p>Is a list of all the input formats supported by the flavor.</p></td></tr><tr><td><p><span class="term"><code class="varname">in_format_flags</code></span></p></td><td><p>Provides informational flags about the flavor's inputs.
There currently aren't any defined flags, so set this field to 0.</p></td></tr><tr><td><p><span class="term"><code class="varname">out_format_count</code></span></p></td><td><p>Specifies how many output formats the flavor supports.</p></td></tr><tr><td><p><span class="term"><code class="varname">out_formats</code></span></p></td><td><p>Is a list of all the output formats supported by the flavor.</p></td></tr><tr><td><p><span class="term"><code class="varname">out_format_flags</code></span></p></td><td><p>Provides informational flags about the flavor's outputs.
There currently aren't any defined flags, so set this field to 0.</p></td></tr></tbody></table></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BFileInterface.html">BFileInterface</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BMediaBufferDecoder.html">BMediaBufferDecoder</a> </div><div id="footerB"><div id="footerBL"><a href="BFileInterface.html" title="BFileInterface"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BMediaBufferDecoder.html" title="BMediaBufferDecoder"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
