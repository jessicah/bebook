<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Application Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheApplicationKit.html" title="The Application Kit" /><link rel="prev" href="BCursor.html" title="BCursor" /><link rel="next" href="BInvoker.html" title="BInvoker" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BCursor.html" title="BCursor"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheApplicationKit.html" title="The Application Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BInvoker.html" title="BInvoker"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Application Kit</div></div><div id="headerB">Prev: <a href="BCursor.html">BCursor</a>  Up: <a href="TheApplicationKit.html">The Application Kit</a>  Next: <a href="BInvoker.html">BInvoker</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler"></a>BHandler</h2></div></div></div><a id="id662353" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td>–</td></tr><tr><td>Mix-in Classes:</td><td><a class="link" href="BArchivable.html" title="BArchivable"><code class="classname">BArchivable</code></a></td></tr><tr><td>Declared In:</td><td><code class="filename">app/Handler.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libbe.so</code></td></tr><tr><td>Allocation:</td><td>–</td></tr></tbody></table></td><td>
<a class="link overview" href="BHandler_Overview.html" title="BHandler">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BHandler.html#BHandler_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BHandler.html#BHandler_HookFunctions">Hook Functions</a></span></li><li><span class="section"><a href="BHandler.html#BHandler_MemberFunctions">Member Functions</a></span></li><li><span class="section"><a href="BHandler.html#BHandler_StaticFunctions">Static Functions</a></span></li><li><span class="section"><a href="BHandler.html#BHandler_ArchivedFields">Archived Fields</a></span></li><li><span class="section"><a href="BHandler.html#BHandler_ScriptingSuites">Scripting Suites and Properties</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Constructor"></a>BHandler()</h4></div></div></div><div class="synopsisgroup">
<code class="constructorsynopsis cpp"><span class="methodname">BHandler</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">char* </span><span class="parameter">name</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>

<code class="constructorsynopsis cpp"><span class="methodname">BHandler</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">archive</span></span>);</code>
</div><p>
Initializes the <code class="classname">BHandler</code> by assigning it a <code class="parameter">name</code>
and registering it with the messaging system. <code class="classname">BHandler</code>s can also
be reconstructed from a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>
<code class="parameter">archive</code>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Destructor"></a>~BHandler()</h4></div></div></div><code class="destructorsynopsis cpp"><span class="modifier">virtual </span><span class="methodname">~BHandler</span>();</code><p>
Deletes any <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>s assigned to the <code class="classname">BHandler</code>.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_HookFunctions"></a>Hook Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_MessageReceived"></a>MessageReceived()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">MessageReceived</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>);</code><p>
Implemented by derived classes to respond to messages that are received by
the <code class="classname">BHandler</code>. The default
implementation of this function responds only to scripting requests. It
passes all other messages to the next handler by calling that object's
version of <code class="methodname">MessageReceived()</code>.
</p><p>
A typical <code class="methodname">MessageReceived()</code> implementation distinguishes
between messages by looking at its command constant (i.e. the
<code class="varname">what</code> field). For example:
</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">MyHandler</code>::<code class="methodname">MessageReceived</code>(<span class="type"><a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>*</span> <code class="parameter">message</code>)
{
   switch ( <code class="parameter">message</code>-&gt;<code class="varname">what</code> ) {
   case <code class="constant">COMMAND_ONE</code>:
      <code class="methodname">HandleCommandOne</code>();
      break;

   case <code class="constant">COMMAND_TWO</code>:
      <code class="methodname">HandleCommandTwo</code>();
      break;
   ...
   default:
      <span class="emphasis"><em><code class="classname">baseClass</code></em></span>::<code class="methodname">MessageReceived</code>(<code class="parameter">message</code>);<a id="msgreceived.callbase"></a><span class="callout"><img src="./images/callouts/1.png" alt="1" /></span>
      break;
   ...
   }
}</pre><div class="calloutlist"><table summary="Callout list"><tr><td><a href="#msgreceived.callbase"><span class="callout"><img src="./images/callouts/1.png" alt="1" /></span></a> </td><td><p>It's essential that all unhandled messages are passed to the base class
implementation of <code class="methodname">MessageReceived()</code>, as shown
here. The handler chain model depends on it.</p></td></tr></table></div><p>
If the message comes to the end of the line—if it's not recognized
and there is no next handler—the <code class="classname">BHandler</code>
version of this function sends a
<a class="link" href="TheApplicationKit_MessageConstants.html#B_MESSAGE_NOT_UNDERSTOOD" title="B_MESSAGE_NOT_UNDERSTOOD"><code class="constant">B_MESSAGE_NOT_UNDERSTOOD</code></a>
reply to notify the message source.
</p><div class="admonition important"><div class="title">Important</div><div class="graphic"><img class="icon" alt="Important" width="32" src="./images/admonitions/Warning_32.png" /><div class="text"><p>Do not delete the argument message when you're done with. It doesn't belong to you.</p></div></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Archive"></a>Archive()</h4></div></div></div><p>
See <a class="link" href="BArchivable.html#BArchivable_Archive" title="Archive()"><code class="methodname">BArchivable::Archive()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_GetSupportedSuites"></a>GetSupportedSuites()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetSupportedSuites</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>);</code><p>
Implemented by derived classes to report the suites of messages and
specifiers they understand. This function is called in response to either a
<code class="constant">B_GET_PROPERTIES</code> scripting message for the
"Suites" property or a
<code class="constant">B_GET_SUPPORTED_SUITES</code> message.
</p><p>
Each derived class should add the names of the suites it implements to the
<code class="varname">suites</code> array of <code class="parameter">message</code>. Each item in
the array is a <acronym class="acronym">MIME</acronym> string with the "suite"
supertype. In addition, the class should add corresponding flattened <a class="link" href="BPropertyInfo.html" title="BPropertyInfo"><code class="classname">BPropertyInfo</code></a> objects
in the <code class="varname">messages</code> array. A typical implementation of
<code class="methodname">GetSupportedSuites()</code> looks like:
</p><pre class="programlisting example cpp"><span class="type">status_t</span> <code class="classname">MyHandler</code>::<code class="methodname">GetSupportedSuites</code>(<span class="type">BMessage*</span> <code class="parameter">message</code>)
{
   <code class="parameter">message</code>-&gt;<code class="methodname">AddString</code>("suites", "suite/vnd.Me-my_handler"));
   <code class="classname">BPropertyInfo</code> <code class="varname">prop_info</code>(<code class="varname">prop_list</code>);
   <code class="parameter">message</code>-&gt;<code class="methodname">AddFlat</code>("messages", <code class="varname">prop_info</code>);

   return <code class="classname">BHandler</code>::<code class="methodname">GetSupportedSuites</code>(<code class="parameter">message</code>);
}</pre><p>
The value returned by <code class="methodname">GetSupportedSuites()</code> is added
to <code class="parameter">message</code> in the <span class="type">int32</span>
<code class="varname">be:error</code> field.
</p><p>
<code class="classname">BHandler</code>'s version
of this function adds the universal suite "suite/vnd.Be-handler"
to <code class="parameter">message</code> then returns <code class="constant">B_OK</code>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_LockLooper"></a><a id="BHandler_LockLooperWithTimeout"></a>
<a id="BHandler_UnlockLooper"></a>
LockLooper(), LockLooperWithTimeout(), UnlockLooper()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">LockLooper</span>();</code><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">LockLooperWithTimeout</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">timeout</span></span>);</code><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">UnlockLooper</span>();</code><p>
These are "smart" versions of <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>'s locking functions
(<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">BLooper::Lock()</code></a> et.
al.). The difference between the versions is that these functions retrieve
the handler's looper and lock it (or unlock it) in a pseudo-atomic
operation, thus avoiding a race condition. Anytime you're tempted to write
code such as this:
</p><pre class="programlisting example cpp"><span class="comment">/* DON'T DO THIS */</span>
if (<code class="varname">myHandler</code>-&gt;<code class="methodname">Looper</code>()-&gt;<code class="methodname">Lock</code>()) {
   ...
   <code class="varname">myHandler</code>-&gt;<code class="methodname">Looper()</code>-&gt;<code class="varname">Unlock</code>();
}</pre><p>
Don't do it. Instead, do this:
</p><pre class="programlisting example cpp"><span class="comment">/* DO THIS INSTEAD */</span>
if (<code class="varname">myHandler</code>-&gt;<code class="methodname">LockLooper</code>()) {
   ...
   <code class="varname">myHandler</code>-&gt;<code class="methodname">UnlockLooper</code>();
}</pre><p>
Except for an additional return value in
<code class="methodname">LockLooperWithTimeout()</code>, these functions are
identical to their <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> analogues. See
<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">BLooper::Lock()</code></a>
for details.
</p><p>
<code class="methodname">LockLooper()</code> returns <code class="constant">true</code> if
it was able to lock the looper, or if it's already locked by the calling
thread, and <code class="constant">false</code> otherwise. If the handler changes
loopers during the call, <code class="constant">false</code> is returned.
</p><p>
<code class="methodname">LockLooperWithTimeout()</code> returns:
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
The looper was successfully locked.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TIMED_OUT</code>.</span></p></td><td><p>
The call timed out without locking the looper.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>
This handler's looper is invalid.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MISMATCHED_VALUES</code>.</span></p></td><td><p>
The handler switched loopers during the call.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Looper"></a>Looper()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">BLooper* </span><span class="methodname">Looper</span>() <span class="modifier">const</span>;</code><p>
Returns the <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>
object that the <code class="classname">BHandler</code> has been added to. The
function returns <code class="constant">NULL</code> if the object hasn't been added
to a <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>. A
<code class="classname">BHandler</code> can be associated with only one <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> at a time.
</p><p>
Note that a <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>
object automatically adds itself (as a handler) to itself (as a looper),
and a <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>
automatically adds its child views. To explicitly add a handler to a
looper, you call <a class="link" href="BLooper.html#BLooper_AddHandler" title="AddHandler(), RemoveHandler(), HandlerAt(), CountHandlers(), IndexOf()"><code class="methodname">BLooper::AddHandler()</code></a>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifier"></a>ResolveSpecifier()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">BHandler* </span><span class="methodname">ResolveSpecifier</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>,<br />                                   <span class="methodparam"><span class="type">int32 </span><span class="parameter">index</span></span>,<br />                                   <span class="methodparam"><span class="type">BMessage* </span><span class="parameter">specifier</span></span>,<br />                                   <span class="methodparam"><span class="type">int32 </span><span class="parameter">what</span></span>,<br />                                   <span class="methodparam"><span class="modifier">const </span><span class="type">char* </span><span class="parameter">property</span></span>);</code><p>
Implemented by derived classes to determine the proper handler for a
scripting message. The message is targeted to the
<code class="classname">BHandler</code>, but the specifiers may indicate that it
should be assigned to another object. It's the job of
<code class="methodname">ResolveSpecifier()</code> to examine the current
specifier (or more, if necessary) and return the object that should either
handle the message or look at the next specifier. This function is called
before the message is dispatched and before any filtering functions are
called.
</p><p>
The first argument, <code class="parameter">message</code>, points to the scripting
message under consideration. The current specifier is passed in
<code class="parameter">specifier</code>; it will be at index
<code class="parameter">index</code> in the specifier array of message. Finally,
<code class="parameter">what</code> contains the what data member of
<code class="parameter">specifier</code> while <code class="parameter">property</code>
contains the name of the targetted property.
</p><p>
<code class="methodname">ResolveSpecifier()</code> returns a pointer to the next
<code class="classname">BHandler</code> that should look at the message. To
identify the <code class="classname">BHandler</code>, it tries these methods, in
order:
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifier_Method1"></a>Method 1:</h5></div></div></div><p>If the
<code class="parameter">specifier</code> identifies a
<code class="classname">BHandler</code> belonging to another <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>, it should send the
<code class="parameter">message</code> to the <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> and return
<code class="constant">NULL</code>. The message will be handled in the message loop
of the other <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>;
it won't be further processed in this one. For example, a
<code class="classname">BHandler</code> that kept a list of proxies might use code
like the following:
</p><pre class="programlisting example cpp">if ( (<code class="function">strcmp</code>(<code class="varname">property</code>, "Proxy") == 0)
      &amp;&amp; (<code class="varname">what</code> == <code class="constant">B_INDEX_SPECIFIER</code>) ) {
   <span class="type">int32</span> <code class="varname">i</code>;
   if ( <code class="varname">specifier</code>-&gt;<code class="methodname">FindInt32</code>("index", <code class="varname">i</code>) == <code class="constant">B_OK</code> ) {
      <span class="type">MyProxy*</span> <code class="varname">proxy</code> = (<span class="type">MyProxy*</span>)<code class="varname">proxyList</code>-&gt;<code class="methodname">ItemAt</code>(<code class="varname">i</code>);
      if ( <code class="varname">proxy</code> ) {
            <code class="varname">message</code>-&gt;<code class="methodname">PopSpecifier</code>();
            if ( <code class="varname">proxy</code>-&gt;<code class="methodname">Looper</code>() != <code class="methodname">Looper</code>() ) {
               <code class="varname">proxy</code>-&gt;<code class="methodname">Looper</code>()-&gt;<code class="methodname">PostMessage</code>(<code class="varname">message</code>, <code class="varname">proxy</code>);
               return <code class="constant">NULL</code>;
            }
      }
      . . .
   }
   . . .
}</pre><p>
Since this function resolved the specifier at <code class="parameter">index</code>,
it calls <a class="link" href="BMessage.html#BMessage_PopSpecifier"><code class="methodname">PopSpecifier()</code></a>
to decrement the index before forwarding the message. Otherwise, the next
handler would try to resolve the same specifier.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifier_Method2"></a>Method 2:</h5></div></div></div><p>If the <code class="parameter">specifier</code> picks out another
<code class="classname">BHandler</code> object belonging to the same <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>,
<code class="methodname">ResolveSpecifier()</code> can return that
<code class="classname">BHandler</code>. For example:
</p><pre class="programlisting example cpp">if ( <code class="varname">proxy</code> ) {
   <code class="varname">message</code>-&gt;<code class="methodname">PopSpecifier</code>();
   if ( <code class="varname">proxy</code>-&gt;<code class="methodname">Looper</code>() != <code class="methodname">Looper</code>() ) {
      <code class="varname">proxy</code>-&gt;<code class="methodname">Looper</code>()-&gt;<code class="methodname">PostMessage</code>(<code class="varname">message</code>, <code class="varname">proxy</code>);
      return <code class="constant">NULL</code>;
   }
   else {
      return <code class="varname">proxy</code>;
   }
}</pre><p>
This, in effect, puts the returned object in the
<code class="classname">BHandler</code>'s place as the designated handler for the
message. The <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>
will give the returned handler a chance to respond to the message or
resolve the next specifier.
</p><p>
Again, <a class="link" href="BMessage.html#BMessage_PopSpecifier"><code class="methodname">PopSpecifier()</code></a>
should be called so that an attempt isn't made to resolve the same
specifier twice.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifier_Method3"></a>Method 3:</h5></div></div></div><p>
If it can resolve all remaining
specifiers and recognizes the message as one that the
<code class="classname">BHandler</code> itself can handle, it should return the
<code class="classname">BHandler</code> (<code class="varname">this</code>). For example:
</p><pre class="programlisting example cpp">if ( (<code class="function">strcmp</code>(<code class="varname">property</code>, "Value") == 0) &amp;&amp;
     (<code class="varname">message</code>-&gt;<code class="varname">what</code> == <code class="constant">B_GET_PROPERTY</code>) )
   return <code class="varname">this</code>;</pre><p>
This confirms the <code class="classname">BHandler</code> as the message target.
<code class="methodname">ResolveSpecifier()</code> won't be called again, so it's
not necessary to call <a class="link" href="BMessage.html#BMessage_PopSpecifier"><code class="methodname">PopSpecifier()</code></a>
before returning.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifier_Method4"></a>Method 4:</h5></div></div></div><p>
If it doesn't recognize the
property or can't resolve the specifier, it should call (and return the
value returned by) the inherited version of
<code class="methodname">ResolveSpecifier()</code>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ResolveSpecifierExamples"></a>Examples</h5></div></div></div><p>
The <a class="link" href="BApplication.html" title="BApplication"><code class="classname">BApplication</code></a> object takes the first path when it resolves a specifier for a "Window" property; it sends the message to the specified <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> and returns <code class="constant">NULL</code>. A <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> follows the second path when it resolves a specifier for a "View" property; it returns the specified <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>. Thus, a message initially targeted to the <a class="link" href="BApplication.html" title="BApplication"><code class="classname">BApplication</code></a> object can find its way to a <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>.
</p><p>
<code class="classname">BHandler</code>'s version of
<code class="methodname">ResolveSpecifier()</code> recognizes a
<code class="constant">B_GET_PROPERTY</code> <code class="parameter">message</code> with a
direct <code class="parameter">specifier</code> requesting a "Suite" for
the supported suites, "Messenger" for the
<code class="classname">BHandler</code>, or the <code class="classname">BHandler</code>'s
"InternalName" (the same name that its
<code class="methodname">Name()</code> function returns). In all three cases, it
assigns the <code class="classname">BHandler</code>(<code class="varname">this</code>) as the
object responsible for the message.
</p><p>
For all other specifiers and messages, it sends a
<code class="constant">B_MESSAGE_NOT_UNDERSTOOD</code> reply and returns
<code class="constant">NULL</code>. The reply message has an <code class="varname">error</code> field
with <code class="constant">B_SCRIPT_SYNTAX</code> as the error and a
<code class="varname">message</code> field with a longer textual explanation of the error.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_SetFilterList"></a><a id="BHandler_FilterList"></a>
<a id="BHandler_AddFilter"></a>
<a id="BHandler_RemoveFilter"></a>
SetFilterList(), FilterList(), AddFilter(), RemoveFilter()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">SetFilterList</span>(<span class="methodparam"><span class="type">BList* </span><span class="parameter">list</span></span>);</code><code class="methodsynopsis cpp"><span class="type">BList* </span><span class="methodname">FilterList</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">AddFilter</span>(<span class="methodparam"><span class="type">BMessageFilter* </span><span class="parameter">filter</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">bool </span><span class="methodname">RemoveFilter</span>(<span class="methodparam"><span class="type">BMessageFilter* </span><span class="parameter">filter</span></span>);</code><p>
These functions manage a list of <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>
objects associated with the <code class="classname">BHandler</code>.
</p><p>
<code class="methodname">SetFilterList()</code> assigns the
<code class="classname">BHandler</code> a new <code class="parameter">list</code> of
filters; the list must contain pointers to instances of the <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a> class
or to instances of classes that derive from <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>. The
new list replaces any list of filters previously assigned. All objects in
the previous list are deleted, as is the <a class="link" href="BList.html" title="BList"><code class="classname">BList</code></a> that contains them. If
list is <code class="constant">NULL</code>, the current list is removed without a
replacement. <code class="methodname">FilterList()</code> returns the current list
of filters.
</p><p>
<code class="methodname">AddFilter()</code> adds a <code class="parameter">filter</code>
to the end of the <code class="classname">BHandler</code>'s list of filters. It
creates the <a class="link" href="BList.html" title="BList"><code class="classname">BList</code></a>
object if it doesn't already exist. By default, BHandlers don't maintain a
<a class="link" href="BList.html" title="BList"><code class="classname">BList</code></a> of filters until
one is assigned or the first <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a> is
added. <code class="methodname">RemoveFilter()</code> removes a
<code class="parameter">filter</code> from the list without deleting it. It returns
<code class="constant">true</code> if successful, and <code class="constant">false</code> if
it can't find the specified filter in the list (or the list doesn't exist).
It leaves the <a class="link" href="BList.html" title="BList"><code class="classname">BList</code></a> in
place even after removing the last filter.
</p><p>
For <code class="methodname">SetFilterList()</code>,
<code class="methodname">AddFilter()</code> and
<code class="methodname">RemoveFilter()</code> to work, the
<code class="classname">BHandler</code> must be assigned to a <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> object and the
<a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a> must be
locked.
</p><p>
See also:
<a class="link" href="BLooper.html#BLooper_SetCommonFilterList"><code class="methodname">BLooper::SetCommonFilterList()</code></a>,
<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">BLooper::Lock()</code></a>,
the <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a> class
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_SetName"></a><a id="BHandler_Name"></a>
SetName(), Name()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetName</span>(<span class="methodparam"><span class="modifier">const </span><span class="type">char* </span><span class="parameter">string</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">const </span><span class="type">char* </span><span class="methodname">Name</span>() <span class="modifier">const</span>;</code><p>
These functions set and return the name that identifies the
<code class="classname">BHandler</code>. The name is originally set by the
constructor. <code class="methodname">SetName()</code> assigns the
<code class="classname">BHandler</code> a new name, and
<code class="methodname">Name()</code> returns the current name. The string
returned by <code class="methodname">Name()</code> belongs to the
<code class="classname">BHandler</code> object; it shouldn't be altered or freed.
</p><p>
See also:
The <code class="classname">BHandler</code> <a class="link" href="BHandler.html#BHandler_Constructor" title="BHandler()">constructor</a>,
<a class="link" href="BView.html#BView_FindView" title="FindView()"><code class="methodname">BView::FindView()</code></a> in th
<a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_SetNextHandler"></a><a id="BHandler_NextHandler"></a>
SetNextHandler(), NextHandler()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetNextHandler</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>);</code><code class="methodsynopsis cpp"><span class="type">BHandler* </span><span class="methodname">NextHandler</span>() <span class="modifier">const</span>;</code><p>
<code class="methodname">SetNextHandler()</code> reorders the objects in the
handler chain so that <code class="parameter">handler</code> follows this
<code class="classname">BHandler</code>. This <code class="classname">BHandler</code> and
<code class="parameter">handler</code> must already be part of the same chain,
and the <a class="link" href="BLooper.html" title="BLooper"><code class="classname">BLooper</code></a>
they belong to must be locked. The order of objects in the handler chain
affects the way in-coming messages are handled (as explained in
"<a class="link" href="TheApplicationKit_Messaging.html#TheApplicationKit_Messaging_Inheritance" title="Inheritance and the Handler Chain">Inheritance and the Handler Chain</a>".
By default handlers are placed in the order that they're added (through
<a class="link" href="BLooper.html#BLooper_AddHandler" title="AddHandler(), RemoveHandler(), HandlerAt(), CountHandlers(), IndexOf()"><code class="methodname">BLooper::AddHandler()</code></a>).
</p><p>
<code class="methodname">NextHandler()</code> returns this object's next handler.
If this object is at the end of the chain, it returns
<code class="constant">NULL</code>.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_SendNotices"></a>SendNotices()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">void </span><span class="methodname">SendNotices</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">what</span></span>,<br />                         <span class="methodparam"><span class="modifier">const </span><span class="type"><a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a>* </span><span class="parameter">msg</span><span class="initializer"> = 0</span></span>);</code><p>
Sends a
<a class="link" href="TheApplicationKit_MessageConstants.html#B_OBSERVER_NOTICE_CHANGE" title="B_OBSERVER_NOTICE_CHANGE"><code class="constant">B_OBSERVER_NOTICE_CHANGE</code></a>
message to each <code class="classname">BHandler</code> object (or "observer")
that's observing this handler (the "notifier"). To observe
a notifier, the observer calls
<a class="link" href="BHandler.html#BHandler_StartWatching" title="StartWatching(), StartWatchingAll(), StopWatching(), StopWatchingAll()"><code class="methodname">StartWatching()</code></a>.
The <code class="parameter">what</code> argument describes the type of change
that's prompting this notification; only those observers that have
registered to be notified about what (or that are watching all changes)
are sent notifications.
</p><p>
The
<a class="link" href="TheApplicationKit_MessageConstants.html#B_OBSERVER_NOTICE_CHANGE" title="B_OBSERVER_NOTICE_CHANGE"><code class="constant">B_OBSERVER_NOTICE_CHANGE</code></a>
messages that are
sent are copied from <code class="parameter">msg</code> with the what argument
added as the <code class="varname">be:old_what</code> field. Note that
<code class="parameter">msg</code>'s original <code class="varname">what</code> field is clobbered.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_StartWatching"></a><a id="BHandler_StartWatchingAll"></a>
<a id="BHandler_StopWatching"></a>
<a id="BHandler_StopWatchingAll"></a>
StartWatching(), StartWatchingAll(), StopWatching(), StopWatchingAll()</h4></div></div></div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StartWatching</span>(<span class="methodparam"><span class="type">BMessenger </span><span class="parameter">watcher</span></span>,<br />                       <span class="methodparam"><span class="type">uint32 </span><span class="parameter">what</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StartWatching</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">watcher</span></span>,<br />                       <span class="methodparam"><span class="type">uint32 </span><span class="parameter">what</span></span>);</code>
</div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StartWatchingAll</span>(<span class="methodparam"><span class="type">BMessenger </span><span class="parameter">watcher</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StartWatchingAll</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">watcher</span></span>);</code>
</div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StopWatching</span>(<span class="methodparam"><span class="type">BMessenger </span><span class="parameter">watcher</span></span>,<br />                      <span class="methodparam"><span class="type">uint32 </span><span class="parameter">what</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StopWatching</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">watcher</span></span>,<br />                      <span class="methodparam"><span class="type">uint32 </span><span class="parameter">what</span></span>);</code>
</div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StopWatchingAll</span>(<span class="methodparam"><span class="type">BMessenger </span><span class="parameter">watcher</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">StopWatchingAll</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">watcher</span></span>);</code>
</div><p>
The <code class="classname">BHandler</code> class provides the concept of a
<span class="bold"><strong>notifier</strong></span>. Notifiers maintain one or more
states that other entities might want to monitor changes to. These states
are identified by a 32-bit <code class="parameter">what</code> code. Another entity
a <code class="classname">BHandler</code> or a <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> can watch for
changes notifiers' states. These are called <span class="bold"><strong>observers</strong></span>.
</p><p>
<code class="methodname">StartWatching()</code> registers the <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> or
<code class="classname">BHandler</code> specified by <code class="parameter">watcher</code>
to be notified whenever the state specified by <code class="parameter">what</code>
changes. <code class="methodname">StartWatchingAll()</code> registers the
specified <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> or
<code class="classname">BHandler</code> to be notified when any of the notifer's
states change.
</p><p>
<code class="methodname">StartWatching()</code> works by sending a message to the
<code class="classname">BHandler</code> you want to observe, with a <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> back to the
observer, so both must be attached to a looper at the time
<code class="methodname">StartWatching()</code> is called.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>The forms of <code class="methodname">StartWatching()</code> and
<code class="methodname">StartWatchingAll()</code> that accept a
<code class="classname">BHandler</code> can be used to observe a handler that's not
yet attached to a looper. However, these only work if the observer and
notifier are both in the same looper.</p></div></div></div><p>
<code class="methodname">StopWatching()</code> ceases monitoring of the state
<code class="parameter">what</code>. <code class="methodname">StopWatchingAll()</code>, by
some odd coincidence, stops all monitoring by the
<code class="classname">BHandler</code> or <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> specified by
<code class="parameter">watcher</code>.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
No error.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_HANDLER</code>.</span></p></td><td><p>
The specified <code class="classname">BHandler</code> isn't valid.
</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_StaticFunctions"></a>Static Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Instantiate"></a>Instantiate()</h4></div></div></div><p>
See <a class="link" href="BArchivable.html#BArchivable_Instantiate" title="Instantiate()"><code class="methodname">BArchivable::Instantiate()</code></a>
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ArchivedFields"></a>Archived Fields</h3></div></div></div><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Field</th><th>Type code</th><th>Description</th></tr></thead><tbody><tr><td><code class="varname">_name</code></td><td><code class="constant">B_STRING_TYPE</code></td><td>The object's name (see
<a class="link" href="BHandler.html#BHandler_SetName" title="SetName(), Name()"><code class="methodname">SetName()</code></a>).</td></tr></tbody></table></div><p>
<code class="classname">BHandler</code> records its own name.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_ScriptingSuites"></a>Scripting Suites and Properties</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id682610"></a>Suite: "suite/vnd.Be-handler"</h4></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_InternalName"></a>"InternalName"</h5></div></div></div><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Message</th><th>Specifiers</th><th>Reply Type</th></tr></thead><tbody><tr><td><code class="constant">B_GET_PROPERTY</code></td><td><code class="constant">B_DIRECT_SPECIFIER</code></td><td><code class="constant">B_STRING_TYPE</code></td></tr></tbody></table></div><p>
Returns the handler's name.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Messenger"></a>"Messenger"</h5></div></div></div><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Message</th><th>Specifiers</th><th>Reply Type</th></tr></thead><tbody><tr><td><code class="constant">B_GET_PROPERTY</code></td><td><code class="constant">B_DIRECT_SPECIFIER</code></td><td><code class="constant">B_MESSENGER_TYPE</code></td></tr></tbody></table></div><p>
Returns a <a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> for the handler.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BHandler_Suites"></a>"Suites"</h5></div></div></div><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Message</th><th>Specifiers</th><th>Reply Type</th></tr></thead><tbody><tr><td><code class="constant">B_GET_PROPERTY</code></td><td><code class="constant">B_DIRECT_SPECIFIER</code></td><td>B_STRING_TYPE array</td></tr></tbody></table></div><p>
Returns an array of suites that the target supports, identified by name (e.g.
"suite/vnd.Be-handler").
</p></div></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BCursor.html">BCursor</a>  Up: <a href="TheApplicationKit.html">The Application Kit</a>  Next: <a href="BInvoker.html">BInvoker</a> </div><div id="footerB"><div id="footerBL"><a href="BCursor.html" title="BCursor"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheApplicationKit.html" title="The Application Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BInvoker.html" title="BInvoker"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
