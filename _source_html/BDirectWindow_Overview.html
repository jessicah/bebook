<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - System Overview - The Game Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheGameKit_Overview.html" title="The Game Kit" /><link rel="prev" href="TheGameKit_Overview_Introduction.html" title="Introduction" /><link rel="next" href="BFileGameSound_Overview.html" title="BFileGameSound" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="TheGameKit_Overview_Introduction.html" title="Introduction"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheGameKit_Overview.html" title="The Game Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BFileGameSound_Overview.html" title="BFileGameSound"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - System Overview - The Game Kit</div></div><div id="headerB">Prev: <a href="TheGameKit_Overview_Introduction.html">Introduction</a>  Up: <a href="TheGameKit_Overview.html">The Game Kit</a>  Next: <a href="BFileGameSound_Overview.html">BFileGameSound</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BDirectWindow_Overview"></a>BDirectWindow</h2></div></div></div><a id="id526141" class="indexterm"></a><p>The
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
class gives your code direct access to the graphics
frame buffer on the video card. Unlike
<a class="link" href="BWindowScreen.html" title="BWindowScreen"><code class="classname">BWindowScreen</code></a>,
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a> can
be used in both full-screen and window modes—you can create a
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
that looks just like a normal window, but lets your code
draw into it by directly accessing the frame buffer.</p><p>In addition,
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
lets you switch between full-screen exclusive
mode and windowed modes without breaking down and rebuilding the object.
A simple call to the
<a class="link" href="BDirectWindow.html#BDirectWindow_SetFullScreen"><code class="methodname">SetFullScreen()</code></a>
function does the job.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>if you want your direct window to be full-screen but don't want
exclusive mode, just resize the window to fill the entire screen; since
full-screen exclusive mode (as set by calling
<a class="link" href="BDirectWindow.html#BDirectWindow_SetFullScreen"><code class="methodname">SetFullScreen()</code></a>)
won't let
other windows draw in front of your direct window, you can't have menus
in a full-screen exclusive mode direct window.</p></div></div></div><p>Another difference between
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
and <a class="link" href="BWindowScreen.html" title="BWindowScreen"><code class="classname">BWindowScreen</code></a>
is that
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
lets you access all the
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>
functions; you can literally treat your
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
just like another window. There are two caveats:</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><div class="orderedlist"><ol><li><p>Don't draw into the direct window from its own thread; you should spawn
another thread for drawing into the direct window.</p></li><li><p>And use the
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function to synchronize the interaction between
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
and your drawing thread. Also, if you choose to use
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>
or <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a> API inside a
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>,
be sure you don't block the
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function.</p></li></ol></div></div></div></div><p>Not all video cards support window mode; use the
<a class="link" href="BDirectWindow.html#BDirectWindow_SupportsWindowMode" title="SupportsWindowMode()"><code class="methodname">SupportsWindowMode()</code></a>
function if you need to know whether or not window mode is available.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BDirectWindow_Overview_GettingConnected"></a>Getting Connected (and Staying That Way)</h3></div></div></div><p>The key to the
 <a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
class is the
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function, which your code must implement. This function is called whenever a change
that your drawing code may need to be aware of occurs.</p><p>When your
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function is called, it's passed a pointer to
a <span class="type">direct_buffer_info</span> structure, as follows:</p><pre class="programlisting c">typedef struct {
   <span class="type">direct_buffer_state</span>   <code class="varname">buffer_state</code>;
   <span class="type">direct_driver_state</span>   <code class="varname">driver_state</code>;
   <span class="type">void*</span>                 <code class="varname">bits</code>;
   <span class="type">void*</span>                 <code class="varname">pci_bits</code>;
   <span class="type">int32</span>                 <code class="varname">bytes_per_row</code>;
   <span class="type">uint32</span>                <code class="varname">bits_per_pixel</code>;
   <span class="type">color_space</span>           <code class="varname">pixel_format</code>;
   <span class="type">buffer_layout</span>         <code class="varname">layout</code>;
   <span class="type">buffer_orientation</span>    <code class="varname">orientation</code>;
   <span class="type">uint32</span>                <code class="varname">_reserved</code>[9];
   <span class="type">uint32</span>                <code class="varname">_dd_type_</code>;
   <span class="type">uint32</span>                <code class="varname">_dd_token_</code>;
   <span class="type">uint32</span>                <code class="varname">clip_list_count</code>;
   <span class="type">clipping_rect</span>         <code class="varname">window_bounds</code>;
   <span class="type">clipping_rect</span>         <code class="varname">clip_bounds</code>;
   <span class="type">clipping_rect</span>         <code class="varname">clip_list</code>[1];
} <span class="type">direct_buffer_info</span>;</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">buffer_state</code></span></p></td><td><p>Indicates what change is occurring in the direct buffer
access privileges. It can have one of the following values:</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_DIRECT_START</code></span></dt><dd><p>You will always receive a <code class="constant">B_DIRECT_START</code> notification when your
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
is first connected to the screen</p></dd><dt><span class="term"><code class="constant">B_DIRECT_MODIFY</code></span></dt><dd><p>Any number of <code class="constant">B_DIRECT_MODIFY</code> notifications
follow (it's possible you won't receive any at all). When you return from
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
after handling <code class="constant">B_DIRECT_START</code> or <code class="constant">B_DIRECT_MODIFY</code>,
your application guarantees to the
application server that your code will abide by the frame buffer
configuration specified by the <span class="type">direct_buffer_info</span> structure until another
<code class="constant">B_DIRECT_MODIFY</code> notification is received (or
<code class="constant">B_DIRECT_STOP</code> occurs).</p></dd><dt><span class="term"><code class="constant">B_DIRECT_STOP</code></span></dt><dd><p>You'll receive a <code class="constant">B_DIRECT_STOP</code> notification when the window is closed,
hidden, or if moved, or if a resolution or color depth change occurs.
Once your
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function returns from handling this
notification, you guarantee to the application server that your code
won't touch the frame buffer anymore.</p></dd></dl><p>For any of these notifications, your
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function shouldn't
return until you can guarantee to the application server that your code
will abide by the frame buffer configuration it received.</p><p>You can get further information about what changed by testing against
other flags in the <code class="varname">buffer_state</code> field:</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_BUFFER_MOVED</code></span></dt><dd><p>The content of your window has been moved, either by a call to
<a class="link" href="BWindow.html#BWindow_MoveTo" title="MoveBy(), MoveTo()"><code class="methodname">MoveTo()</code></a> or
<a class="link" href="BWindow.html#BWindow_MoveBy"><code class="methodname">MoveBy()</code></a>
or by the user manually dragging the window.
The contents of the window are always moved relative to the top-left
corner of the window.</p></dd><dt><span class="term"><code class="constant">B_BUFFER_RESET</code></span></dt><dd><p>The entire direct access buffer has been reset. This can
happen if the user changes the depth or resolution of the screen, or if
the window had previously been hidden and has been made visible again.</p></dd><dt><span class="term"><code class="constant">B_BUFFER_RESIZED</code></span></dt><dd><p>The content area of your window has been resized.</p></dd><dt><span class="term"><code class="constant">B_CLIPPING_MODIFIED</code></span></dt><dd><p>The visible region of the content area of your window
changed. This doesn't imply anything about the position of the window or
the size of the content area of the window—it simply means that the
part of the window that's visible has changed shape.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="varname">driver_state</code></span></p></td><td><p>Indicates changes in the state of the graphics
card on which your direct window is displayed. There are two possible
values:</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_MODE_CHANGED</code></span></dt><dd><p>The resolution or depth of the graphics card has changed.</p></dd><dt><span class="term"><code class="constant">B_DRIVER_CHANGED</code></span></dt><dd><p>The window was moved onto another monitor.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="varname">bits</code></span></p></td><td><p>Is a pointer to the frame buffer in your own team's memory
space.</p></td></tr><tr><td><p><span class="term"><code class="varname">pci_bits</code></span></p></td><td><p>Is a pointer to the frame buffer in the PCI memory
space; this value is typically needed to control DMA.</p></td></tr><tr><td><p><span class="term"><code class="varname">bytes_per_row</code></span></p></td><td><p>Is the number of bytes used to represent a single row of
pixels in the frame buffer.</p></td></tr><tr><td><p><span class="term"><code class="varname">bits_per_pixel</code></span></p></td><td><p>Is the number of bits actually used to store a single
pixel, including reserved, unused, or alpha channel bits. This value is
usually a multiple of eight.</p></td></tr><tr><td><p><span class="term"><code class="varname">pixel_format</code></span></p></td><td><p>Is the format used to encode a pixel, as defined in the
<span class="type">color_space</span> type in
<code class="filename">GraphicsDefs.h</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">layout</code>, <code class="varname">orientation</code>,
<code class="varname">_reserved</code> , <code class="varname">_dd_type_</code>,
and <code class="varname">_dd_token_</code></span></p></td><td><p>Are all reserved for future use and must not be used.</p></td></tr><tr><td><p><span class="term"><code class="varname">window_bounds</code></span></p></td><td><p>Is a rectangle that defines the full content area of the
window, in screen coordinates. You can convert these coordinates into
frame buffer addresses using the values in the <code class="varname">bits</code> , <code class="varname">bytes_per_row</code> , and
<code class="varname">bits_per_pixel</code> fields.</p></td></tr><tr><td><p><span class="term"><code class="varname">clip_bounds</code></span></p></td><td><p>Is the bounding rectangle of the visible part of the content
area of the window, in screen coordinates. This rectangle is the smallest
rectangle that contains all the rectangles in the <code class="varname">clip_list</code>, described
below.</p></td></tr><tr><td><p><span class="term"><code class="varname">clip_list_count</code></span></p></td><td><p>Is the number of rectangles in the <code class="varname">clip_list</code>.</p></td></tr><tr><td><p><span class="term"><code class="varname">clip_list</code></span></p></td><td><p>Is a list of rectangles that together define the visible region
of the content area of the window, in screen coordinates</p></td></tr></tbody></table><p>The <span class="type">clipping_rect</span> structure is:</p><pre class="programlisting example c">typedef struct {
   <span class="type">int32</span>      <code class="varname">left</code>;
   <span class="type">int32</span>      <code class="varname">top</code>;
   <span class="type">int32</span>      <code class="varname">right</code>;
   <span class="type">int32</span>      <code class="varname">bottom</code>;
} <span class="type">clipping_rect</span>;</pre><p>Note that, as always, these edges are inclusive; for example, if left is
5 and top is 3, the pixel at (5,3) is included in the rectangle's
contents.</p><p>The data in the <span class="type">direct_buffer_info</span> structure is only valid until
<code class="methodname">DirectConnected()</code> returns, so if you need to reference any of the
information later, you should make a copy of the fields you need.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>If your
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
implementation doesn't handle a request
within three seconds, the Application Server will intentionally crash
your application under the assumption that it's deadlocked. Be sure to
handle requests as quickly as possible.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BDirectWindow_Overview_Window_Vs_Fullscreen"></a>Window Mode vs. Full Screen Mode</h3></div></div></div><p>There are some differences in how
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a> behaves depending on
whether it's in window mode or full-screen exclusive mode.</p><p>In window mode, the
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
behaves almost exactly like a
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>—so
much so that you can use a
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
in any situation you'd normally use a
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>.
The <code class="varname">window_bounds</code> rectangles are
the same size and shape as the window itself, as you'd expect. If
exclusive window mode is available (
<a class="link" href="BDirectWindow.html#BDirectWindow_SupportsWindowMode" title="SupportsWindowMode()"><code class="methodname">SupportsWindowMode()</code></a>
returns <code class="constant">true</code>),
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
will be called as described above, thereby providing
the means to directly access the frame buffer. If the graphics card
doesn't support exclusive access to the frame buffer while in window
mode,
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
will never be called, and you can only use
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> and
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
APIs to work in the window.</p><p>In full-screen exclusive mode, the <code class="varname">window_bounds</code> are actually the size
and shape of the entire screen, even if the screen isn't the same size as
the direct window you created. You have to handle the difference yourself.</p><p>Full-screen exclusive mode also guarantees that your window will always
be the focus, always be in front, and will always stay full-screen (the
application server will resize the window for you if the screen
resolution changes). Since no other windows can come in front of a
full-screen exclusive direct window, any Interface Kit objects that use a
window to display their contents won't work; this includes any type of
menu.</p><p>If you want your
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
to be full-screen, but still compatible
with menus or other windows, create it as a non-exclusive window, then
use the following code:</p><pre class="programlisting example cpp"><code class="classname">BScreen</code> <code class="varname">screen</code>(<code class="varname">this</code>);
<code class="methodname">MoveTo</code>(0,0);
<code class="methodname">ResizeTo</code>(<code class="varname">screen</code>.<code class="varname">width</code>, <code class="varname">screen</code>.<code class="varname">height</code>);</pre><p>This will make the non-exclusive direct window fill the entire screen.
Keep in mind that in this case, other windows may appear in front of
yours, and if the screen resolution changes, you will have to resize the
window yourself if you want to continue to fill the entire screen.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BDirectWindow_Overview_Using_Direct_Window"></a>Using a Direct Window</h3></div></div></div><p>Let's put together a simple class, derived from
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>, that
demonstrates the basics of drawing into a direct window.</p><pre class="programlisting example cpp">class <code class="classname">DirectSample</code> : public <code class="classname">BDirectWindow</code> {
public:
                   <code class="methodname">DirectSample</code>(<code class="classname">BRect</code> <code class="parameter">frame</code>);
                   <code class="methodname">~DirectSample</code>();
    virtual <span class="type">bool</span>   <code class="methodname">QuitRequested</code>();
    virtual <span class="type">void</span>   <code class="methodname">DirectConnected</code>(<span class="type">direct_buffer_info *</span><code class="parameter">info</code>);

    <span class="type">uint8*</span>         <code class="varname">fBits</code>;
    <span class="type">int32</span>          <code class="varname">fRowBytes</code>;
    <span class="type">color_space</span>    <code class="varname">fFormat</code>;
    <span class="type">clipping_rect</span>  <code class="varname">fBounds</code>;

    <span class="type">uint32</span>         <code class="varname">fNumClipRects</code>;
    <span class="type">clipping_rect*</span> <code class="varname">fClipList</code>;

    <span class="type">bool</span>           <code class="varname">fDirty</code>;      <span class="comment">// needs refresh?</span>
    <span class="type">bool</span>           <code class="varname">fConnected</code>;
    <span class="type">bool</span>           <code class="varname">fConnectionDisabled</code>;
    <span class="type">BLocker*</span>       <code class="varname">locker</code>;
    <span class="type">thread_id</span>      <code class="varname">fDrawThreadID</code>;
};</pre><p>The <code class="classname">DirectSample</code> class implements a constructor as well as the
<a class="link" href="BApplication.html#BApplication_QuitRequested" title="QuitRequested()"><code class="methodname">QuitRequested()</code></a> and
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
functions.</p><p>Some variables are added to the class for cacheing information about the
frame buffer.</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">fBits</code></span></p></td><td><p>Will contain a pointer to the frame buffer's bitmap.</p></td></tr><tr><td><p><span class="term"><code class="varname">fRowBytes</code></span></p></td><td><p>Will contain the number of bytes per row of screen data.</p></td></tr><tr><td><p><span class="term"><code class="varname">fFormat</code></span></p></td><td><p>Will contain the pixel format (such as <code class="constant">B_CMAP8</code> for 8-bit
indexed color graphics mode). Our sample program will only work in this
mode.</p></td></tr><tr><td><p><span class="term"><code class="varname">fBounds</code></span></p></td><td><p>will contain the bounds rectangle for the window.</p></td></tr><tr><td><p><span class="term"><code class="varname">fNumClipRects</code></span></p></td><td><p>Will contain the number of rectangles in the clip
rectangle list.</p></td></tr><tr><td><p><span class="term"><code class="varname">fClipList</code></span></p></td><td><p>Is the actual list of clip rectangles, and will be
allocated on-the-fly as needed.</p></td></tr><tr><td><p><span class="term"><code class="varname">fDirty</code></span></p></td><td><p>Will be <code class="constant">true</code> if
the window needs to be redrawn.</p></td></tr><tr><td><p><span class="term"><code class="varname">fConnected</code></span></p></td><td><p>Is <code class="constant">true</code> if the
window is connected to the frame buffer.</p></td></tr><tr><td><p><span class="term"><code class="varname">fConnectionDisabled</code></span></p></td><td><p>Is <code class="constant">true</code> if the window is in the process of being
closed.</p></td></tr><tr><td><p><span class="term"><code class="varname">locker</code></span></p></td><td><p>Is a
<a class="link" href="BLocker.html" title="BLocker"><code class="classname">BLocker</code></a> that will be used to ensure mutual exclusion when
the frame buffer or buffer information data we've cached is being
manipulated.</p></td></tr><tr><td><p><span class="term"><code class="varname">fDrawThreadID</code></span></p></td><td><p>Contains the <span class="type">thread_id</span> of the drawing thread, which is
responsible for drawing the contents of the window.</p></td></tr></tbody></table><p>The specifics of what these variables are and why the information
contained in them is maintained will be discussed when we get to the
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
and <code class="methodname">DrawingThread()</code> functions.</p><p>The constructor for the <code class="classname">DirectSample</code> class looks like this:</p><pre class="programlisting example cpp"><code class="classname">DirectSample</code>::<code class="methodname">DirectSample</code>(<code class="classname">BRect</code> <code class="parameter">frame</code>)
             : <code class="classname">BDirectWindow</code>(<code class="parameter">frame</code>, "DirectWindow Sample",
                             <code class="constant">B_TITLED_WINDOW</code>,
                             <code class="constant">B_NOT_RESIZABLE</code>|<code class="constant">B_NOT_ZOOMABLE</code>)
{
   <code class="varname">fConnected</code> = <code class="constant">false</code>;
   <code class="varname">fConnectionDisabled</code> = <code class="constant">false</code>;
   <code class="varname">locker</code> = new <code class="classname">BLocker</code>();
   <code class="varname">fClipList</code> = <code class="constant">NULL</code>;
   <code class="varname">fNumClipRects</code> = 0;

   <code class="methodname">AddChild</code>(new <code class="classname">SampleView</code>(<code class="methodname">Bounds</code>()));

   if (!<code class="methodname">SupportsWindowMode</code>()) {
      <code class="methodname">SetFullScreen</code>(<code class="constant">true</code>);
   }

   <code class="varname">fDirty</code> = <code class="constant">true</code>;
   <code class="varname">fDrawThreadID</code> = <code class="function">spawn_thread</code>(<code class="function">DrawingThread</code>, "drawing_thread",
                  <code class="constant">B_NORMAL_PRIORITY</code>, (<span class="type">void *</span>) <code class="varname">this</code>);
   <code class="function">resume_thread</code>(<code class="varname">fDrawThreadID</code>);
   <code class="methodname">Show</code>();
}</pre><p>This code establishes the direct window by deferring to
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>.
Then the <code class="varname">fConnected</code> and <code class="varname">fConnectionDisabled</code> flags are initialized to
indicate that the window isn't connected yet, but the connection isn't in
the process of being torn down by the <code class="classname">DirectSample</code> destructor. The locker
is created, and the clip rectangle list is initialized to a <code class="constant">NULL</code> pointer,
with a count of 0.</p><p>Then it adds a child view that occupies the entire window. The primary
purpose of this view in this sample is to set the view color to
<code class="constant">B_TRANSPARENT_32_BIT</code>, to prevent the application server from erasing the
window with a default color.</p><p>If the video card doesn't support window mode, we call
<a class="link" href="BDirectWindow.html#BDirectWindow_SetFullScreen"><code class="methodname">SetFullScreen()</code></a> to
switch the direct window into full-screen exclusive mode. This guarantees
that you'll get connected with direct screen access (in a window if
possible, otherwise in full-screen exclusive mode). If you don't use
<a class="link" href="BDirectWindow.html#BDirectWindow_SetFullScreen"><code class="methodname">SetFullScreen()</code></a>,
and window mode isn't supported,
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
will never be called, and you won't have direct screen access.</p><p>Then the <code class="varname">fDirty</code> flag is set to <code class="constant">true</code>,
which indicates that the window
needs to be updated, and the drawing thread is started; the drawing
thread will handle all actual drawing into the window. The argument
passed to the drawing thread is a pointer to the <code class="classname">DirectSample</code> window
itself. You should always use a separate thread for drawing into a
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>.</p><p>Finally, <a class="link" href="BWindow.html#BWindow_Show" title="Show(), Hide(), IsHidden(), Minimize(), IsMinimized()"><code class="methodname">Show()</code></a>
is called to make the direct window visible.</p><p>The destructor needs to make sure there's no chance someone will try to
draw while the window is being destructed:</p><pre class="programlisting example cpp"><code class="classname">DirectSample</code>::<code class="methodname">~DirectSample</code>() {
   <span class="type">int32</span> <code class="varname">result</code>;

   <code class="varname">fConnectionDisabled</code> = <code class="constant">true</code>;      <span class="comment">// Connection is dying</span>
   <code class="methodname">Hide</code>();
   <code class="methodname">Sync</code>();
   <code class="function">wait_for_thread</code>(<code class="varname">fDrawThreadID</code>, &amp;<code class="varname">result</code>);
   <code class="function">free</code>(<code class="varname">fClipList</code>);
   delete <code class="varname">locker</code>;
}</pre><p>The first thing the destructor does is set the <code class="varname">fConnectionDisabled</code> flag
to <code class="constant">true</code>, which indicates that the window is in the process of being
destroyed, and that future calls to
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a> or the drawing
thread should be ignored. The window is then hidden by calling
<a class="link" href="BWindow.html#BWindow_Hide"><code class="methodname">Hide()</code></a>.
Finally, <a class="link" href="BWindow.html#BWindow_Sync"><code class="methodname">Sync()</code></a>
is called to block until the window is actually hidden.</p><p><a class="link" href="TheKernelKit_ThreadsAndTeams.html#wait_for_thread" title="wait_for_thread()"><code class="function">wait_for_thread()</code></a>
waits until the drawing thread terminates. The drawing
thread (as we'll see shortly) is designed to terminate when the
<code class="varname">fConnectionDisabled</code> flag is <code class="constant">true</code>.</p><p>Then the clip rectangle list is freed and the locker deleted.</p><p>The <a class="link" href="BApplication.html#BApplication_QuitRequested" title="QuitRequested()"><code class="methodname">QuitRequested()</code></a>
function is implemented as usual.</p><p>The <a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function is called whenever a change occurs that
affects how your code should access the frame buffer:</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">DirectSample</code>::<code class="methodname">DirectConnected</code>(<span class="type">direct_buffer_info *</span><code class="parameter">info</code>) {
   if (!<code class="varname">fConnected</code> &amp;&amp; <code class="varname">fConnectionDisabled</code>) {
      return;
   }
   <code class="varname">locker</code>-&gt;<code class="methodname">Lock</code>();

   switch(<code class="varname">info</code>-&gt;<code class="varname">buffer_state</code> &amp; <code class="constant">B_DIRECT_MODE_MASK</code>) {
      case <code class="constant">B_DIRECT_START</code>:
         <code class="varname">fConnected</code> = <code class="constant">true</code>;

      case <code class="constant">B_DIRECT_MODIFY</code>:
         <span class="comment">// Get clipping information</span>

         if (<code class="varname">fClipList</code>) {
            <code class="function">free</code>(<code class="varname">fClipList</code>);
            <code class="varname">fClipList</code> = <code class="constant">NULL</code>;
         }

         <code class="varname">fNumClipRects</code> = <code class="varname">info</code>-&gt;<code class="varname">clip_list_count</code>;
         <code class="varname">fClipList</code> = (<span class="type">clipping_rect *</span>)
               <code class="function">malloc</code>(<code class="varname">fNumClipRects</code>*<code class="function">sizeof</code>(<code class="varname">clipping_rect</code>));

         if (<code class="varname">fClipList</code>) {
            <code class="function">memcpy</code>(<code class="varname">fClipList</code>, <code class="varname">info</code>-&gt;<code class="varname">clip_list</code>,
                  <code class="varname">fNumClipRects</code>*<code class="function">sizeof</code>(<span class="type">clipping_rect</span>));
            <code class="varname">fBits</code> = (<span class="type">uint8 *</span>) <code class="varname">info</code>-&gt;<code class="varname">bits</code>;
            <code class="varname">fRowBytes</code> = <code class="varname">info</code>-&gt;<code class="varname">bytes_per_row</code>;
            <code class="varname">fFormat</code> = <code class="varname">info</code>-&gt;<code class="varname">pixel_format</code>;
            <code class="varname">fBounds</code> = <code class="varname">info</code>-&gt;<code class="varname">window_bounds</code>;
            <code class="varname">fDirty</code> = <code class="constant">true</code>;

         }
         break;

      case <code class="constant">B_DIRECT_STOP</code>:
         <code class="varname">fConnected</code> = false;
         break;
   }
   <code class="varname">locker</code>-&gt;<code class="methodname">Unlock</code>();
}</pre><p><a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
begins by checking the <code class="varname">fConnected</code> and
<code class="varname">fConnectionDisabled</code> flags; the code in
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
is only run if the connection is opened (<code class="varname">fConnected</code> is <code class="constant">true</code>)
or if we want to start it again (<code class="varname">fConnectionDisabled</code> is
<code class="constant">false</code>). This arrangement prevents the
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
function from trying to reconnect if the destructor has
started running. Otherwise, the locker is locked, to prevent
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
and the drawing thread from colliding.</p><p>If the buffer state is <code class="constant">B_DIRECT_START</code>, the
<code class="varname">fConnected</code> flag is set to
<code class="constant">true</code>. This keeps track of the fact that the application server has given
permission to draw directly into the region of the frame buffer
controlled by the direct window.</p><p>If the buffer state is <code class="constant">B_DIRECT_START</code> or <code class="constant">B_DIRECT_MODIFY</code> (in which case
the <span class="type">direct_buffer_info</span> structure describes changes to the frame buffer),
any previously-existing clip rectangle list is deleted, then we cache the
information that interests us and set the <code class="varname">fDirty</code> flag to <code class="constant">true</code> (to
indicate that the display needs to be redrawn to reflect the changed
graphics settings).</p><p>The clip list is also cached by saving the number of rectangles in the
list in the <code class="varname">fNumClipRects</code> field and by making a copy of the clip list
into a newly <code class="function">malloc()</code>d block of memory.</p><p>If the state is <code class="constant">B_DIRECT_STOP</code>, the <code class="varname">fConnected</code>
flag is set to <code class="constant">false</code>, to
indicate that we shouldn't draw into the frame buffer anymore.</p><p>Finally, the locker is unlocked, which lets the drawing thread start
running again.</p><p>Now let's have a look at <code class="methodname">DrawingThread()</code>; this function serves as the
drawing thread, and is a global function:</p><pre class="programlisting example cpp"><span class="type">int32</span> <code class="function">DrawingThread</code>(<span class="type">void*</span> <code class="parameter">data</code>) {
   <span class="type">DirectSample*</span> <code class="varname">w</code>;

   <code class="varname">w</code> = (<span class="type">DirectSample*</span>) <code class="varname">data</code>;
   while (!<code class="varname">w</code>-&gt;<code class="varname">fConnectionDisabled</code>) {
      <code class="varname">w</code>-&gt;<code class="varname">locker</code>-&gt;<code class="methodname">Lock</code>();
      if (<code class="varname">w</code>-&gt;<code class="varname">fConnected</code>) {
         if (<code class="varname">w</code>-&gt;<code class="varname">fFormat</code> == <code class="constant">B_CMAP8</code> &amp;&amp; <code class="varname">w</code>-&gt;<code class="varname">fDirty</code>) {
            <span class="type">int32</span> <code class="varname">y</code>;
            <span class="type">int32</span> <code class="varname">width</code>;
            <span class="type">int32</span> <code class="varname">height</code>;
            <span class="type">int32</span> <code class="varname">adder</code>;
            <span class="type">uint8 *</span><code class="varname">p</code>;
            <span class="type">clipping_rect *</span><code class="varname">clip</code>;
            <span class="type">int32</span> <code class="varname">i</code>;

            <code class="varname">adder</code> = <code class="varname">w</code>-&gt;<code class="varname">fRowBytes</code>;   <span class="comment">// Stash locally for this pass</span>
            for (<code class="varname">i</code>=0; <code class="varname">i</code>&lt;<code class="varname">w</code>-&gt;<code class="varname">fNumClipRects</code>; <code class="varname">i</code>++) {
               <code class="varname">clip</code> = &amp;(<code class="varname">w</code>-&gt;<code class="varname">fClipList</code>[<code class="varname">i</code>]);
               <code class="varname">width</code> = (<code class="varname">clip</code>-&gt;<code class="varname">right</code> - <code class="varname">clip</code>-&gt;<code class="varname">left</code>)+1;
               <code class="varname">height</code> = (<code class="varname">clip</code>-&gt;<code class="varname">bottom</code> - <code class="varname">clip</code>-&gt;<code class="varname">top</code>)+1;
               <code class="varname">p</code> = <code class="varname">w</code>-&gt;<code class="varname">fBits</code>+(<code class="varname">clip</code>-&gt;<code class="varname">top</code>*<code class="varname">w</code>-&gt;<code class="varname">fRowBytes</code>)+<code class="varname">clip</code>-&gt;<code class="varname">left</code>;
               <code class="varname">y</code> = 0;
               while (<code class="varname">y</code> &lt; <code class="varname">height</code>) {
                  <code class="function">memset</code>(<code class="varname">p</code>, 0x00, <code class="varname">width</code>);
                  <code class="varname">y</code>++;
                  <code class="varname">p</code>+=<code class="varname">adder</code>;
               }
            }
         }
         <code class="varname">w</code>-&gt;<code class="varname">fDirty</code> = <code class="constant">false</code>;
      }
      <code class="varname">w</code>-&gt;<code class="varname">locker</code>-&gt;<code class="methodname">Unlock</code>();
      <span class="comment">// Use BWindow or BView APIs here if you want</span>
      <code class="function">snooze</code>(16000);
   }
   return <code class="constant">B_OK</code>;
}</pre><p><code class="methodname">DrawingThread()</code> starts by casting the argument,
<code class="parameter">data</code>, into a pointer to the
<code class="classname">DirectSample</code> window into which it will be drawing.</p><p>The <span class="code">while</span> loop that follows will continue to run as long as the
<code class="varname">fConnectionDisabled</code> flag is <code class="constant">true</code>—in other words, it will keep
looping as long as the connection is enabled.</p><p>The drawing loop itself begins by locking the locker to ensure that
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
doesn't change anything while we're working, then
checking to be sure the connection is opened (<code class="varname">fConnected</code> is <code class="constant">true</code>). If the
connection is open, we verify that format of the window is still 8-bit
color and that the display needs to be updated. If the display needs
updating and the pixel format is still <code class="constant">B_CMAP8</code>, the drawing code begins.</p><p>The <code class="varname">fRowBytes</code> field of the <code class="classname">DirectSample</code> window is cached in a local
variable called <code class="varname">adder</code>. Then each rectangle in the clip list is drawn, one
at a time, using a <span class="code">for</span> loop.</p><p>A pointer to the clip rectangle to be drawn is stored in <code class="varname">clip</code>, and the
width and height of the rectangle are computed. Then <code class="varname">p</code> is set to be a
pointer to the first pixel in the frame buffer that's contained by the
clip rectangle. Since 8-bit color pixels each occupy exactly one byte of
video memory, this pixel's address can be computed by taking the base
<code class="varname">fBits</code> pointer, adding the number of bytes per row times the number of
rows between the top of the screen and the first row in the clip
rectangle, then adding the number of bytes between the left edge of the
screen and the left edge of the clip rectangle, as seen in the line:</p><pre class="programlisting example cpp"><code class="varname">p</code> = <code class="varname">w</code>-&gt;<code class="varname">fBits</code>+(<code class="varname">clip</code>-&gt;<code class="varname">top</code>*<code class="varname">w</code>-&gt;<code class="varname">fRowBytes</code>)+<code class="varname">clip</code>-&gt;<code class="varname">left</code>;</pre><p>Then a <span class="code">while</span> loop is used to iterate over each line in the clip
rectangle, by ranging the variable <code class="varname">y</code> from 0 to the height of the clip
rectangle. <code class="function">memset()</code> is used to clear the row to black, which is
represented by the byte value 0x00. <code class="varname">y</code> is incremented by one for each pass
through the loop, to count the rows being drawn for each iteration, and
the pointer <code class="varname">p</code> is incremented by adder to move down to the beginning of
the next row in the clip rectangle.</p><p>Once each clip rectangle has been drawn, the <span class="code">for</span> loop exits, and the
<code class="varname">fDirty</code> flag is set to <code class="constant">false</code> to indicate that the screen is up-to-date.
Once that's done, the locker is unlocked, which lets
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
do its thing if it's called. To avoid using an unreasonable amount of processing time,
<a class="link" href="TheKernelKit_ThreadsAndTeams.html#snooze" title="snooze(), snooze_until()"><code class="function">snooze()</code></a>
is called to give up CPU time to other threads.</p><p>If you want to use calls to
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> or
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a> API in your drawing thread,
you should do so just after unlocking the window.</p><p>When the thread terminates (which will only happen when the connection is
disabled), the drawing thread returns <code class="constant">B_OK</code>.</p><p>This drawing function is designed to draw nothing unless it's necessary;
<a class="link" href="BDirectWindow.html#BDirectWindow_DirectConnected" title="DirectConnected()"><code class="methodname">DirectConnected()</code></a>
will set the <code class="varname">fDirty</code> flag when something happens to
cause the screen to need a refresh, and other code elsewhere in the
application could also set the <code class="varname">fDirty</code> flag to indicate that the screen
should be redrawn.</p><p>Since we're taking over drawing the contents of the window, we need to
tell the application server not to draw anything. This is done by adding
the following line to the constructor for the SampleView:</p><pre class="programlisting example cpp"><code class="methodname">SetViewColor</code>(<code class="constant">B_TRANSPARENT_32_BIT</code>);</pre><p>This is very important: if you don't remember to do this, you'll have all
kinds of synchronization problems when the application server and your
drawing code try to draw into the window at the same time.</p><p>Note that this sample code doesn't really do anything useful (if all you
want to do is have a black window moving around, don't use
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>—use a regular
<a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a>, throw a
<a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a> into it, and use
<a class="link" href="BView.html#BView_SetViewColor" title="SetViewColor(), ViewColor()"><code class="methodname">SetViewColor()</code></a>
to make the view black; it'll be faster and more efficient
because it will use hardware graphics acceleration if it's available).
However, it serves as a simple example of how to establish a connection
to let your own drawing code directly access the screen. Just replace the
code inside the drawing loop with something more useful (like a nifty
real-time animation).</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="TheGameKit_Overview_Introduction.html">Introduction</a>  Up: <a href="TheGameKit_Overview.html">The Game Kit</a>  Next: <a href="BFileGameSound_Overview.html">BFileGameSound</a> </div><div id="footerB"><div id="footerBL"><a href="TheGameKit_Overview_Introduction.html" title="Introduction"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheGameKit_Overview.html" title="The Game Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BFileGameSound_Overview.html" title="BFileGameSound"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
