<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Special Topics - Device Drivers</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="DeviceDrivers.html" title="Device Drivers" /><link rel="prev" href="DeviceDrivers_DriverSettingsAPI.html" title="Driver Settings API" /><link rel="next" href="DeviceDrivers_Functions.html" title="Kernel Functions" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="DeviceDrivers_DriverSettingsAPI.html" title="Driver Settings API"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="DeviceDrivers.html" title="Device Drivers"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="DeviceDrivers_Functions.html" title="Kernel Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Special Topics - Device Drivers</div></div><div id="headerB">Prev: <a href="DeviceDrivers_DriverSettingsAPI.html">Driver Settings API</a>  Up: <a href="DeviceDrivers.html">Device Drivers</a>  Next: <a href="DeviceDrivers_Functions.html">Kernel Functions</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DeviceDrivers_ConstantsDefinedTypes"></a>Constants And Defined Types</h2></div></div></div><p>Declared in: <code class="filename">drivers/Drivers.h</code></p><p>This section covers constants and types defined for use by kernel drivers
and modules.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DeviceDrivers_Constants"></a>Constants</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_CUR_DRIVER_API_VERSION"></a>Current Driver API Version</h4></div></div></div><pre class="programlisting cpp">#define <code class="constant">B_CUR_DRIVER_API_VERSION</code> <em class="replaceable"><code>N</code></em></pre><p>The <code class="constant">B_CUR_DRIVER_API_VERSION</code> constant
indicates what version of the driver API your driver will be built to.</p><p>See also:
"<a class="link" href="DeviceDrivers_WritingDrivers.html#DeviceDrivers_SymbolsDriversExport" title="Symbols Drivers Export">Symbols Drivers
Export</a>"</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_GET_DEVICE_SIZE"></a><a id="B_SET_DEVICE_SIZE"></a>
<a id="B_SET_NONBLOCKING_IO"></a>
<a id="B_SET_BLOCKING_IO"></a>
<a id="B_GET_READ_STATUS"></a>
<a id="B_GET_WRITE_STATUS"></a>
<a id="B_GET_GEOMETRY"></a>
<a id="B_GET_DRIVER_FOR_DEVICE"></a>
<a id="B_GET_PARTITION_INFO"></a>
<a id="B_SET_PARTITION"></a>
<a id="B_FORMAT_DEVICE"></a>
<a id="B_EJECT_DEVICE"></a>
<a id="B_GET_ICON"></a>
<a id="B_GET_BIOS_GEOMETRY"></a>
<a id="B_GET_MEDIA_STATUS"></a>
<a id="B_LOAD_MEDIA"></a>
<a id="B_GET_BIOS_DRIVE_ID"></a>
<a id="B_SET_UNINTERRUPTABLE_IO"></a>
<a id="B_SET_INTERRUPTABLE_IO"></a>
<a id="B_FLUSH_DRIVE_CACHE"></a>
<a id="B_GET_NEXT_OPEN_DEVICE"></a>
<a id="B_ADD_FIXED_DRIVER"></a>
<a id="B_REMOVE_FIXED_DRIVER"></a>
<a id="B_AUDIO_DRIVER_BASE"></a>
<a id="B_MIDI_DRIVER_BASE"></a>
<a id="B_JOYSTICK_DRIVER_BASE"></a>
<a id="B_GRAPHIC_DRIVER_BASE"></a>
<a id="B_DEVICE_OP_CODES_END"></a>
Driver Control Opcodes</h4></div></div></div><a id="id918505" class="indexterm"></a><a id="id918515" class="indexterm"></a><a id="id918524" class="indexterm"></a><a id="id918534" class="indexterm"></a><a id="id918543" class="indexterm"></a><a id="id918552" class="indexterm"></a><a id="id918562" class="indexterm"></a><a id="id918571" class="indexterm"></a><a id="id918581" class="indexterm"></a><a id="id918590" class="indexterm"></a><a id="id918599" class="indexterm"></a><a id="id918608" class="indexterm"></a><a id="id918617" class="indexterm"></a><a id="id918626" class="indexterm"></a><a id="id918636" class="indexterm"></a><a id="id918646" class="indexterm"></a><a id="id918655" class="indexterm"></a><a id="id918664" class="indexterm"></a><a id="id918674" class="indexterm"></a><a id="id918684" class="indexterm"></a><a id="id918693" class="indexterm"></a><a id="id918703" class="indexterm"></a><a id="id918712" class="indexterm"></a><a id="id918722" class="indexterm"></a><a id="id918732" class="indexterm"></a><a id="id918741" class="indexterm"></a><a id="id918751" class="indexterm"></a><a id="id918760" class="indexterm"></a><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_GET_DEVICE_SIZE</code></span></p></td><td><p>Returns a <span class="type">size_t</span> indicating the device size in bytes.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_DEVICE_SIZE</code></span></p></td><td><p>Sets the device size to the value pointed to by data.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_NONBLOCKING_IO</code></span></p></td><td><p>Sets the device to use nonblocking I/O.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_BLOCKING_IO</code></span></p></td><td><p>Sets the device to use blocking I/O.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_READ_STATUS</code></span></p></td><td><p>Returns <code class="constant">true</code> if the device can read without blocking,
otherwise <code class="constant">false</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_WRITE_STATUS</code></span></p></td><td><p>Returns <code class="constant">true</code> if the device can write without blocking,
otherwise <code class="constant">false</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_GEOMETRY</code></span></p></td><td><p>Fills out the specified
<a class="link" href="DeviceDrivers_ConstantsDefinedTypes.html#device_geometry" title="device_geometry"><span class="type">device_geometry</span></a>
structure to describe the device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_DRIVER_FOR_DEVICE</code></span></p></td><td><p>Returns the path of the driver executable
handling the device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_PARTITION_INFO</code></span></p></td><td><p>Returns a
<a class="link" href="DeviceDrivers_ConstantsDefinedTypes.html#partition_info" title="partition_info"><span class="type">partition_info</span></a>
structure for the device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_PARTITION</code></span></p></td><td><p>Creates a user-defined partition. data points to a
<a class="link" href="DeviceDrivers_ConstantsDefinedTypes.html#partition_info" title="partition_info"><span class="type">partition_info</span></a>
structure.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FORMAT_DEVICE</code></span></p></td><td><p>Formats the device. data should point to a boolean value: If
<code class="constant">true</code>, the device is formatted low-level. If it's
<code class="constant">false</code>, the formatting is &lt;&lt;??&gt;&gt;</p></td></tr><tr><td><p><span class="term"><code class="constant">B_EJECT_DEVICE</code></span></p></td><td><p>Ejects the device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_ICON</code></span></p></td><td><p>Fills out the specified
<a class="link" href="DeviceDrivers_ConstantsDefinedTypes.html#device_icon" title="device_icon"><span class="type">device_icon</span></a>
<span class="type"></span>
structure to describe the
device's icon.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_BIOS_GEOMETRY</code></span></p></td><td><p>Fills out a
<a class="link" href="DeviceDrivers_ConstantsDefinedTypes.html#device_geometry" title="device_geometry"><span class="type">device_geometry</span></a>
structure to describe the device as the BIOS sees it.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_MEDIA_STATUS</code></span></p></td><td><p>Gets the status of the media in the device by placing
a <span class="type">status_t</span> at the location pointed to by data.</p><p><code class="constant">B_GET_MEDIA_STATUS</code> returns one of these values
in data:</p><dl class="variablelist constants"><dt><span class="term"><code class="constant">B_NO_ERROR</code>.</span></dt><dd><p>The media is ready.</p></dd><dt><span class="term"><code class="constant">B_DEV_NO_MEDIA</code>.</span></dt><dd><p>No media in the device</p></dd><dt><span class="term"><code class="constant">B_DEV_NOT_READY</code>.</span></dt><dd><p>The device isn't ready.</p></dd><dt><span class="term"><code class="constant">B_DEV_MEDIA_CHANGED</code>.</span></dt><dd><p>The media changed since the
time that the device was opened, or since the time of the last
<code class="constant">B_GET_MEDIA_STATUS</code> request.</p></dd><dt><span class="term"><code class="constant">B_DEV_MEDIA_CHANGE_REQUEST</code>.</span></dt><dd><p>The user wants to remove the media.</p></dd><dt><span class="term"><code class="constant">B_DEV_DOOR_OPEN</code>.</span></dt><dd><p>The drive "door" is open.</p></dd></dl></td></tr><tr><td><p><span class="term"><code class="constant">B_LOAD_MEDIA</code></span></p></td><td><p>Loads the media.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_BIOS_DRIVE_ID</code></span></p></td><td><p>Returns the BIOS ID for the device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_UNINTERRUPTABLE_IO</code></span></p></td><td><p>Prevents
<span class="keycap">control</span>+<span class="keycap">C</span>
from interrupting I/O.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SET_INTERRUPTABLE_IO</code></span></p></td><td><p>Allows
<span class="keycap">control</span>+<span class="keycap">C</span>
to interrupt I/O.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FLUSH_DRIVE_CACHE</code></span></p></td><td><p>Flushes the drive's cache.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GET_NEXT_OPEN_DEVICE</code></span></p></td><td><p>Iterates through open devices; data points to an
<span class="type">open_device_iterator</span>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ADD_FIXED_DRIVER</code></span></p></td><td><p>For internal use only.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_REMOVE_FIXED_DRIVER</code></span></p></td><td><p>For internal use only.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_AUDIO_DRIVER_BASE</code></span></p></td><td><p>Base for codes in <code class="filename">audio_driver.h</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MIDI_DRIVER_BASE</code></span></p></td><td><p>Base for codes in <code class="filename">midi_driver.h</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_JOYSTICK_DRIVER_BASE</code></span></p></td><td><p>Base for codes in <code class="filename">joystick.h</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_GRAPHIC_DRIVER_BASE</code></span></p></td><td><p>Base for codes in <code class="filename">graphic_driver.h</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DEVICE_OP_CODES_END</code></span></p></td><td><p>End of Be-defined control IDs.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DeviceDrivers_DefinedTypes"></a>Defined Types</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="device_geometry"></a>device_geometry</h4></div></div></div><a id="id919504" class="indexterm"></a><pre class="programlisting c">typedef struct {
    <span class="type">uint32</span> <code class="varname">bytes_per_sector</code>;
    <span class="type">uint32</span> <code class="varname">sectors_per_track</code>;
    <span class="type">uint32</span> <code class="varname">cylinder_count</code>;
    <span class="type">uint32</span> <code class="varname">head_count</code>;
    <span class="type">uchar</span> <code class="varname">device_type</code>;
    <span class="type">bool</span> <code class="varname">removable</code>;
    <span class="type">bool</span> <code class="varname">read_only</code>;
    <span class="type">bool</span> <code class="varname">write_once</code>;
} <span class="type">device_geometry</span></pre><p>The device_geometry structure is returned
by the <code class="constant">B_GET_GEOMETRY</code> driver
control function. Its fields are:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">bytes_per_sector</code></span></p></td><td><p>Indicates how many bytes each sector of the disk contains.</p></td></tr><tr><td><p><span class="term"><code class="varname">sectors_per_track</code></span></p></td><td><p>Indicates how many sectors each disk track contains.</p></td></tr><tr><td><p><span class="term"><code class="varname">cylinder_count</code></span></p></td><td><p>Indicates the number of cylinders
the disk contains.</p></td></tr><tr><td><p><span class="term"><code class="varname">head_count</code></span></p></td><td><p>Indicates how many heads the disk has.</p></td></tr><tr><td><p><span class="term"><code class="varname">device_type</code></span></p></td><td><p>Specifies the type of device; there's
a list of device type definitions below.</p></td></tr><tr><td><p><span class="term"><code class="varname">removable</code></span></p></td><td><p>Is <code class="constant">true</code> if the
device's media can be removed from the drive, and is
<code class="constant">false</code> otherwise.</p></td></tr><tr><td><p><span class="term"><code class="varname">read_only</code></span></p></td><td><p>Is <code class="constant">true</code> if the
media is read-only (such as CD-ROM), or <code class="constant">false</code> if the
media can be both read from and written.</p></td></tr><tr><td><p><span class="term"><code class="varname">write_once</code></span></p></td><td><p>Is <code class="constant">true</code> if the
media can only be written to once (such as CD-recordable), or
<code class="constant">false</code> if there's no limit to the number of times the
media can be written to.</p></td></tr></tbody></table><p>If you need to compute the total size of the device in bytes, you can
obtain this figure using the following simple formula:</p><pre class="programlisting example c"><code class="varname">disk_size</code> = <code class="varname">geometry</code>.<code class="varname">cylinder_count</code> * <code class="varname">geometry</code>.<code class="varname">sectors_per_track</code> *
<code class="varname">geometry</code>.<code class="varname">head_count</code> * <code class="varname">geometry</code>.<code class="varname">bytes_per_sector</code>;</pre><p>The device type returned in <code class="varname">device_type</code> is one of:</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_DISK</code></span></p></td><td><p>Hard disk, floppy disk, etc.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TAPE</code></span></p></td><td><p>Tape drive.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_PRINTER</code></span></p></td><td><p>Printer.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_CPU</code></span></p></td><td><p>CPU device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_WORM</code></span></p></td><td><p>Write-once, read-many device (such as CD-recordable).</p></td></tr><tr><td><p><span class="term"><code class="constant">B_CD</code></span></p></td><td><p>CD-ROM.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_SCANNER</code></span></p></td><td><p>Scanner.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_OPTICAL</code></span></p></td><td><p>Optical device</p></td></tr><tr><td><p><span class="term"><code class="constant">B_JUKEBOX</code></span></p></td><td><p>Jukebox device.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NETWORK</code></span></p></td><td><p>Network device.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="device_hooks"></a>device_hooks</h4></div></div></div><a id="id919984" class="indexterm"></a><pre class="programlisting c">typedef struct {
    <span class="type">device_open_hook</span> <code class="varname">open</code>;
    <span class="type">device_close_hook</span> <code class="varname">close</code>;
    <span class="type">device_free_hook</span> <code class="varname">free</code>;
    <span class="type">device_control_hook</span> <code class="varname">control</code>;
    <span class="type">device_read_hook</span> <code class="varname">read</code>;
    <span class="type">device_write_hook</span> <code class="varname">write</code>;
    <span class="type">device_select_hook</span> <code class="varname">select</code>;
    <span class="type">device_deselect_hook</span> <code class="varname">deselect</code>;
    <span class="type">device_readv_hook</span> <code class="varname">readv</code>;
    <span class="type">device_writev_hook</span> <code class="varname">writev</code>;
} <span class="type">device_hooks</span></pre><p>This structure is used by device drivers to export their function hooks
to the kernel.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="device_icon"></a>device_icon</h4></div></div></div><a id="id920092" class="indexterm"></a><pre class="programlisting c">typedef struct {
    <span class="type">int32</span> <code class="varname">icon_size</code>;
    <span class="type">void*</span><code class="varname">icon_data</code>;
} <span class="type">device_icon</span></pre><p>When you want to obtain an icon for a specific device, call <code class="function">ioctl()</code> on
the open device, specifying the <code class="constant">B_GET_ICON</code> opcode. Pass in data a pointer
to a <span class="type">device_icon</span> structure in which <code class="varname">icon_size</code> indicates the size of icon
you want and <code class="varname">icon_data</code> points to a buffer large enough to receive the
icon's data.</p><p><code class="varname">icon_size</code> can be either <code class="constant">B_MINI_ICON</code>, in which case the buffer pointed to
by <code class="varname">icon_data</code> should be large enough to receive a 16x16 8-bit bitmap
(256-byte), or <code class="constant">B_LARGE_ICON</code>, in which case the buffer should be large
enough to receive a 32x32 8-bit bitmap (1024-byte). The most obvious way
to set up this buffer would be to create a
<a class="link" href="BBitmap.html" title="BBitmap"><code class="classname">BBitmap</code></a> of the appropriate
size and color depth and use its buffer, like this:</p><pre class="programlisting example c"><code class="classname">BBitmap</code> <code class="varname">bits</code>(<code class="classname">BRect</code>(0, 0, <code class="constant">B_MINI_ICON</code>-1, <code class="constant">B_MINI_ICON</code>-1, 0, <code class="constant">B_CMAP8</code>));
<span class="type">device_icon</span> <code class="varname">iconrec</code>;

<code class="varname">iconrec</code>.<code class="varname">icon_size</code> = <code class="constant">B_MINI_ICON</code>;
<code class="varname">iconrec</code>.<code class="varname">icon_data</code> = <code class="varname">bits</code>.<code class="methodname">Bits</code>();
<span class="type">status_t</span> <code class="varname">err</code> = <code class="function">ioctl</code>(<code class="varname">dev_fd</code>, <code class="constant">B_GET_ICON</code>, &amp;<code class="varname">iconrec</code>);

if (<code class="varname">err</code> == <code class="constant">B_OK</code>) {
   <span class="comment">/* enjoy the icon */</span>
   ...
   <code class="varname">view</code>-&gt;<code class="methodname">DrawBitmap</code>(<code class="varname">bits</code>);
} else {
   <span class="comment">/* I don't like icons anyway */</span>
}</pre></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="driver_path"></a>driver_path</h4></div></div></div><a id="id920302" class="indexterm"></a><pre class="programlisting example c">typedef <span class="type">char</span> <span class="type">driver_path</span>[256];</pre><p>Used by the <code class="constant">B_GET_DRIVER_FOR_DEVICE</code> control function to return the
pathname of the specified device.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="open_device_iterator"></a>open_device_iterator</h4></div></div></div><a id="id920343" class="indexterm"></a><pre class="programlisting c">typedef struct {
    <span class="type">uint32</span> <code class="varname">cookie</code>;
    <span class="type">char</span> <code class="varname">device</code>[256];
} <span class="type">open_device_iterator</span></pre><p>Used by the <code class="constant">B_GET_NEXT_OPEN_DEVICE</code> control function. The first time you
call this function, your <span class="type">open_device_iterator</span> should have cookie
initialized to 0. Then just keep calling it over and over; each time
you'll get the name of the next open device. When an error is returned,
you're done.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="partition_info"></a>partition_info</h4></div></div></div><a id="id920399" class="indexterm"></a><pre class="programlisting c">typedef struct {
    <span class="type">off_t</span> <code class="varname">offset</code>;
    <span class="type">off_t</span> <code class="varname">size</code>;
    <span class="type">int32</span> <code class="varname">logical_block_size</code>;
    <span class="type">int32</span> <code class="varname">session</code>;
    <span class="type">int32</span> <code class="varname">partition</code>;
    <span class="type">char</span> <code class="varname">device</code>[256];
} <span class="type">partition_info</span></pre><p>The <span class="type">partition_info</span> structure describes a disk partition, and
is used by the <code class="constant">B_GET_PARTITION_INFO</code> and
<code class="constant">B_SET_PARTITION</code> control commands.</p><p>The fields are:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">offset</code></span></p></td><td><p>Is the offset, in bytes, from the beginning
of the disk to the beginning of the partition.</p></td></tr><tr><td><p><span class="term"><code class="varname">size</code></span></p></td><td><p>Is the size, in bytes, of the partition.</p></td></tr><tr><td><p><span class="term"><code class="varname">logical_block_size</code></span></p></td><td><p>Is the block size with which
the file system was written to the partition.</p></td></tr><tr><td><p><span class="term"><code class="varname">session</code> and <code class="varname">partition</code></span></p></td><td><p>Are the session and partition ID numbers for the partition.</p></td></tr><tr><td><p><span class="term"><code class="varname">device</code></span></p></td><td><p>Is the pathname of the physical device on
which the partition is located.</p></td></tr></tbody></table></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="DeviceDrivers_DriverSettingsAPI.html">Driver Settings API</a>  Up: <a href="DeviceDrivers.html">Device Drivers</a>  Next: <a href="DeviceDrivers_Functions.html">Kernel Functions</a> </div><div id="footerB"><div id="footerBL"><a href="DeviceDrivers_DriverSettingsAPI.html" title="Driver Settings API"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="DeviceDrivers.html" title="Device Drivers"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="DeviceDrivers_Functions.html" title="Kernel Functions"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
