<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Storage Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheStorageKit.html" title="The Storage Kit" /><link rel="prev" href="The_Node_Monitor.html" title="The Node Monitor" /><link rel="next" href="TheStorageKit_Constants.html" title="Constants" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="The_Node_Monitor.html" title="The Node Monitor"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheStorageKit.html" title="The Storage Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheStorageKit_Constants.html" title="Constants"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Storage Kit</div></div><div id="headerB">Prev: <a href="The_Node_Monitor.html">The Node Monitor</a>  Up: <a href="TheStorageKit.html">The Storage Kit</a>  Next: <a href="TheStorageKit_Constants.html">Constants</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheStorageKit_Functions"></a>Functions</h2></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheStorageKit_Attribute_Functions"></a>Attribute Functions</h3></div></div></div><p>Declared In: <code class="filename">kernel/fs_attr.h</code></p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_close_attr_dir"></a>fs_close_attr_dir()</h4></div></div></div><a id="id1260876" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_close_attr_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>
Closes the specified attribute directory. You should pass into this
function the pointer returned when you called
<a class="link" href="TheStorageKit_Functions.html#fs_open_attr_dir" title="fs_open_attr_dir(), fs_fopen_attr_dir()"><code class="function">fs_open_attr_dir()</code></a> or
<a class="link" href="TheStorageKit_Functions.html#fs_fopen_attr_dir"><code class="function">fs_fopen_attr_dir()</code></a>.
</p><p>
If successful, this function returns 0; otherwise it returns -1 and sets
<code class="varname">errno</code> to a descriptive code.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_open_attr_dir"></a><a id="fs_fopen_attr_dir"></a>
fs_open_attr_dir(), fs_fopen_attr_dir()</h4></div></div></div><a id="id1260972" class="indexterm"></a><a id="id1260980" class="indexterm"></a><div class="synopsisgroup">
<code class="methodsynopsis c"><span class="type">DIR* </span><span class="methodname">fs_open_attr_dir</span>(<span class="methodparam"><span class="type">const char* </span><span class="parameter">path</span></span>);</code>

<code class="methodsynopsis c"><span class="type">DIR* </span><span class="methodname">fs_open_attr_dir</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">fd</span></span>);</code>
</div><p>
Opens the attribute directory for the file specified by <code class="parameter">path</code> or file
descriptor <code class="parameter">fd</code>.
</p><p>
The attribute directory for a file contains a list of the attributes that
are attached to the file. Once the attribute directory is open, you can
use the <code class="function">fs_read_attr_dir()</code> function to find out which attributes are
present.
</p><p>
If the directory is opened successfully, a pointer to the directory
structure is returned. This pointer should be passed to the other <code class="function">fs_attr</code>
functions to read entries from the attribute directory, as well as to
close the directory when you're finished with it.
</p><p>
If an error occurs while opening the attribute directory, this function
returns <code class="constant">NULL</code> and sets <code class="varname">errno</code> to one of the values listed below.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid file descriptor, or a file error prevented the
operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>No matching attribute was found for the specified
file.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NAME_TOO_LONG</code>.</span></p></td><td><p><code class="parameter">path</code> is longer than
<code class="constant">B_PATH_NAME_LENGTH</code> characters.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_LINK_LIMIT</code>.</span></p></td><td><p>A loop was detected in the directory structure.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BUSY</code>.</span></p></td><td><p>The specified file is currently in use.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MORE_FDS</code>.</span></p></td><td><p>Too many open files; all file descriptors are in use.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_read_attr"></a>fs_read_attr()</h4></div></div></div><a id="id1261229" class="indexterm"></a><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">fs_read_attr</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">fd</span></span>,<br />                     <span class="methodparam"><span class="type">const char* </span><span class="parameter">attribute</span></span>,<br />                     <span class="methodparam"><span class="type">uint32 </span><span class="parameter">type</span></span>,<br />                     <span class="methodparam"><span class="type">off_t </span><span class="parameter">pos</span></span>,<br />                     <span class="methodparam"><span class="type">void* </span><span class="parameter">buffer</span></span>,<br />                     <span class="methodparam"><span class="type">size_t </span><span class="parameter">count</span></span>);</code><p>
Reads the attribute of the type and name specified by <code class="parameter">type</code> and <code class="parameter">attribute</code>
from the file descriptor <code class="parameter">fd</code>. The attribute's data is read starting at the
offset <code class="parameter">pos</code> and stored in the <code class="parameter">buffer</code>. <code class="parameter">count</code> specifies the maximum number
of bytes to be read.
</p><p>
The <code class="parameter">type</code> can be any of the standard BeOS type definitions, such as
<code class="constant">B_STRING_TYPE</code>. See the header file
<code class="filename">support/TypeConstants.h</code> for a
complete list of these types. Note that the type of the attribute is a
hint only; there's no reason you can't read a <code class="constant">B_STRING_TYPE</code> attribute as
an integer (except that the data would probably not make any sense if you
did).
</p><p>
If the attribute is read successfully, <code class="function">fs_read_attr()</code> returns the actual
number of bytes of data read from the attribute into the buffer. If an
error occurs, this function returns -1 sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid file descriptor <code class="parameter">fd</code> specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>No matching attribute was found for the specified
file descriptor.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_read_attr_dir"></a>fs_read_attr_dir()</h4></div></div></div><a id="id1261427" class="indexterm"></a><code class="methodsynopsis c"><span class="type">struct dirent* </span><span class="methodname">fs_read_attr_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>
Reads the current attribute from the specified attribute directory, and
bumps the dirp so it points to the next attribute. The dirp pointer that
you pass to this function should have been retrieved through a previous
call to
<a class="link" href="TheStorageKit_Functions.html#fs_open_attr_dir" title="fs_open_attr_dir(), fs_fopen_attr_dir()"><code class="function">fs_open_attr_dir()</code></a> or
<a class="link" href="TheStorageKit_Functions.html#fs_fopen_attr_dir"><code class="function">fs_fopen_attr_dir()</code></a>.
</p><p>
A pointer to a <span class="type">dirent</span> structure is returned. This structure contains
information about the attribute. Do not dispose of or alter the data
contained by this pointer; it belongs to the operating system.
</p><p>
Once a file's attribute directory has been opened, you can loop over this
function to iteratively retrieve the names of all the attributes in the
file. An attribute's name is recorded in the <code class="varname">d_name</code> field of the <span class="type">dirent</span>
structure; see the example in  "<a class="xref" href="AttributeFunctions_Overview.html#AttributeFunctions_An_Example" title="An Example">An Example</a>".
</p><p>
This function doesn't let you get the type or value of an attribute. For
that, use
<a class="link" href="TheStorageKit_Functions.html#fs_stat_attr" title="fs_stat_attr()"><code class="function">fs_stat_attr()</code></a>.
</p><p>
If you're looking for files that have a particular value for one or more
attributes, however, you should try using the <code class="function">fs_query</code> functions, which
allow you to more easily establish complex search operations on the
values of one or more attributes.
</p><p>
If an error occurs (including reaching the end of the directory), this
function returns <code class="constant">NULL</code>.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_A_DIRECTORY</code>.</span></p></td><td><p>The attribute directory is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>You've reached the end of the attribute directory.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_remove_attr"></a>fs_remove_attr()</h4></div></div></div><a id="id1261612" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_remove_attr</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">fd</span></span>,<br />                   <span class="methodparam"><span class="type">const char* </span><span class="parameter">attribute</span></span>);</code><p>
Deletes the named attribute from the file given by the file descriptor <code class="parameter">fd</code>.
</p><p>
If the function is successful, <code class="function">fs_remove_attr()</code> returns 0. Otherwise, it
returns -1 and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p><code class="parameter">fd</code> is invalid, or file opened with read-only access.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Invalid attribute name specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_ALLOWED</code>.</span></p></td><td><p>Disk containing the file is read-only.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>No matching attribute was found.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_rewind_attr_dir"></a>fs_rewind_attr_dir()</h4></div></div></div><a id="id1261761" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_rewind_attr_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>
Rewinds the attribute directory to the beginning. This lets you start
over again at the top of a file's attribute directory and read your way
down toward the bottom.
</p><p>
Returns a result code specifying whether or not the operation was
successful.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Unlike most of the other file system C functions, <code class="function">fs_rewind_attr_dir()</code>
doesn't set <code class="varname">errno</code>.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>Success.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_stat_attr"></a>fs_stat_attr()</h4></div></div></div><a id="id1261868" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_stat_attr</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">fd</span></span>,<br />                 <span class="methodparam"><span class="type">const char* </span><span class="parameter">name</span></span>,<br />                 <span class="methodparam"><span class="type">struct attr_info* </span><span class="parameter">info</span></span>);</code><p>
Returns, in the <span class="type">attr_info</span> structure pointed to by <code class="parameter">info</code>, the type and size
of the specified attribute on the file whose descriptor is specified by
<code class="parameter">fd</code>.
</p><p>
The <span class="type">attr_info</span> structure is defined as follows:
</p><pre class="programlisting definition c">typedef struct <span class="type">attr_info</span>
{
   <span class="type">uint32</span> <code class="varname">type</code>;
   <span class="type">off_t</span>  <code class="varname">size</code>;
}</pre><p>
<code class="varname">type</code> contains a code defining the format of the data contained by the
attribute; standard values for this field are defined in the
<code class="filename">support/TypeConstants.h</code> header file.
</p><p>
<code class="varname">size</code> specifies the size of the data the attribute contains.
</p><p>
Upon success, the function returns 0. Otherwise, it returns -1 and sets
<code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>The requested attribute was not found for the file.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid file descriptor specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_write_attr"></a>fs_write_attr()</h4></div></div></div><a id="id1262052" class="indexterm"></a><code class="methodsynopsis c"><span class="type">ssize_t </span><span class="methodname">fs_write_attr</span>(<span class="methodparam"><span class="type">int </span><span class="parameter">fd</span></span>,<br />                      <span class="methodparam"><span class="type">const char* </span><span class="parameter">attribute</span></span>,<br />                      <span class="methodparam"><span class="type">uint32 </span><span class="parameter">type</span></span>,<br />                      <span class="methodparam"><span class="type">off_t </span><span class="parameter">pos</span></span>,<br />                      <span class="methodparam"><span class="type">const void* </span><span class="parameter">buffer</span></span>,<br />                      <span class="methodparam"><span class="type">size_t </span><span class="parameter">count</span></span>);</code><p>
Sets the value of the named attribute to the data in the specified
buffer. The data's type is specified by type and should be one of the
codes defined in <code class="filename">support/TypeConstants.h</code>. The length of the data to be
written is specified by count.
</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>At this time, writing at an offset within an attribute is not fully
supported, so you should always specify a <code class="parameter">pos</code> of 0 to write at the
beginning of the attribute.</p></div></div></div><p>
If the attribute already has a value, this function wholly replaces that
value with the new data—even if the new data is smaller than the
existing data.
</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Under the Be File System, files have a special attribute storage area
which contains the smaller attributes. When this space is filled up, or
an attribute too large to fit into the space is added to the file,
additional disk blocks are allocated for the new attributes. However,
only one attribute is written per block in these additional blocks. The
moral of the story is: use attributes wisely. They can be your friends,
but if you overuse them, you'll bloat your files.</p></div></div></div><p>
Upon success, the function returns the number of bytes that were actually
written. Otherwise, it returns -1 and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>The attribute name is too long or is an empty string.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid file descriptor <code class="parameter">fd</code> specified, or the the file
is read-only.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Index_Functions"></a>Index Functions</h3></div></div></div><p>
Declared In: <code class="filename">kernel/fs_index.h</code>
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_close_index_dir"></a>fs_close_index_dir()</h4></div></div></div><a id="id1262278" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_close_index_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>
Closes the specified index directory and frees dirp. You should pass into
this function the pointer returned from a previous
<a class="link" href="TheStorageKit_Functions.html#fs_open_index_dir" title="fs_open_index_dir()"><code class="function">fs_open_index_dir()</code></a>.
</p><p>
You should always use this function to close index directories after you
finish using them.
</p><p>
If successful, this function returns 0; otherwise it returns -1 and sets
<code class="varname">errno</code> to one of the following codes.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_FILE</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_create_index"></a>fs_create_index()</h4></div></div></div><a id="id1262386" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_create_index</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">device</span></span>,<br />                    <span class="methodparam"><span class="type">const char* </span><span class="parameter">name</span></span>,<br />                    <span class="methodparam"><span class="type">int </span><span class="parameter">type</span></span>,<br />                    <span class="methodparam"><span class="type">uint </span><span class="parameter">flags</span></span>);</code><p>
Creates a new index called <code class="parameter">name</code> on the specified <code class="parameter">device</code>. Once this has
been done, adding an attribute named <code class="parameter">name</code> to a file causes the file to be
added to the name index, such that subsequent queries will be able to
search for files that contain the name attribute.
</p><p>
<code class="parameter">type</code> indicates the kind of data the attribute will contain. Standard
types are defined in the
<code class="filename">support/TypeConstants.h</code> header file.
Different file systems may support different types. BFS supports the
following types of attributes:
</p><ul class="itemizedlist"><li><p>
<code class="constant">B_INT32_TYPE</code>
</p></li><li><p>
<code class="constant">B_INT64_TYPE</code>
</p></li><li><p>
<code class="constant">B_FLOAT_TYPE</code>
</p></li><li><p>
<code class="constant">B_DOUBLE_TYPE</code>
</p></li><li><p>
<code class="constant">B_STRING_TYPE</code>
</p></li><li><p>
<code class="constant">B_MIME_STRING_TYPE</code>
</p></li></ul><p>
<code class="parameter">flags</code> is currently unused and should always be 0.
</p><p>
If successful, this function returns 0; otherwise it returns -1 and sets
<code class="varname">errno</code> to one of the following codes.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>The device does not exist, or <code class="parameter">name</code> is reserved.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_ALLOWED</code>.</span></p></td><td><p>The device is read-only.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_EXISTS</code>.</span></p></td><td><p>The index <code class="parameter">name</code> already exists.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DEVICE_FULL</code>.</span></p></td><td><p>There's not enough room on the device to create the
index.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ERROR</code>.</span></p></td><td><p>The index type passed isn't supported.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_open_index_dir"></a>fs_open_index_dir()</h4></div></div></div><a id="id1262698" class="indexterm"></a><code class="methodsynopsis c"><span class="type">DIR* </span><span class="methodname">fs_open_index_dir</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">device</span></span>);</code><p>
Opens the index directory for the volume identified by device. Once open,
you can retrieve the names of the indices on the volume by calling
<a class="link" href="TheStorageKit_Functions.html#fs_read_index_dir" title="fs_read_index_dir()"><code class="function">fs_read_index_dir()</code></a>.
</p><p>
When you have finished using the index directory, call
<a class="link" href="TheStorageKit_Functions.html#fs_close_index_dir" title="fs_close_index_dir()"><code class="function">fs_close_index_dir()</code></a> to close it.
</p><p>
If the index directory is opened successfully, a pointer to a directory
structure is returned. This pointer should be passed to the other
<code class="function">fs_index</code> functions to read entries from the index directory, as well as
to close the directory when you're finished with it.
</p><p>
If an error occurs while opening the index directory, this function
returns <code class="constant">NULL</code> and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>A file error prevented the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Invalid <code class="parameter">device</code> number specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_LINK_LIMIT</code>.</span></p></td><td><p>A cyclic loop was detected in the directory structure.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BUSY</code>.</span></p></td><td><p>The specified file is currently in use.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MORE_FDS</code>.</span></p></td><td><p>Too many open files; all file descriptors are in use.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_read_index_dir"></a>fs_read_index_dir()</h4></div></div></div><a id="id1262904" class="indexterm"></a><code class="methodsynopsis c"><span class="type">struct dirent* </span><span class="methodname">fs_read_index_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>
Reads the current entry from the open index directory referenced by <code class="parameter">dirp</code>,
and bumps the pointer to point to the next entry. <code class="parameter">dirp</code> should have been
obtained through a previous call to
<a class="link" href="TheStorageKit_Functions.html#fs_open_index_dir" title="fs_open_index_dir()"><code class="function">fs_open_index_dir()</code></a>. The returned
<span class="type">dirent</span> pointer contains information about the index entry, including the
name of the attribute represented by the index. This pointer belongs to
the system; you must not delete it.
</p><p>
Through repeated calls to <code class="function">fs_read_index_dir()</code>, you can obtain a list of
all the indices available on the device. When you reach the end of the
list, <code class="varname">errno</code> is set to <code class="constant">B_ENTRY_NOT_FOUND</code>.
</p><p>
If an error occurs, this function returns <code class="constant">NULL</code> and sets <code class="varname">errno</code> to an
appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid file descriptor <code class="parameter">fd</code> specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_A_DIRECTORY</code>.</span></p></td><td><p><code class="parameter">dirp</code> does not represent a valid index directory.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>You've reached the end of the list.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_remove_index"></a>fs_remove_index()</h4></div></div></div><a id="id1263066" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_remove_index</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">device</span></span>,<br />                    <span class="methodparam"><span class="type">const char* </span><span class="parameter">index_name</span></span>);</code><p>
Deletes the index named <code class="parameter">index_name</code> from the specified <code class="parameter">device</code>. Once the
index is deleted, it will no longer be possible to use the query system
to search for files with the corresponding attribute.
</p><p>
Use this function to remove an index that you no longer wish or need to
be able to search upon. For example, if your application is being
uninstalled by your user-friendly uninstaller program, and it's no longer
meaningful to be able to search on a given attribute, you should use this
function to delete the index for that attribute.
</p><p>
You should be careful when deciding whether or not to delete an index,
however. If the user still has files around that they want to be able to
search, using the <span class="application">Tracker</span>'s Find panel, for instance, and you've deleted
the index for that attribute, they'll be most displeased. There's a grey
area you need to wade through in determining whether or not to delete
your indices; your decision needs to be based on the specifics of what
your application does and how it will be used.
</p><p>
If the index is removed successfully, <code class="function">fs_remove_index()</code> returns 0.
Otherwise, it returns -1 and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>A file system error prevented the operation.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Invalid <code class="parameter">device</code> number specified.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_ALLOWED</code>.</span></p></td><td><p>Can't remove a system-reserved index ("name," "size,"
"last_modified"), or the device is read-only.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>The specified index does not exist.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_rewind_index_dir"></a>fs_rewind_index_dir()</h4></div></div></div><a id="id1263264" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_rewind_index_dir</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dirp</span></span>);</code><p>Rewinds the specified index directory to the beginning of its list of
indices. This allows you to start over again at the top of a device's
index directory and make your way down toward the bottom.</p><p>Returns a result code specifying whether or not the operation was
successful.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Unlike the most of the other file system functions,
<code class="function">fs_rewind_index_dir()</code> doesn't set <code class="varname">errno</code>.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>Success.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>Invalid directory reference specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_stat_index"></a>fs_stat_index()</h4></div></div></div><a id="id1263372" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_stat_index</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">device</span></span>,<br />                  <span class="methodparam"><span class="type">const char* </span><span class="parameter">index_name</span></span>,<br />                  <span class="methodparam"><span class="type">struct index_info* </span><span class="parameter">info</span></span>);</code><p>Returns, in the <span class="type">index_info</span> structure pointed to by
<code class="parameter">info</code>, information about the index named
<code class="parameter">index_name</code> on the specified device.</p><p>The <span class="type">index_info</span> structure is defined as follows:</p><pre class="programlisting definition c">typedef struct <span class="type">index_info</span>
{
   <span class="type">uint32</span>  <code class="varname">type</code>;
   <span class="type">off_t</span>   <code class="varname">size</code>;
   <span class="type">time_t</span>  <code class="varname">modification_time</code>;
   <span class="type">time_t</span>  <code class="varname">creation_time</code>;
   <span class="type">uid_t</span>   <code class="varname">uid</code>;
   <span class="type">gid_t</span>   <code class="varname">gid</code>;
}</pre><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="varname">type</code></span></p></td><td><p>Contains a code defining the format of the data contained by the
attribute represented by the index; standard values for this field are
defined in the <code class="filename">support/TypeConstants.h</code> header file.</p></td></tr><tr><td><p><span class="term"><code class="varname">size</code></span></p></td><td><p>Specifies the size of the data the attribute contains.</p></td></tr><tr><td><p><span class="term"><code class="varname">modification_time</code></span></p></td><td><p>Contains the time the index was last changed, in
seconds since January 1, 1970.</p></td></tr><tr><td><p><span class="term"><code class="varname">creation_time</code></span></p></td><td><p>Contains the date and time the index was originally
created, in seconds since January 1, 1970.</p></td></tr><tr><td><p><span class="term"><code class="varname">uid</code></span></p></td><td><p>Contains the user ID of the owner of the index.</p></td></tr><tr><td><p><span class="term"><code class="varname">gid</code></span></p></td><td><p>Contains the group ID of the owner of the index.</p></td></tr></tbody></table><p>
If the function is successful, it returns 0; otherwise, it returns -1 and
sets <code class="varname">errno</code> to an appropriate value
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>The requested index was not found.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>Invalid device number specified.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheStorageKit_Query_Functions"></a>Query Functions</h3></div></div></div><p>
Declared In: <code class="filename">kernel/fs_query.h</code>
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_close_query"></a>fs_close_query()</h4></div></div></div><a id="id1263697" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_close_query</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">dir</span></span>);</code><p>
Closes a query which was previously opened using the
<a class="link" href="TheStorageKit_Functions.html#fs_open_query" title="fs_open_query()"><code class="function">fs_open_query()</code></a>
function. You pass in the <span class="type">DIR*</span> returned by either of these functions.
The pointer <code class="parameter">dir</code> is freed by this function.
</p><p>
If the query closes successfully, <code class="function">fs_close_query()</code> returns 0; otherwise,
it returns -1 and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p> A file system error prevented the operation from
succeeding.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_open_query"></a>fs_open_query()</h4></div></div></div><a id="id1263793" class="indexterm"></a><code class="methodsynopsis c"><span class="type">DIR* </span><span class="methodname">fs_open_query</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">device</span></span>,<br />                   <span class="methodparam"><span class="type">const char* </span><span class="parameter">query</span></span>,<br />                   <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span></span>);</code><p>
Opens a new query on the specified device. The <code class="parameter">query</code> string is the
criteria or "predicate" that describes the files that you're looking for.
For information on how to construct the query string, see the
<a class="link" href="BQuery.html" title="BQuery"><code class="classname">BQuery</code></a>
class. Note that you can't use the "push" method:
<code class="function">fs_open_query()</code> only
understands predicate strings.
</p><p>
<code class="parameter">flags</code> is currently unused; pass 0 as its value.
</p><p>
The pointer returned by this function is used to identify your query to
the other query functions; you should not dispose of it
yourself—this will be done for you when you call
<a class="link" href="TheStorageKit_Functions.html#fs_close_query" title="fs_close_query()"><code class="function">fs_close_query()</code></a>.
If the query couldn't be opened, the function returns <code class="constant">NULL</code>
and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p><code class="parameter">device</code> does not specify a valid device,
<code class="parameter">query</code> is <code class="constant">NULL</code> or
an invalid expression, or a live query was requested without specifying
a valid port.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>A file system error prevented the operation from
succeeding.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BUSY</code>.</span></p></td><td><p>A busy node could not be accessed.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MORE_FDS</code>.</span></p></td><td><p>All file descriptors are in use (too many open files).</p></td></tr><tr><td><p><span class="term"><code class="constant">E2BIG</code>.</span></p></td><td><p>query expression is too big.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_read_query"></a>fs_read_query()</h4></div></div></div><a id="id1264026" class="indexterm"></a><code class="methodsynopsis c"><span class="type">struct dirent* </span><span class="methodname">fs_read_query</span>(<span class="methodparam"><span class="type">DIR* </span><span class="parameter">d</span></span>);</code><p>
Returns the next item that matches the specified query. The <code class="parameter">d</code> argument
should have been gotten from a previous call to
<a class="link" href="TheStorageKit_Functions.html#fs_open_query" title="fs_open_query()"><code class="function">fs_open_query()</code></a>; it
identifies the particular query from which to read.
</p><p>
You mustn't free the pointer returned to you by this function.
</p><p>
If an error occurs while reading the query, this function returns <code class="constant">NULL</code>
and sets <code class="varname">errno</code> to an appropriate value.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>A file system error prevented the operation from
succeeding.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>An error occurred processing the query predicate.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p>No more matches.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NOT_A_DIRECTORY</code>.</span></p></td><td><p>A non-directory node was found where a directory
was expected.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_INTERRUPTED</code>.</span></p></td><td><p>A signal interrupted the read.</p></td></tr><tr><td><p><span class="term"><code class="constant">E2BIG</code>.</span></p></td><td><p>Query predicate is too big.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheStorageKit_FileSystem_Info_Functions"></a>FileSystem Information Functions</h3></div></div></div><p>
Declared In: <code class="filename">kernel/fs_info.h</code>
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="dev_for_path"></a>dev_for_path()</h4></div></div></div><a id="id1264235" class="indexterm"></a><code class="methodsynopsis c"><span class="type">dev_t </span><span class="methodname">dev_for_path</span>(<span class="methodparam"><span class="type">const char* </span><span class="parameter">path</span></span>);</code><p>
Given a pathname, returns the device number of the device on which the
path is located. If the result is negative, it is a return code
specifying an error.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_ENTRY_NOT_FOUND</code>.</span></p></td><td><p><code class="parameter">path</code> does not exist, or
is <code class="constant">NULL</code> or an empty string.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p><code class="parameter">path</code> is <code class="constant">NULL</code> or an empty string.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NAME_TOO_LONG</code>.</span></p></td><td><p><code class="parameter">path</code> is too long.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>Insufficient memory to complete the operation.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_FILE_ERROR</code>.</span></p></td><td><p>A file system error prevented the operation from
succeeding.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="next_dev"></a>next_dev()</h4></div></div></div><a id="id1264389" class="indexterm"></a><code class="methodsynopsis c"><span class="type">dev_t </span><span class="methodname">next_dev</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">pos</span></span>);</code><p>
The <code class="function">next_dev()</code> function allows you to iterate through all devices,
receiving their device numbers as a result each time. If the result is
negative, it is an error code. When the end of the device list is
reached, the return value <code class="constant">B_BAD_VALUE</code> is returned.
</p><p>
You should initially set <code class="parameter">pos</code> to 0, then call <code class="function">next_dev()</code> in a loop to
obtain each device number until an error occurs. For example:
</p><pre class="programlisting example c"><span class="type">void</span> <code class="function">ScanDevices</code>(<span class="type">void</span>) {
   <span class="type">int</span> <code class="varname">pos</code>;

   <code class="varname">pos</code> = 0;
   while(<code class="function">next_dev</code>(&amp;<code class="varname">pos</code>) &gt;=0) {
      <code class="function">do_something</code>(<code class="varname">pos</code>);
   }
}</pre><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>No matching device found.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="fs_stat_dev"></a>fs_stat_dev()</h4></div></div></div><a id="id1264522" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">fs_stat_dev</span>(<span class="methodparam"><span class="type">dev_t </span><span class="parameter">dev</span></span>,<br />                <span class="methodparam"><span class="type">fs_info* </span><span class="parameter">info</span></span>);</code><p>
<code class="function">fs_stat_dev()</code> returns information about the specified device. This can be
used in conjunction with <a class="link" href="TheStorageKit_Functions.html#next_dev" title="next_dev()"><code class="function">next_dev()</code></a>
to scan all devices and record information your application requires.
</p><p>
The information about the device is returned in the
<a class="link" href="TheStorageKit_DefinedTypes.html#fs_info" title="fs_info"><span class="type">fs_info()</span></a>
structure <code class="parameter">info</code>
</p><p>
This function returns 0 if the request was successful or -1 if an error
occurred. Use the <code class="function">errno()</code> function to determine what
<code class="varname">error</code> in particular occurred.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The device was found; <code class="parameter">info</code> contains valid information.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p><code class="parameter">dev</code> doesn't identify an existing device.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheStorageKit_BMimeType_Functions"></a>MimeType Functions</h3></div></div></div><p>
Declared In: <code class="filename">storage/Mime.h</code>
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="create_app_meta_mime"></a>create_app_meta_mime()</h4></div></div></div><a id="id1264685" class="indexterm"></a><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">create_app_meta_mime</span>(<span class="methodparam"><span class="type">const char* </span><span class="parameter">path</span></span>,<br />                              <span class="methodparam"><span class="type">int </span><span class="parameter">recursive</span></span>,<br />                              <span class="methodparam"><span class="type">int </span><span class="parameter">synchronous</span></span>,<br />                              <span class="methodparam"><span class="type">int </span><span class="parameter">force</span></span>);</code><p>
Creates an entry in the File Types database for a specific application,
or for all applications:
</p><ul class="itemizedlist"><li><p>
To create an entry for a specific application, pass the path to the
application in <code class="parameter">path</code>. Information is taken from the app and written into
the database.
</p></li><li><p>
To create entries for all applications, pass a <code class="constant">NULL</code> path.
</p></li></ul><p>
The <code class="parameter">recursive</code> flag is currently unused.
</p><p>
If <code class="parameter">synchronous</code> is <code class="constant">true</code>,
the function doesn't return until the operation
is complete. If it's <code class="constant">false</code>, the function returns immediately while the
operation continues in the background.
</p><p>
If <code class="parameter">force</code> is <code class="constant">true</code>,
entries are created even if they already exist.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>No error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>You can't request recursive operation when a path is
specified.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="get_device_icon"></a>get_device_icon()</h4></div></div></div><a id="id1264857" class="indexterm"></a><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_device_icon</span>(<span class="methodparam"><span class="type">const char* </span><span class="parameter">device</span></span>,<br />                         <span class="methodparam"><span class="type">void* </span><span class="parameter">icon</span></span>,<br />                         <span class="methodparam"><span class="type">int32 </span><span class="parameter">size</span></span>);</code><p>
Returns the icons that are associated with the given device. You specify
which icon you want (large or small) by passing 32 or 16 as the <code class="parameter">size</code>
argument. The icon is then returned through the <code class="parameter">icon</code> argument.
</p><p>
See Also:
<a class="link" href="BVolume.html#BVolume_GetIcon" title="GetIcon()"><code class="methodname">BVolume::GetIcon()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="update_mime_info"></a>update_mime_info()</h4></div></div></div><a id="id1264938" class="indexterm"></a><code class="methodsynopsis c"><span class="type">int </span><span class="methodname">update_mime_info</span>(<span class="methodparam"><span class="type">const char* </span><span class="parameter">path</span></span>,<br />                     <span class="methodparam"><span class="type">int </span><span class="parameter">recursive</span></span>,<br />                     <span class="methodparam"><span class="type">int </span><span class="parameter">synchronous</span></span>,<br />                     <span class="methodparam"><span class="type">int </span><span class="parameter">force</span></span>);</code><p>
Updates the MIME information for one or more files, specified by <code class="parameter">path</code>. If
<code class="parameter">path</code> is <code class="constant">NULL</code>, all files are scanned recursively, and the value of
<code class="parameter">recursive</code> is ignored.
</p><p>
If <code class="parameter">recursive</code> is <code class="constant">true</code> and
<code class="parameter">path</code> indicates a directory, the directory tree
contained by <code class="parameter">path</code> is scanned, with every file in the tree being updated;
otherwise, just the file indicated by <code class="parameter">path</code> is updated.
</p><p>
If <code class="parameter">synchronous</code> is <code class="constant">true</code>,
<code class="function">update_mime_info()</code> doesn't return until the
update operation is complete. If it's <code class="constant">false</code>, <code class="function">update_mime_info()</code> runs
asynchronously, and returns immediately while updating continues in the
background.
</p><p>
If <code class="parameter">force</code> is <code class="constant">true</code>,
files are updated even if they've been updated already.
</p><p>
If an error occurs, <code class="function">update_mime_info()</code> returns a negative error code;
otherwise, it returns <code class="constant">B_OK</code>.
</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="The_Node_Monitor.html">The Node Monitor</a>  Up: <a href="TheStorageKit.html">The Storage Kit</a>  Next: <a href="TheStorageKit_Constants.html">Constants</a> </div><div id="footerB"><div id="footerBL"><a href="The_Node_Monitor.html" title="The Node Monitor"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheStorageKit.html" title="The Storage Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheStorageKit_Constants.html" title="Constants"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
