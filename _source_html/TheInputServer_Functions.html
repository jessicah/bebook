<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Input Server</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheInputServer.html" title="The Input Server" /><link rel="prev" href="BInputServerMethod.html" title="BInputServerMethod" /><link rel="next" href="TheInputServer_Messages.html" title="Message Constants" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BInputServerMethod.html" title="BInputServerMethod"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheInputServer.html" title="The Input Server"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="TheInputServer_Messages.html" title="Message Constants"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Input Server</div></div><div id="headerB">Prev: <a href="BInputServerMethod.html">BInputServerMethod</a>  Up: <a href="TheInputServer.html">The Input Server</a>  Next: <a href="TheInputServer_Messages.html">Message Constants</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheInputServer_Functions"></a>Functions</h2></div></div></div><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Declared In:</td><td><code class="filename">interface/InterfaceDefs.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libbe.so</code></td></tr></tbody></table></div><p>This section describes the global mouse and keyboard functions.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheInputServer_Functions_Mouse"></a>Mouse Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="set_click_speed"></a><a id="get_click_speed"></a>
set_click_speed(), get_click_speed()</h4></div></div></div><a id="id963127" class="indexterm"></a><a id="id963134" class="indexterm"></a><p>Declared in:  <code class="filename">interface/InterfaceDefs.h</code></p><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_click_speed</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">interval</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_click_speed</span>(<span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">interval</span></span>);</code><p>These functions set and report the timing for multiple-clicks. For
successive mouse-down events to count as a multiple-click, they must
occur within the interval set by <code class="function">set_click_speed()</code> and provided by
<code class="function">get_click_speed()</code>. The
<code class="parameter">interval</code> is measured in microseconds; it's usually
set by the user in the Mouse preferences application. The smallest
possible interval is 100,000 microseconds (0.1 second).</p><p>If successful, these functions return <code class="constant">B_OK</code>;
if unsuccessful, they return
an error code, which may be just <code class="constant">B_ERROR</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="set_mouse_map"></a><a id="get_mouse_map"></a>
<a id="set_mouse_type"></a>
<a id="get_mouse_type"></a>
<a id="set_mouse_speed"></a>
<a id="get_mouse_speed"></a>
set_mouse_map(), get_mouse_map(), set_mouse_type(), get_mouse_type()
, set_mouse_speed(), get_mouse_speed()</h4></div></div></div><a id="id963261" class="indexterm"></a><a id="id963268" class="indexterm"></a><a id="id963275" class="indexterm"></a><a id="id963282" class="indexterm"></a><a id="id963289" class="indexterm"></a><a id="id963296" class="indexterm"></a><p>Declared in:  <code class="filename">interface/InterfaceDefs.h</code></p><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_mouse_map</span>(<span class="methodparam"><span class="type">mouse_map </span><span class="parameter">map</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_mouse_map</span>(<span class="methodparam"><span class="type">mouse_map* </span><span class="parameter">map</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_mouse_type</span>(<span class="methodparam"><span class="type"> </span><span class="parameter">numButtons</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_mouse_type</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">numButtons</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_mouse_speed</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">speed</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_mouse_speed</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">speed</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_mouse_acceleration</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">acceleration</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_mouse_acceleration</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">acceleration</span></span>);</code><p>These functions configure the mouse and supply information about the
current configuration. The configuration should usually be left to the
user and the Mouse preferences application.</p><p><code class="function">set_mouse_map()</code> maps the buttons of the mouse to their roles in the user
interface, and <code class="function">get_mouse_map()</code> writes the current map into the variable
referred to by <code class="parameter">map</code>. The <span class="type">mouse_map</span> structure has a field for each button
on a three-button mouse:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">left</code></span></p></td><td><p>The button on the left of the mouse</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">right</code></span></p></td><td><p>The button on the right of the mouse</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">middle</code></span></p></td><td><p>The button in the middle, between the other two buttons</p></td></tr></tbody></table><p>Each field is set to one of the following constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_PRIMARY_MOUSE_BUTTON</code></p></li><li><p><code class="constant">B_SECONDARY_MOUSE_BUTTON</code></p></li><li><p><code class="constant">B_TERTIARY_MOUSE_BUTTON</code></p></li></ul><p>The same role can be assigned to more than one physical button. If all
three buttons are set to <code class="constant">B_PRIMARY_MOUSE_BUTTON</code>, they all function as the
primary button; if two of them are set to <code class="constant">B_SECONDARY_MOUSE_BUTTON</code>, they
both function as the secondary button; and so on.</p><p><code class="function">set_mouse_type()</code> informs the system of how many buttons the mouse
actually has. If it has two buttons, only the left and right fields of
the <span class="type">mouse_map</span> are operative. If it has just one button, only the left
field is operative. <code class="function">set_mouse_type()</code> writes the current number of buttons
into the variable referred to by <code class="parameter">numButtons</code>.</p><p><code class="function">set_mouse_speed()</code> sets the speed of the mouse—the rate at which the
cursor image moves on-screen relative to the actual speed at which the
user moves the mouse on its pad. A speed value of 0 is the slowest
movement rate. The maximum rate is 20, though even 10 is too fast for
most users. <code class="function">get_mouse_speed()</code> writes the current speed into the variable
referred to by <code class="parameter">speed</code>.</p><p><code class="function">set_mouse_acceleration()</code> sets the mouse's acceleration—the rate at
which the cursor image gains and loses speed as the user begins and
ceases moving the mouse. An acceleration value of 0 is the slowest
movement rate. The maximum rate is 20, though even 10 is too fast for
most users. <code class="function">get_mouse_acceleration()</code> writes the current acceleration into
the variable referred to by <code class="parameter">acceleration</code>.</p><p>All six functions return <code class="constant">B_OK</code> if successful, and an error code, typically
<code class="constant">B_ERROR</code>, if not.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="TheInputServer_Functions_Keyboard"></a>Keyboard Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="get_key_info"></a>get_key_info()</h4></div></div></div><a id="id963726" class="indexterm"></a><p>Declared in:  <code class="filename">interface/InterfaceDefs.h</code></p><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_key_info</span>(<span class="methodparam"><span class="type">key_info* </span><span class="parameter">keyInfo</span></span>);</code><p>Writes information about the state of the keyboard into the <span class="type">key_info</span>
structure referred to by <code class="parameter">keyInfo</code>. This function lets you get information
about the keyboard in the absence of <code class="constant">B_KEY_DOWN</code> messages. The <span class="type">key_info</span>
structure has just two fields:</p><table class="variablelist fields"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">modifiers</code></span></p></td><td><p>A mask indicating which modifier keys are down and which keyboard
locks are on.</p></td></tr><tr><td><p><span class="term"><span class="type">uint8</span> <code class="varname">key_states</code> [16]</span></p></td><td><p>A bit array that records the state of all the keys on the keyboard,
and all the keyboard locks. This array works identically to the "states"
array passed in a key-down message. See
"<a class="xref" href="TheKeyboard_KeyStates.html" title="Key States">Key States</a>"
in the <a class="xref" href="TheKeyboard.html" title="The Keyboard">The Keyboard</a> chapter
for information on how to read information from the array.</p></td></tr></tbody></table><p><code class="function">get_key_info()</code> returns <code class="constant">B_OK</code>
if it was able to get the requested
information, and <code class="constant">B_ERROR</code> if the return results are unreliable.</p><p>See also:
<a class="link" href="BView.html#BView_KeyDown" title="KeyDown()"><code class="methodname">BView::KeyDown()</code></a>,
<a class="link" href="TheInputServer_Functions.html#modifiers" title="modifiers()"><code class="function">modifiers()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="get_key_map"></a>get_key_map()</h4></div></div></div><a id="id963889" class="indexterm"></a><code class="methodsynopsis c"><span class="type">void </span><span class="methodname">get_key_map</span>(<span class="methodparam"><span class="type">key_map** </span><span class="parameter">keys</span></span>,<br />                 <span class="methodparam"><span class="type">char** </span><span class="parameter">chars</span></span>);</code><p>Declared in: <code class="filename">interface/InterfaceDefs.h</code></p><p>Provides a pointer to a copy of the system key map—the structure
that describes the role of each key on the keyboard. The pointers
returned by the function are yours; you must <code class="function">free()</code> them when you're
finished with them.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>In versions of the BeOS before Release 4, the pointers used to belong
to the operating system. Now they're yours to do with as you please.
Please update your applications as necessary to avoid leaking memory.</p></div></div></div><p>Through the Keymap preferences application, users can configure the
keyboard to their liking. The user's preferences are stored in a file
(<code class="filename">Key_map</code> within the <code class="constant">B_USER_SETTINGS_DIRECTORY</code>, returned by the
<a class="link" href="BDirectory.html#find_directory" title="find_directory()"><code class="function">find_directory()</code></a>
function). When the machine reboots, the key map is read
from this file. If the file doesn't exist, the original map encoded in
the Application Server is used.</p><p>The <span class="type">key_map</span> structure contains a large number of fields, but it can be
broken down into these six parts:</p><div class="orderedlist"><ol><li><p>A version number.</p></li><li><p>A series of fields that determine which keys will function as
modifier keys—such as <span class="keycap">Shift</span>, <span class="keycap">Control</span>,
or <span class="keycap">Num Lock</span>.</p></li><li><p>A field that sets the initial state of the keyboard locks in the
default key map.</p></li><li><p>A series of ordered tables that assign character values to keys.
Except for a handful of modifier keys, all keys are mapped to
characters, though they may not be mapped for all modifier combinations.</p></li><li><p>A series of tables that locate the dead keys for diacritical marks
and determine how a combination of a dead key plus another key is
mapped to a particular character.</p></li><li><p>A set of masks that determine which modifier keys are required for a
key to be considered dead.</p></li></ol></div><p>The following sections describe the parts of the <span class="type">key_map</span> structure.</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_version"></a>Version</h5></div></div></div><p>The first field of the key map is a version number:</p><table class="variablelist"><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">version</code></span></p></td><td><p>An internal identifier for the key map.</p></td></tr></tbody></table><p>The version number doesn't change when the user configures the keyboard,
and shouldn't be changed programmatically either. You can ignore it.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_Modifiers"></a>Modifiers</h5></div></div></div><p>Modifier keys set states that affect other user actions on the keyboard
and mouse. Eight modifier states are defined—<span class="keycap">Shift</span>, <span class="keycap">Control</span>,
<span class="keycap">Option</span>, <span class="keycap">Command</span>, <span class="keycap">Menu</span>,
<span class="keycap">Caps Lock</span>, <span class="keycap">Num Lock</span>, and <span class="keycap">Scroll Lock</span>. These states
are discussed under
"<a class="xref" href="TheKeyboard_ModifierKeys.html" title="Modifier Keys">Modifier Keys</a>" in the
<a class="link" href="TheKeyboard.html" title="The Keyboard">Keyboard Information</a> appendix.
They fairly closely match the key caps found on a Macintosh keyboard, but
only partially match those on a standard PC keyboard—which
generally has a set of <span class="keycap">Alt</span>(ernate) keys, rarely <span class="keycap">Option</span> keys, and only
sometimes <span class="keycap">Command</span> and <span class="keycap">Menu</span> keys. Because of these differences, the
mapping of keys to modifiers is the area of the key map most open to the
user's personal judgement and taste, and consequently to changes in the
default configuration.</p><p>Since two keys, one on the left and one on the right, can be mapped to
the <span class="keycap">Shift</span>, <span class="keycap">Control</span>, <span class="keycap">Option</span>,
and <span class="keycap">Command</span> modifiers, the keyboard can have
as many as twelve modifier keys. The <span class="type">key_map</span> structure has one field for
each key:</p><table class="variablelist fields"><col align="left" valign="top" width="1*" /><col align="left" valign="top" width="5*" /><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">caps_key</code></span></p></td><td><p>The key that functions as the <span class="keycap">Caps Lock</span> key; by default, this is the
key labeled "Caps Lock," key 0x3b.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">scroll_key</code></span></p></td><td><p>The key that functions as the <span class="keycap">Scroll Lock</span> key; by default, this is the
key labeled "Scroll Lock," key 0x0f.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">num_key</code></span></p></td><td><p>The key that functions as the <span class="keycap">Num Lock</span> key; by default, this is the
key labeled "Num Lock," key 0x22.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">left_shift_key</code></span></p></td><td><p>A key that functions as a <span class="keycap">Shift</span> key; by default, this is the key on
the left labeled "Shift," key 0x4b.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">right_shift_key</code></span></p></td><td><p>Another key that functions as a <span class="keycap">Shift</span> key; by default, this is the key
on the right labeled "Shift," key 0x56.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">left_command_key</code></span></p></td><td><p>A key that functions as a <span class="keycap">Command</span> key; by default, this is key 0x5d,
sometimes labeled "Alt."</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">right_command_key</code></span></p></td><td><p>Another key that functions as a <span class="keycap">Command</span> key; by default, this is key
0x5f, sometimes labeled "Alt."</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">left_control_key</code></span></p></td><td><p>A key that functions as a <span class="keycap">Control</span> key; by default, this is the key
labeled "Control" on the left, key 0x5c.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">right_control_key</code></span></p></td><td><p>Another key that functions as a <span class="keycap">Control</span> key; by default on keyboards
that have Option keys, this key is the key labeled "Control" on the
right, key 0x60. For keyboards that don't have <span class="keycap">Option</span> keys, this field is
unmapped (its value is 0); key 0x60 is used as an <span class="keycap">Option</span> key.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">left_option_key</code></span></p></td><td><p>A key that functions as an <span class="keycap">Option</span> key; by default, this is key 0x66,
which has different labels on different keyboards—"Option,"
"Command," or a Windows symbol. This key doesn't exist on, and therefore
isn't mapped for, a standard 101-key keyboard.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">right_option_key</code></span></p></td><td><p>A key that functions as an <span class="keycap">Option</span> key; by default, this is key 0x67,
which has different labels on different keyboards—"Option,"
"Command," or a Windows symbol. For keyboards without this key, the field
is mapped to the key labeled "Control" on the right, key 0x60.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">menu_key</code></span></p></td><td><p>A key that initiates keyboard navigation of the menu hierarchy; by
default, this is the key labeled with a menu symbol, key 0x68. This key
doesn't exist on, and therefore isn't mapped for, a standard 101-key
keyboard.</p></td></tr></tbody></table><p>Each field names the key that functions as that modifier. For example,
when the user holds down the key whose code is set in the
<code class="varname">right_option_key</code> field, the <code class="constant">B_OPTION_KEY</code>
and <code class="constant">B_RIGHT_OPTION_KEY</code> bits are
turned on in the modifiers mask that the
<a class="link" href="TheInputServer_Functions.html#modifiers" title="modifiers()"><code class="function">modifiers()</code></a> function returns.
When the user then strikes a character key, the <code class="constant">B_OPTION_KEY</code> state
influences the character that's generated.</p><p>If a modifier field is set to a value that doesn't correspond to an
actual key on the keyboard (including 0), that field is not mapped. No
key fills that particular modifier role.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_KeyboardLocks"></a>Keyboard locks</h5></div></div></div><p>One field of the key map sets initial modifier states:</p><table class="variablelist fields"><col align="left" valign="top" width="1*" /><col align="left" valign="top" width="4*" /><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">lock_settings</code></span></p></td><td><p>A mask that determines which keyboard locks are turned on when the
machine reboots or when the default key map is restored.</p></td></tr></tbody></table><p>The mask can be 0 or may contain any combination of these three constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_CAPS_LOCK</code></p></li><li><p><code class="constant">B_SCROLL_LOCK</code></p></li><li><p><code class="constant">B_NUM_LOCK</code></p></li></ul><p>It's 0 by default; there are no initial locks.</p><p>Altering the <code class="varname">lock_settings</code> field has no effect unless the altered key map
is made the default.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_CharacterMaps"></a>Character Maps</h5></div></div></div><p>The principal job of the key map is to assign character values to keys.
This is done in a series of nine tables:</p><table class="variablelist fields"><col align="left" valign="top" width="1*" /><col align="left" valign="top" width="4*" /><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">control_map</code> [128]</span></p></td><td><p>The characters that are produced when a <span class="keycap">Control</span> key is down but both
<span class="keycap">Command</span> keys are up.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">option_caps_shift_map</code> [128]</span></p></td><td><p>The characters that are produced when <span class="keycap">Caps Lock</span> is on and both a <span class="keycap">Shift</span>
key and an <span class="keycap">Option</span> key are down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">option_caps_map</code> [128]</span></p></td><td><p>The characters that are produced when <span class="keycap">Caps Lock</span> is on and an <span class="keycap">Option</span>
key is down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">option_shift_map</code> [128]</span></p></td><td><p>The characters that are produced when both a <span class="keycap">Shift</span> key and an <span class="keycap">Option</span>
key are down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">option_map</code> [128]</span></p></td><td><p>The characters that are produced when an <span class="keycap">Option</span> key is down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">caps_shift_map</code> [128]</span></p></td><td><p>The characters that are produced when <span class="keycap">Caps Lock</span> is on and a <span class="keycap">Shift</span> key
is down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">caps_map</code> [128]</span></p></td><td><p>The characters that are produced when <span class="keycap">Caps Lock</span> is on.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">shift_map</code> [128]</span></p></td><td><p>The characters that are produced when a <span class="keycap">Shift</span> key is down.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">normal_map</code> [128]</span></p></td><td><p>The characters that are produced when none of the other tables apply.</p></td></tr></tbody></table><p>Each of these tables is an array of 128 offsets into another array, the
chars array of Unicode <acronym class="acronym">UTF-8</acronym> character encodings. <code class="function">get_key_map()</code> provides
a pointer to the chars array as its second argument.</p><p>Key codes are used as indices into the character tables. The offset
stored at any particular index maps a character to that key. For example,
the code assigned to the <span class="keycap">M</span> key is 0x52; at index 0x52 in the
<code class="varname">option_caps_map</code> is an offset; at that offset in the chars array, you'll
find the character that's mapped to the <span class="keycap">M</span> key when an <span class="keycap">Option</span> key is held
down and <span class="keycap">Caps Lock</span> is on.</p><p>This indirection—an index to an offset to a character—is
required because characters are encoded as Unicode <acronym class="acronym">UTF-8</acronym> strings.
Character values of 127 or less (7-bit <acronym class="acronym">ASCII</acronym>) are just a single byte, but
<acronym class="acronym">UTF-8</acronym> takes two, three, or (rarely) four bytes to encode values over 127.</p><p>The chars array represents each character as a Pascal string—the
first byte in the string tells how many other bytes the string contains.
For example, the string for the trademark symbol (<span class="trademark"></span>™) looks like this:</p><pre class="screen">x03xE2x84xA2</pre><p>The first byte (x03) indicates that Unicode <acronym class="acronym">UTF-8</acronym> takes 3 bytes to
represent the trademark symbol, and those bytes follow (xE2x84xA2).
Pascal strings are not null-terminated.</p><p>Here's an example showing you how to decode the character tables. This
sample prints out a simple chart of the <code class="varname">normal_map</code>, <code class="varname">shift_map</code>,
<code class="varname">option_map</code>, and <code class="varname">option_shift_map</code> characters:</p><pre class="programlisting example c">#include &lt;interface/InterfaceDefs.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

static <span class="type">void</span> <code class="function">print_key</code>( <span class="type">char *</span><code class="parameter">chars</code>, <span class="type">int32</span> <code class="parameter">offset</code> )
{
   <span class="type">int</span> <code class="varname">size</code> = <code class="parameter">chars</code>[<code class="parameter">offset</code>++];

   switch( <code class="varname">size</code> ) {
   case 0:
      <span class="comment">// Not mapped</span>
      <code class="function">printf</code>( "N/A" );
      break;

   case 1:
      <span class="comment">// 1-byte UTF-8/ASCII character</span>
      <code class="function">printf</code>( "%c", <code class="parameter">chars</code>[<code class="parameter">offset</code>] );
      break;

   default:
      <span class="comment">// 2-, 3-, or 4-byte <acronym class="acronym">UTF-8</acronym> character</span>
      {
         <span class="type">char</span> <code class="varname">str</code>[5];
         <span class="type">int</span> <code class="varname">i</code> = (<code class="varname">size</code> &lt;= 4) ? <code class="varname">size</code> : 4;
         <code class="function">strncpy</code>( <code class="varname">str</code>, &amp;(<code class="parameter">chars</code>[<code class="parameter">offset</code>]), i );
         <code class="varname">str</code>[<code class="varname">i</code>] = '0';
         <code class="function">printf</code>( "%s", <code class="varname">str</code> );
      }
      break;
   }

   <code class="function">printf</code>( "\t" );
}

<span class="type">int</span> <code class="function">main</code>( <span class="type">void</span> )
{
   <span class="comment">// Get the current key map.</span>
   <span class="type">key_map *</span><code class="varname">keys</code>;
   <span class="type">char *</span><code class="varname">chars</code>;
   <code class="function">get_key_map</code>( &amp;<code class="varname">keys</code>, &amp;<code class="varname">chars</code> );

   <span class="comment">// Print a chart of the normal, shift, option, and option+shift
   // keys.</span>
   <code class="function">printf</code>( "Key #tNormaltShifttOptiontOption+Shiftn" );
   for( <span class="type">int</span> <code class="varname">idx</code> = 0; <code class="varname">idx</code> &lt; 128; <code class="varname">idx</code>++ ) {
      <code class="function">printf</code>( " %3dt", <code class="varname">idx</code> );
      <code class="function">print_key</code>( <code class="varname">chars</code>, <code class="varname">keys</code>-&gt;<code class="varname">normal_map</code>[<code class="varname">idx</code>] );
      <code class="function">print_key</code>( <code class="varname">chars</code>, <code class="varname">keys</code>-&gt;<code class="varname">shift_map</code>[<code class="varname">idx</code>] );
      <code class="function">print_key</code>( <code class="varname">chars</code>, <code class="varname">keys</code>-&gt;<code class="varname">option_map</code>[<code class="varname">idx</code>] );
      <code class="function">print_key</code>( <code class="varname">chars</code>, <code class="varname">keys</code>-&gt;<code class="varname">option_shift_map</code>[<code class="varname">idx</code>] );
      <code class="function">printf</code>( "\n" );
   }

   <span class="comment">// Free our copy of the key map.</span>
   <code class="function">free</code>( <code class="varname">chars</code> );
   <code class="function">free</code>( <code class="varname">keys</code> );

   return <code class="constant">EXIT_SUCCESS</code>;
}</pre><p>The character map tables are ordered. Values from the first applicable
table are used, even if another table might also seem to apply. For
example, if <span class="keycap">Caps Lock</span> is on and a <span class="keycap">Control</span>
key is down (and both <span class="keycap">Command</span>
keys are up), the <code class="varname">control_map</code> array is used, not
<code class="varname">caps_map</code>. If a <span class="keycap">Shift</span> key
is down and <span class="keycap">Caps Lock</span> is on, the <code class="varname">caps_shift_map</code>
is used, not <code class="varname">shift_map</code> or
<code class="varname">caps_map</code>.</p><p>Notice that the last eight tables (all except <code class="varname">control_map</code>) are paired,
with a table that names the <span class="keycap">Shift</span> key (<code class="varname">…_shift_map</code>) preceding an
equivalent table without <span class="keycap">Shift</span>:</p><ul class="itemizedlist"><li><p><code class="varname">option_caps_shift_map</code> is paired
with <code class="varname">option_caps_map</code>,</p></li><li><p><code class="varname">option_shift_map</code> with <code class="varname">option_map</code>,</p></li><li><p><code class="varname">caps_shift_map</code> with <code class="varname">caps_map</code>, and</p></li><li><p><code class="varname">shift_map</code> with <code class="varname">normal_map</code>.</p></li></ul><p>These pairings are important for a special rule that applies to keys on
the numerical keypad when <span class="keycap">Num Lock</span> is on:</p><ul class="itemizedlist"><li><p>If the <span class="keycap">Shift</span> key is down, the non-<span class="keycap">Shift</span> table is used.</p></li><li><p>However, if the <span class="keycap">Shift</span> key is not down,
the <span class="keycap">Shift</span> table is used.</p></li></ul><p>In other words, <span class="keycap">Num Lock</span> inverts the
<span class="keycap">Shift</span> and non-<span class="keycap">Shift</span> tables for keys
on the numerical keypad.</p><p>Not every key needs to be mapped to a character. If the chars array has a
0-length string for a key, the key is not mapped to a character (given
the particular modifier states the table represents). Generally, modifier
keys are not mapped to characters, but all other keys are, at least for
some tables. Key-down events are not generated for unmapped keys.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_DeadKeys"></a>Dead keys</h5></div></div></div><p>Next are the tables that map combinations of keys to single characters.
The first key in the combination is "dead"—it doesn't produce a
key-down event until the user strikes another character key. When the
user hits the second key, one of two things will happen: If the second
key is one that can be used in combination with the dead key, a single
key-down event reports the combination character. If the second key
doesn't combine with the dead key, two key-down events occur, one
reporting the dead-key character and one reporting the second character.</p><p>There are five dead-key tables:</p><table class="variablelist fields"><col align="left" valign="top" width="1*" /><col align="left" valign="top" width="5*" /><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">int32</span> <code class="varname">acute_dead_key</code> [32]</span></p></td><td><p>The table for combining an acute accent (´) with other characters.</p></td></tr><tr><td><p><span class="term"><span class="type">int32</span> <code class="varname">grave_dead_key</code> [32]</span></p></td><td><p>The table for combining a grave accent (`) with other characters.</p></td></tr><tr><td><p><span class="term"><span class="type">int32</span> <code class="varname">circumflex_dead_key</code> [32]</span></p></td><td><p>The table for combining a circumflex (^) with other characters.</p></td></tr><tr><td><p><span class="term"><span class="type">int32</span> <code class="varname">dieresis_dead_key</code> [32]</span></p></td><td><p>The table for combining a dieresis (¨) with other characters.</p></td></tr><tr><td><p><span class="term"><span class="type">int32</span> <code class="varname">tilde_dead_key</code> [32]</span></p></td><td><p>The table for combining a tilde (~) with other characters</p></td></tr></tbody></table><p>The tables are named after diacritical marks that can be placed on more
than one character. However, the name is just a mnemonic; it means
nothing. The contents of the table determine what the dead key is and how
it combines with other characters. It would be possible, for example, to
remap the <code class="varname">tilde_dead_key</code> table so that it had nothing
to do with a tilde.</p><p>Each table consists of a series of up to 16 offset pairs—where, as
in the case of the character maps, each offset picks a character from the
chars character array. The first character in the pair is the one that
must be typed immediately after the dead key. The second character is the
resulting character, the character that's produced by the combination of
the dead key plus the first character in the pair. For example, if the
first character is 'o', the second might be '^'—meaning that the
combination of a dead key plus the character 'o' produces a circumflexed
'ô'.</p><p>The character pairs for the default <code class="varname">grave_dead_key</code> array look something
like this:</p><pre class="screen">' ', ''',
'A', 'À',
'E', 'È',
'I', 'Ì',
'O', 'Ò',
'U', 'Ù',
'a', 'à',
'e', 'è',
'i', 'ì''o', 'ò',
'u', 'ù',
. . .</pre><p>By convention, the first offset in each array is to the <code class="constant">B_SPACE</code> character
and the second is to the dead-key character itself. This pair does double
duty: It states that the dead key plus a space yields the dead-key
character, and it also names the dead key. The system understands what
the dead key is from the second offset in the array.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="KeyMap_CharacterTablesForDeadKeys"></a>Character Tables For Dead Keys</h5></div></div></div><p>As mentioned above, for a key to be dead, it must be mapped to the
character picked by the second offset in a dead-key array. However, it's
not typical for every key that's mapped to the character to be dead.
Usually, there's a requirement that the user must hold down certain
modifier keys (often the <span class="keycap">Option</span> key). In other words, a key is dead only
if selected character-map tables map it to the requisite character.</p><p>Five additional fields of the <span class="type">key_map</span> structure specify what those
character-map tables are—which modifiers are required for each of
the dead keys:</p><table class="variablelist fields"><col align="left" valign="top" width="1*" /><col align="left" valign="top" width="5*" /><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">acute_tables</code></span></p></td><td><p>The character tables that cause a key to be dead when they map it to
the second character in the acute_dead_key array.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">grave_tables</code></span></p></td><td><p>The character tables that cause a key to be dead when they map it to
the second character in the grave_dead_key array.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">circumflex_tables</code></span></p></td><td><p>The character tables that cause a key to be dead when they map it to
the second character in the circumflex_dead_key array.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">dieresis_tables</code></span></p></td><td><p>The character tables that cause a key to be dead when they map it to
the second character in the dieresis_dead_key array.</p></td></tr><tr><td><p><span class="term"><span class="type">uint32</span> <code class="varname">tilde_tables</code></span></p></td><td><p>The character tables that cause a key to be dead when they map it to
the second character in the tilde_dead_key array.</p></td></tr></tbody></table><p>Each of these fields contains a mask formed from the following constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_CONTROL_TABLE</code></p></li><li><p><code class="constant">B_CAPS_SHIFT_TABLE</code></p></li><li><p><code class="constant">B_OPTION_CAPS_SHIFT_TABLE</code></p></li><li><p><code class="constant">B_CAPS_TABLE</code></p></li><li><p><code class="constant">B_OPTION_CAPS_TABLE</code></p></li><li><p><code class="constant">B_SHIFT_TABLE</code></p></li><li><p><code class="constant">B_OPTION_SHIFT_TABLE</code></p></li><li><p><code class="constant">B_NORMAL_TABLE</code></p></li><li><p><code class="constant">B_OPTION_TABLE</code></p></li></ul><p>The mask designates the character-map tables that permit a key to be
dead. For example, if the mask for the <code class="varname">grave_tables</code> field is,</p><pre class="programlisting example c"><code class="constant">B_OPTION_TABLE</code> | <code class="constant">B_OPTION_CAPS_SHIFT_TABLE</code></pre><p>a key would be dead whenever either of those tables mapped the key to the
character of the second offset in the <code class="varname">grave_dead_key</code> array ('Q' in the
example above). A key mapped to the same character by another table would
not be dead.</p><p>See also:
<a class="link" href="TheInputServer_Functions.html#get_key_info" title="get_key_info()"><code class="function">get_key_info()</code></a>,
<a class="link" href="TheInputServer_Functions.html#modifiers" title="modifiers()"><code class="function">modifiers()</code></a>,
the Keyboard Information appendix,
<a class="link" href="TheInputServer_Functions.html#set_modifier_key" title="set_modifier_key()"><code class="function">set_modifier_key()</code></a></p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="get_keyboard_id"></a>get_keyboard_id()</h4></div></div></div><a id="id966061" class="indexterm"></a><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_keyboard_id</span>(<span class="methodparam"><span class="type">uint16* </span><span class="parameter">id</span></span>);</code><p>Declared in:  <code class="filename">interface/InterfaceDefs.h</code></p><p>Obtains the keyboard identifier from the Application Server and device
driver and writes it into the variable referred to by <code class="parameter">id</code>. This number
reveals what kind of keyboard is currently attached to the computer.</p><p>The identifier for the standard 101-key PC keyboard—and for
keyboards with a similar set of keys—is 0x83ab.</p><p>If unsuccessful for any reason, <code class="function">get_keyboard_id()</code>
returns <code class="constant">B_ERROR</code>. If
successful, it returns <code class="constant">B_OK</code>.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="modifiers"></a>modifiers()</h4></div></div></div><a id="id966142" class="indexterm"></a><code class="methodsynopsis c"><span class="type">uint32 </span><span class="methodname">modifiers</span>();</code><p>Declared in: <code class="filename">interface/InterfaceDefs.h</code></p><p>Returns a mask that has a bit set for each modifier key the user is
holding down and for each keyboard lock that's set. The mask can be
tested against these constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_SHIFT_KEY</code></p></li><li><p><code class="constant">B_COMMAND_KEY</code></p></li><li><p><code class="constant">B_CAPS_LOCK</code></p></li><li><p><code class="constant">B_CONTROL_KEY</code></p></li><li><p><code class="constant">B_MENU_KEY</code></p></li><li><p><code class="constant">B_SCROLL_LOCK</code></p></li><li><p><code class="constant">B_OPTION_KEY</code></p></li><li><p><code class="constant">B_NUM_LOCK</code></p></li></ul><p>No bits are set (the mask is 0) if no locks are on and none of the
modifiers keys are down.</p><p>If it's important to know which physical key the user is holding down,
the one on the right or the one on the left, the mask can be further
tested against these constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_LEFT_SHIFT_KEY</code></p></li><li><p><code class="constant">B_RIGHT_SHIFT_KEY</code></p></li><li><p><code class="constant">B_LEFT_CONTROL_KEY</code></p></li><li><p><code class="constant">B_RIGHT_CONTROL_KEY</code></p></li><li><p><code class="constant">B_LEFT_OPTION_KEY</code></p></li><li><p><code class="constant">B_RIGHT_OPTION_KEY</code></p></li><li><p><code class="constant">B_LEFT_COMMAND_KEY</code></p></li><li><p><code class="constant">B_RIGHT_COMMAND_KEY</code></p></li></ul><p>By default, the keys closest to the space bar function as
<span class="keycap">Command</span> keys, no matter what their labels on particular
keyboards. If a keyboard doesn't have <span class="keycap">Option</span> keys (for
example, a standard 101-key keyboard), the key on the right labeled &amp;
quot;Control" functions as the right <span class="keycap">Option</span> key, and
only the left "Control" key is available to function as a
<span class="keycap">Control</span> modifier. However, users can change this
configuration with the <span class="application">/bin/keymap</span>
application.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="set_key_repeat_rate"></a><a id="get_key_repeat_rate"></a>
<a id="set_key_repeat_delay"></a>
<a id="get_key_repeat_delay"></a>
set_key_repeat_rate(), get_key_repeat_rate(), set_key_repeat_delay(),
get_key_repeat_delay()</h4></div></div></div><a id="id966397" class="indexterm"></a><a id="id966404" class="indexterm"></a><a id="id966411" class="indexterm"></a><a id="id966418" class="indexterm"></a><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_key_repeat_rate</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">rate</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_key_repeat_rate</span>(<span class="methodparam"><span class="type">int32* </span><span class="parameter">rate</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">set_key_repeat_delay</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">delay</span></span>);</code><code class="methodsynopsis c"><span class="type">status_t </span><span class="methodname">get_key_repeat_delay</span>(<span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">delay</span></span>);</code><p>Declared in: <code class="filename">interface/InterfaceDefs.h</code></p><p>These functions set and report the timing of repeating keys. When the
user presses a character key on the keyboard, it produces an immediate
<code class="constant">B_KEY_DOWN</code> message. If the user continues to hold the key down, it will,
after an initial delay, continue to produce messages at regularly spaced
intervals—until the user releases the key or presses another key.
The delay and the spacing between messages are both preferences the user
can set with the <span class="application">Keyboard</span> application.</p><p><code class="function">set_key_repeat_rate()</code> sets the number of messages repeating keys produce
per second. For a standard PC keyboard, the rate can be as low as 2 and
as high as 30; <code class="function">get_key_repeat_rate()</code> writes the current setting into the
integer that rate refers to.</p><p><code class="function">set_key_repeat_delay()</code> sets the length of the initial delay before the
key begins repeating. Acceptable values are 250,000, 500,000, 750,000 and
1,000,000 microseconds (.25, .5, .75, and 1.0 second);
<code class="function">get_key_repeat_delay()</code> writes the current setting into the variable that
delay points to.</p><p>All four functions return <code class="constant">B_OK</code> if they successfully communicate with the
Application Server, and <code class="constant">B_ERROR</code> if not.
It's possible for the <code class="function">set…()</code>
functions to communicate with the server but not succeed in setting the
rate or delay (for example, if the delay isn't one of the listed four
values).</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="set_keyboard_locks"></a>set_keyboard_locks()</h4></div></div></div><a id="id966600" class="indexterm"></a><code class="methodsynopsis c"><span class="type">void </span><span class="methodname">set_keyboard_locks</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">modifiers</span></span>);</code><p>Declared in: <code class="filename">interface/InterfaceDefs.h</code></p><p>Turns the keyboard locks—<span class="keycap">Caps Lock</span>,
<span class="keycap">Num Lock</span>, and <span class="keycap">Scroll Lock</span>—on
and off. The keyboard locks that are listed in the
modifiers mask passed as an argument are turned on; those not listed are
turned off. The mask can be 0 (to turn off all locks) or it can contain
any combination of the following constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_CAPS_LOCK</code></p></li><li><p><code class="constant">B_NUM_LOCK</code></p></li><li><p><code class="constant">B_SCROLL_LOCK</code></p></li></ul><p>See also:
<a class="link" href="TheInputServer_Functions.html#get_key_map" title="get_key_map()"><code class="function">get_key_map()</code></a>,
<a class="link" href="TheInputServer_Functions.html#modifiers" title="modifiers()"><code class="function">modifiers()</code></a></p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="set_modifier_key"></a>set_modifier_key()</h4></div></div></div><a id="id966717" class="indexterm"></a><code class="methodsynopsis c"><span class="type">void </span><span class="methodname">set_modifier_key</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">modifier</span></span>,<br />                      <span class="methodparam"><span class="type">uint32 </span><span class="parameter">key</span></span>);</code><p>Declared in: <code class="filename">interface/InterfaceDefs.h</code></p><p>Maps a modifier role to a particular key on the keyboard, where key is a
key identifier and modifier is one of the these constants:</p><ul class="itemizedlist nomarker"><li><p><code class="constant">B_CAPS_LOCK</code></p></li><li><p><code class="constant">B_LEFT_SHIFT_KEY</code></p></li><li><p><code class="constant">B_RIGHT_SHIFT_KEY</code></p></li><li><p><code class="constant">B_NUM_LOCK</code></p></li><li><p><code class="constant">B_LEFT_CONTROL_KEY</code></p></li><li><p><code class="constant">B_RIGHT_CONTROL_KEY</code></p></li><li><p><code class="constant">B_SCROLL_LOCK</code></p></li><li><p><code class="constant">B_LEFT_OPTION_KEY</code></p></li><li><p><code class="constant">B_RIGHT_OPTION_KEY</code></p></li><li><p><code class="constant">B_MENU_KEY</code></p></li><li><p><code class="constant">B_LEFT_COMMAND_KEY</code></p></li><li><p><code class="constant">B_RIGHT_COMMAND_KEY</code></p></li></ul><p>The key in question serves as the named modifier key, unmapping any key
that previously played that role. The change remains in effect until the
default key map is restored. In general, the user's preferences for
modifier keys—expressed in the <span class="application">Keymap</span>
application—should be respected.</p><p>Modifier keys can also be mapped by calling
<a class="link" href="TheInputServer_Functions.html#get_key_map" title="get_key_map()"><code class="function">get_key_map()</code></a>
and altering the <a class="link" href="TheInterfaceKit_DefinedTypes.html#key_map" title="key_map"><span class="type">key_map</span></a>
structure directly. This function is merely a convenient
alternative for accomplishing the same thing. (It's currently not
possible to alter the key map;
<a class="link" href="TheInputServer_Functions.html#get_key_map" title="get_key_map()"><code class="function">get_key_map()</code></a>
looks at a copy.)</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="instantiate_input_device"></a>instantiate_input_device()</h4></div></div></div><a id="id966932" class="indexterm"></a><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>TODO: This function does not appear in the BeBook</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="instantiate_input_filter"></a>instantiate_input_filter()</h4></div></div></div><a id="id966958" class="indexterm"></a><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>TODO: This function does not appear in the BeBook</p></div></div></div></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BInputServerMethod.html">BInputServerMethod</a>  Up: <a href="TheInputServer.html">The Input Server</a>  Next: <a href="TheInputServer_Messages.html">Message Constants</a> </div><div id="footerB"><div id="footerBL"><a href="BInputServerMethod.html" title="BInputServerMethod"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheInputServer.html" title="The Input Server"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="TheInputServer_Messages.html" title="Message Constants"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
