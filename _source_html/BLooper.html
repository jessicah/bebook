<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Application Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheApplicationKit.html" title="The Application Kit" /><link rel="prev" href="BInvoker.html" title="BInvoker" /><link rel="next" href="BMessage.html" title="BMessage" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BInvoker.html" title="BInvoker"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheApplicationKit.html" title="The Application Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BMessage.html" title="BMessage"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Application Kit</div></div><div id="headerB">Prev: <a href="BInvoker.html">BInvoker</a>  Up: <a href="TheApplicationKit.html">The Application Kit</a>  Next: <a href="BMessage.html">BMessage</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper"></a>BLooper</h2></div></div></div><a id="id694566" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td><a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a></td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">app/Looper.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libbe.so</code></td></tr><tr><td>Allocation:</td><td>–</td></tr></tbody></table></td><td>
<a class="link overview" href="BLooper_Overview.html" title="BLooper">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BLooper.html#BLooper_ConstuctorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BLooper.html#BLooper_HookFunctions">Hook Functions</a></span></li><li><span class="section"><a href="BLooper.html#BLooper_MemberFunctions">Member Functions</a></span></li><li><span class="section"><a href="BLooper.html#BLooper_StaticFunctions">Static Functions</a></span></li><li><span class="section"><a href="BLooper.html#BLooper_Constants">Constants</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_ConstuctorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Constructor"></a>BLooper()</h4></div></div></div><div class="synopsisgroup">
<code class="constructorsynopsis cpp"><span class="methodname"><span class="classname">BLooper</span></span>(<span class="methodparam"><span class="modifier">const </span><span class="type">char* </span><span class="parameter">name</span><span class="initializer"> = <span class="constant">NULL</span></span></span>,<br />        <span class="methodparam"><span class="type">int32 </span><span class="parameter">priority</span><span class="initializer"> = <span class="constant">B_NORMAL_PRIORITY</span></span></span>,<br />        <span class="methodparam"><span class="type">int32 </span><span class="parameter">portCapacity</span><span class="initializer"> = <span class="constant">B_LOOPER_PORT_DEFAULT_CAPACITY</span></span></span>);</code>

<code class="constructorsynopsis cpp"><span class="methodname"><span class="classname">BLooper</span></span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">archive</span></span>);</code>
</div><p>
Assigns the <code class="classname">BLooper</code> object a <code class="parameter">name</code>
and then locks it (by calling
<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">Lock()</code></a>).
<code class="parameter">priority</code> is a value that describes the amount of CPU
attention the message loop will receive once it starts running, and
<code class="parameter">portCapacity</code> is the number of messages the
<code class="classname">BLooper</code> can hold in its "message port"
(this is <span class="emphasis"><em>not</em></span> the message queue, as explained below).
</p><p>
After you construct the <code class="classname">BLooper</code>, you have to tell it
to <a class="link" href="BLooper.html#BLooper_Run" title="Run()"><code class="methodname">Run()</code></a>.
Because the object is locked, <a class="link" href="BLooper.html#BLooper_Run" title="Run()"><code class="methodname">Run()</code></a> can only be
called from the thread that constructed the object. It's legal to invoke
<a class="link" href="BLooper.html#BLooper_Run" title="Run()"><code class="methodname">Run()</code></a> from
within a subclass implementation of the constructor.
</p><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Constructor_Priority"></a>Priority</h5></div></div></div><p>
A set of priority values are defined in <code class="filename">kernel/OS.h</code>;
from lowest to highest, they are:
</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_LOW_PRIORITY</code></span></p></td><td><p>For threads running in the background that shouldn't interrupt other threads.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NORMAL_PRIORITY</code></span></p></td><td><p>For all ordinary threads, including the main thread.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DISPLAY_PRIORITY</code></span></p></td><td><p>For threads associated with objects in the user interface, including window threads.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_URGENT_DISPLAY_PRIORITY</code></span></p></td><td><p>For interface threads that deserve more attention than ordinary windows.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_REAL_TIME_DISPLAY_PRIORITY</code></span></p></td><td><p>For threads that animate the on-screen display.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_URGENT_PRIORITY</code></span></p></td><td><p>For threads performing time-critical computations.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_REAL_TIME_PRIORITY</code></span></p></td><td><p>For threads controlling real-time processes that need
unfettered access to the CPUs.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Constructor_PortCapacity"></a>Port Capacity</h5></div></div></div><p>
Messages that are sent to a <code class="classname">BLooper</code> first show up in
a port (as the term is defined by the <a class="link" href="TheKernelKit.html" title="The Kernel Kit">Kernel
Kit</a>), and then are moved to the <a class="link" href="BMessageQueue.html" title="BMessageQueue"><code class="classname">BMessageQueue</code></a>. The
capacity of the <a class="link" href="BMessageQueue.html" title="BMessageQueue"><code class="classname">BMessageQueue</code></a> is
virtually unlimited; the capacity of the port is not. Although messages are
moved from the port to the queue as quickly as possible, the port can fill
up. A full port will block subsequent message senders.
</p><p>
The default port capacity (100), should be sufficient for most apps, but
you can fiddle with it through the <code class="parameter">portCapacity</code>
argument.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Destructor"></a>~BLooper()</h4></div></div></div><code class="destructorsynopsis cpp"><span class="modifier">virtual </span><span class="methodname">~BLooper</span>();</code><p>
Frees the message queue and all pending messages and deletes the message loop.
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>s that have
been added to the <code class="classname">BLooper</code> are not deleted, but
<a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>
objects added as common filters are.
</p><p>
In general, you should never delete your <code class="classname">BLooper</code> objects:
With the exception of the
<a class="link" href="BApplication.html" title="BApplication"><code class="classname">BApplication</code></a>
object, <code class="classname">BLooper</code>s are destroyed by the
<a class="link" href="BLooper.html#BLooper_Quit" title="Quit()"><code class="methodname">Quit()</code></a> function.
</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>If you create a <code class="classname">BLooper</code>-derived class that uses
multiple inheritance, make sure the first class your mixin class inherits
from is <code class="classname">BLooper</code>; otherwise, you'll crash when you
try to close the window. This happens because of an interaction between the
window thread how C++ deletes objects of a multiply-inherited class. In
other words:</p><pre class="programlisting example cpp">class <code class="classname">myClass</code> : public <code class="classname">BLooper</code>, public <code class="classname">OtherClass</code> {
   ...
};</pre><p>is safe, whilst</p><pre class="programlisting example cpp">class <code class="classname">myClass</code> : public <code class="classname">OtherClass</code>, public <code class="classname">BLooper</code> {
   ...
};</pre><p>is not.</p></div></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_HookFunctions"></a>Hook Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_DispatchMessage"></a>DispatchMessage()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">DispatchMessage</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>,<br />                             <span class="methodparam"><span class="type">BHandler* </span><span class="parameter">target</span></span>);</code><p>
<code class="methodname">DispatchMessage()</code> is the
<code class="classname">BLooper</code>'s central message-processing function. It's
called automatically as messages arrive in the looper's queue, one
invocation per message. You never invoke
<code class="methodname">DispatchMessage()</code> yourself.
</p><p>
The default implementation passes <code class="parameter">message</code> to
<code class="parameter">handler</code> by invoking the latter's <a class="link" href="BHandler.html#BHandler_MessageReceived" title="MessageReceived()"><code class="methodname">MessageReceived()</code>
</a>:
</p><pre class="programlisting example cpp"><code class="varname">target</code>-&gt;<code class="methodname">MessageReceived</code>(<code class="varname">message</code>);</pre><p>
The only exception is where <code class="parameter">message</code>.what is
<a class="link" href="TheApplicationKit_MessageConstants.html#B_QUIT_REQUESTED" title="B_QUIT_REQUESTED"><code class="constant">B_QUIT_REQUESTED</code></a>
and <code class="parameter">handler</code> is
the looper itself; in this case, the object invokes its own <a class="link" href="BLooper.html#BLooper_QuitRequested" title="QuitRequested()"><code class="methodname">QuitRequested()</code></a>
function.
</p><p>
You can override this function to dispatch the messages that your own
application defines or recognizes. All unhandled messages should be passed
to the base class version, as demonstrated below:
</p><pre class="programlisting example cpp"><span class="type">void</span> <code class="classname">MyLooper</code>::<code class="methodname">DispatchMessage</code>(<span class="type">BMessage *</span><code class="parameter">msg</code>,
                               <span class="type">BHandler *</span><code class="parameter">target</code>)
{
   switch ( <code class="parameter">msg</code>-&gt;<code class="varname">what</code> ) {
   case <code class="constant">MY_MESSAGE1</code>:
      ...
      break;
   case <code class="constant">MY_MESSAGE2</code>:
      ...
      break;
   default:
      <span class="emphasis"><em><code class="classname">baseClass</code></em></span>::<code class="methodname">DispatchMessage</code>(<code class="parameter">msg</code>, <code class="parameter">target</code>);
      break;
   }
}</pre><p>
Also, note that you mustn't delete <code class="parameter">message</code>; it's deleted for you..
</p><p>
The system locks the <code class="classname">BLooper</code> before calling
<code class="methodname">DispatchMessage()</code> and keeps it locked for the
duration of the function.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_QuitRequested"></a>QuitRequested()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">bool </span><span class="methodname">QuitRequested</span>();</code><p>
Hook function that's invoked when the <code class="classname">BLooper</code> receives a
<a class="link" href="TheApplicationKit_MessageConstants.html#B_QUIT_REQUESTED" title="B_QUIT_REQUESTED"><code class="constant">B_QUIT_REQUESTED</code></a>
message. You never invoke this function directly. Derived classes implement
this function to return <code class="constant">true</code> if it's okay to quit
this <code class="classname">BLooper</code>, and <code class="constant">false</code>
if not. Note that this function does not actually quit the object—the
code that handles the
<a class="link" href="TheApplicationKit_MessageConstants.html#B_QUIT_REQUESTED" title="B_QUIT_REQUESTED"><code class="constant">B_QUIT_REQUESTED</code></a>
message does that.
</p><p>
<code class="classname">BLooper</code>'s default implementation of <code class="methodname">QuitRequested()</code> always returns <code class="constant">true</code>.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_AddCommonFilter"></a><a id="BLooper_RemoveCommonFilter"></a>
<a id="BLooper_SetCommonFilterList"></a>
<a id="BLooper_CommonFilterList"></a>
AddCommonFilter(), RemoveCommonFilter(), SetCommonFilterList(), CommonFilterList()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">void </span><span class="methodname">AddCommonFilter</span>(<span class="methodparam"><span class="type">BMessageFilter* </span><span class="parameter">filter</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">bool </span><span class="methodname">RemoveCommonFilter</span>(<span class="methodparam"><span class="type">BMessageFilter* </span><span class="parameter">filter</span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">void </span><span class="methodname">SetCommonFilterList</span>(<span class="methodparam"><span class="type">BList* </span><span class="parameter">filters</span></span>);</code><code class="methodsynopsis cpp"><span class="type">BList* </span><span class="methodname">CommonFilterList</span>() <span class="modifier">const</span>;</code><p>
These functions manage the <code class="classname">BLooper</code>'s list of <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>s.
Message filters are objects that screen in-coming messages. In the case of
<code class="classname">BLooper</code>, each message is passed through all filters
in the list before it's passed on to <a class="link" href="BLooper.html#BLooper_DispatchMessage" title="DispatchMessage()"><code class="methodname">DispatchMessage()</code></a>.
The order of the filters in the list is determinate. See the <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a> class
for details on how message filters work.
</p><p>
<code class="methodname">AddCommonFilter()</code> adds <code class="parameter">filter</code> to the end of the
filter list (creating a <a class="link" href="BList.html" title="BList"><code class="classname">BList</code></a> container if
necessary).
</p><p>
<code class="methodname">RemoveCommonFilter()</code> removes <code class="parameter">filter</code> from the list,
but doesn't free the filter. It returns <code class="constant">true</code> if
successful, and <code class="constant">false</code> if it can't find the specified
filter.
</p><p>
<code class="methodname">SetCommonFilterList()</code> deletes the current filter
list and its contents, and replaces it with <code class="parameter">filters</code>.
All elements in <code class="parameter">filters</code> must be <a class="link" href="BMessageFilter.html" title="BMessageFilter"><code class="classname">BMessageFilter</code></a>
pointers. The <code class="classname">BLooper</code> takes ownership of all objects
in <code class="parameter">filters</code>, as well as
<code class="parameter">filters</code> itself. If <code class="parameter">filters</code> is
<code class="constant">NULL</code>, the current list is deleted without a
replacement.
</p><p>
<code class="methodname">CommonFilterList()</code> returns a pointer to the
current list. You can examine the list but you shouldn't modify or delete
it.
</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>For all but <code class="methodname">CommonFilterList()</code>, the
<code class="classname">BLooper</code> must be locked.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_AddHandler"></a><a id="BLooper_RemoveHandler"></a>
<a id="BLooper_HandlerAt"></a>
<a id="BLooper_CountHandlers"></a>
<a id="BLooper_IndexOf"></a>
AddHandler(), RemoveHandler(), HandlerAt(), CountHandlers(), IndexOf()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">AddHandler</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>);</code><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">RemoveHandler</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>);</code><code class="methodsynopsis cpp"><span class="type">BHandler* </span><span class="methodname">HandlerAt</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">index</span></span>) <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">int32 </span><span class="methodname">CountHandlers</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">int32 </span><span class="methodname">IndexOf</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>) <span class="modifier">const</span>;</code><p>
<code class="methodname">AddHandler()</code> adds <code class="parameter">handler</code> to the
<code class="classname">BLooper</code>'s list of
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>
objects, and <code class="methodname">RemoveHandler()</code> removes it. Only
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> that
have been added to the list are eligible to respond to the messages the
<code class="classname">BLooper</code> dispatches.
</p><p>
<code class="methodname">AddHandler()</code> fails if the handler already belongs
to a <code class="classname">BLooper</code>; a
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> can
belong to no more than one <code class="classname">BLooper</code> at a time. It
can change its affiliation from time to time, but must be removed from one
<code class="classname">BLooper</code> before it can be added to another.
<code class="methodname">RemoveHandler()</code> returns <code class="constant">true</code>
if it succeeds in removing the
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>
from the <code class="classname">BLooper</code>, and <code class="constant">false</code> if
not or if the handler doesn't belong to the <code class="classname">BLooper</code>
in the first place.
</p><p>
<code class="methodname">AddHandler()</code> also calls the handler's
<a class="link" href="BHandler.html#BHandler_SetNextHandler" title="SetNextHandler(), NextHandler()"><code class="methodname">SetNextHandler()</code></a>
function to assign it the <code class="classname">BLooper</code> as its default next
handler. <code class="methodname">RemoveHandler()</code> calls the same function to
set the handler's next handler to <code class="constant">NULL</code>.
</p><p>
<code class="methodname">HandlerAt()</code> returns the
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> object
currently located at <code class="parameter">index</code> in the
<code class="classname">BLooper</code>'s list of eligible handlers, or
<code class="constant">NULL</code> if the index is out of range. Indices begin at
0 and there are no gaps in the list. <code class="methodname">CountHandlers()</code>
returns the number of objects currently in the list; the count should always
be at least 1, since the list automatically includes the
<code class="classname">BLooper</code> itself. <code class="methodname">IndexOf()</code>
returns the index of the specified <code class="parameter">handler</code>, or
<code class="constant">B_ERROR</code> if that object isn't in the list.
</p><p>
For any of these functions to work, the <code class="classname">BLooper</code> must be locked.
</p><p>
See also: <a class="link" href="BHandler.html#BHandler_Looper" title="Looper()"><code class="methodname">BHandler::Looper()</code></a>,
<a class="link" href="BHandler.html#BHandler_SetNextHandler" title="SetNextHandler(), NextHandler()"><code class="methodname">SetNextHandler()</code></a>,
<a class="link" href="BLooper.html#BLooper_PostMessage" title="PostMessage()"><code class="methodname">PostMessage()</code></a>, the
<a class="link" href="BMessenger.html" title="BMessenger"><code class="classname">BMessenger</code></a> class
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_CurrentMessage"></a><a id="BLooper_DetachCurrentMessage"></a>
CurrentMessage(), DetachCurrentMessage()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">BMessage* </span><span class="methodname">CurrentMessage</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">BMessage* </span><span class="methodname">DetachCurrentMessage</span>();</code><p>
The message that a <code class="classname">BLooper</code> passes to its handler(s)
is called the "current message." These functions access the
current message; they're meaningless (they return
<code class="constant">NULL</code>) when called from outside the message processing
loop.
</p><p>
<code class="methodname">CurrentMessage()</code> simply returns a pointer to the
current message without affecting the <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> object itself.
This is particularly useful to functions that respond to system messages
(such as <code class="methodname">MouseDown()</code> and
<code class="methodname">ScreenChanged()</code>), but that aren't sent the full
<a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> object that
initiated the response.
</p><p>
<code class="methodname">DetachCurrentMessage()</code> removes the current message
from the message queue and passes ownership of it to the caller; deleting
the message is the caller's responsibility. This is useful if you want to
delay the response to the message without tying up the
<code class="classname">BLooper</code>. But be careful—if the message
sender is waiting for a synchronous reply, detaching the message and
holding on to it will block the sender.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Lock"></a><a id="BLooper_LockWithTimeout"></a>
<a id="BLooper_Unlock"></a>
Lock(), LockWithTimeout(), Unlock()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">Lock</span>();</code><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">LockWithTimeout</span>(<span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">timeout</span></span>);</code><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">Unlock</span>();</code><p>
<code class="methodname">Lock()</code> locks the <code class="classname">BLooper</code>.
Locks are held within the context of a thread; while a
<code class="classname">BLooper</code> is locked, no other thread can invoke its
most important functions (
<a class="link" href="BLooper.html#BLooper_AddHandler" title="AddHandler(), RemoveHandler(), HandlerAt(), CountHandlers(), IndexOf()"><code class="methodname">AddHandler()</code></a>,
<a class="link" href="BLooper.html#BLooper_DispatchMessage" title="DispatchMessage()"><code class="methodname">DispatchMessage()</code></a>, etc.)
</p><p>
If the looper is already locked (by some other thread),
<code class="methodname">Lock()</code> blocks until the looper is unlocked. To set
a timeout for the block, use <code class="methodname">LockWithTimeout()</code>
instead. <code class="parameter">timeout</code> is measured in microseconds; if
it's 0, the function returns immediately (with or without the lock); if
it's <code class="constant">B_INFINITE_TIMEOUT</code>, it blocks without limit.
</p><p>
<code class="methodname">Unlock()</code> unlocks a locked looper. It can only be
called by the thread that currently holds the lock.
</p><p>
Calls to
<code class="methodname">Lock()</code>/<code class="methodname">LockWithTimeout()</code>
and <code class="methodname">Unlock()</code> can be nested, but locking and
unlocking must always be balanced. A single
<code class="methodname">Unlock()</code> will not undo a series of
<code class="methodname">Lock()</code>'s.
</p><p>
<a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> defines
"smart" versions of these functions that find the handler's
looper and then locks it (or unlocks it) in a pseudo-atomic operation (see
<a class="link" href="BHandler.html#BHandler_LockLooper" title="LockLooper(), LockLooperWithTimeout(), UnlockLooper()"><code class="methodname">BHandler::LockLooper()</code>
</a>). You should always use the <a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> versions, if
possible, rather than retrieving the handler's looper and locking it
yourself.
</p><p>
<code class="methodname">Lock()</code> returns <code class="constant">true</code> if it was
able to lock the looper, or if it's already locked by the calling thread,
and <code class="constant">false</code> otherwise.
</p><p>
<code class="methodname">LockWithTimeout()</code> returns:
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
The looper was successfully locked.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TIMED_OUT</code>.</span></p></td><td><p>
The call timed out without locking the looper.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>
This looper was deleted while the function was blocked.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_LockingThread"></a><a id="BLooper_IsLocked"></a>
<a id="BLooper_CountLocks"></a>
<a id="BLooper_CountLockRequests"></a>
<a id="BLooper_Sem"></a>
LockingThread(), IsLocked(), CountLocks(), CountLockRequests(), Sem()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">thread_id </span><span class="methodname">LockingThread</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">bool </span><span class="methodname">IsLocked</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">int32 </span><span class="methodname">CountLocks</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">int32 </span><span class="methodname">CountLockRequests</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">sem_id </span><span class="methodname">Sem</span>() <span class="modifier">const</span>;</code><p>
These functions may be useful while debugging a <code class="classname">BLooper</code>.
</p><p>
<code class="methodname">LockingThread()</code> returns the thread that currently
has the <code class="classname">BLooper</code> locked, or 1 if the
<code class="classname">BLooper</code> isn't locked.
</p><p>
<code class="methodname">IsLocked()</code> returns <code class="constant">true</code> if
the calling thread currently has the <code class="classname">BLooper</code> locked
(if it's the locking thread) and <code class="constant">false</code> if not (if some
other thread is the locking thread or the <code class="classname">BLooper</code>
isn't locked).
</p><p>
<code class="methodname">CountLocks()</code> returns the number of times the
locking thread has locked the <code class="classname">BLooper</code>the number of
<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">Lock()</code></a> (or
<a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">LockWithTimeout()</code></a>)
calls that have not yet been balanced by matching <a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">Unlock()</code></a> calls.
</p><p>
<code class="methodname">CountLockRequests()</code> returns the number of threads
currently trying to lock the <code class="classname">BLooper</code>. The count
includes the thread that currently has the lock plus all threads currently
waiting to acquire it.
</p><p>
<code class="methodname">Sem()</code> returns the <span class="type">sem_id</span> for the
semaphore that the <code class="classname">BLooper</code> uses to implement the
locking mechanism.
</p><p>
See also: <a class="link" href="BLooper.html#BLooper_Lock" title="Lock(), LockWithTimeout(), Unlock()"><code class="methodname">Lock()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_MessageReceived"></a>MessageReceived()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">MessageReceived</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>);</code><p>
Simply calls the inherited function. For the current release, the
<code class="classname">BLooper</code> implementation of this function does nothing
of importance.
</p><p>
See also: <a class="link" href="BHandler.html#BHandler_MessageReceived" title="MessageReceived()"><code class="methodname">BHandler::MessageReceived()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_MessageQueue"></a>MessageQueue()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">BMessageQueue* </span><span class="methodname">MessageQueue</span>() <span class="modifier">const</span>;</code><p>
Returns the queue that holds messages delivered to the
<code class="classname">BLooper</code>'s thread. You rarely need to examine the
message queue directly; it's made available so you can cheat fate by
looking ahead.
</p><p>
See also: the
<a class="link" href="BMessageQueue.html" title="BMessageQueue"><code class="classname">BMessageQueue</code></a> class
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_PostMessage"></a>PostMessage()</h4></div></div></div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">PostMessage</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">PostMessage</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">command</span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">PostMessage</span>(<span class="methodparam"><span class="type">BMessage* </span><span class="parameter">message</span></span>,<br />                     <span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>,<br />                     <span class="methodparam"><span class="type">BHandler* </span><span class="parameter">replyHandler</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">PostMessage</span>(<span class="methodparam"><span class="type">uint32 </span><span class="parameter">command</span></span>,<br />                     <span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>,<br />                     <span class="methodparam"><span class="type">BHandler* </span><span class="parameter">replyHandler</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>
</div><p>
<code class="methodname">PostMessage()</code> is similar to <a class="link" href="BMessenger.html#BMessenger_SendMessage" title="SendMessage()"><code class="methodname">BMessenger::SendMessage()</code></a>.
The <a class="link" href="BMessenger.html" title="BMessenger"><code class="methodname">BMessenger</code></a> version is
preferred (it's a bit safer than <code class="methodname">PostMessage()</code>).
</p><p>
Places a message at the far end of the <code class="classname">BLooper</code>'s
message queue. The message will be processed by <a class="link" href="BLooper.html#BLooper_DispatchMessage" title="DispatchMessage()"><code class="methodname">DispatchMessage()</code>
</a> when it comes to the head of the queue.
</p><p>
The message can be a full <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> object
(<code class="parameter">message</code>), or just a command constant
(<code class="parameter">command</code>). In the former case, the message is copied
and the caller retains ownership of the argument, which can be deleted as
soon as <code class="methodname">PostMessage()</code> returns. In the latter case,
a <a class="link" href="BMessage.html" title="BMessage"><code class="classname">BMessage</code></a> is
created (and deleted) for you.
</p><p>
<code class="parameter">handler</code> is the designated handler for the message,
and must be part of this <code class="classname">BLooper</code>'s handler chain. If
handler is (literally) <code class="constant">NULL</code>, the designated handler is
the <code class="classname">BLooper</code>'s preferred handler at the time <a class="link" href="BLooper.html#BLooper_DispatchMessage" title="DispatchMessage()"><code class="methodname">DispatchMessage()</code>
</a> is called. In the versions of
<code class="methodname">PostMessage()</code> that don't have a handler argument,
the designated handler is the <code class="classname">BLooper</code> object itself.
</p><p>
Replies to the message are delivered to
<code class="parameter">replyHandler</code>. If a
<code class="parameter">replyHandler</code> isn't specified, replies are sent to
<code class="varname">be_app_messenger</code>.
</p><p>
A <code class="classname">BLooper</code> should never post a message to itself from
within its own message loop thread.
</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>
The message was successfully posted.
</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MISMATCHED_VALUES</code>.</span></p></td><td><p>
<code class="parameter">handler</code>
doesn't belong to this <code class="classname">BLooper</code>.
</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>
See the return values for <a class="link" href="BMessenger.html#BMessenger_SendMessage" title="SendMessage()"><code class="methodname">BMessenger::SendMessage()</code></a>.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Quit"></a>Quit()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Quit</span>();</code><p>
Shuts down the message loop (if it's running), and deletes the
<code class="classname">BLooper</code>. The object must be locked.
</p><p>
When <code class="methodname">Quit()</code> is called from the
<code class="classname">BLooper</code>'s thread, the message loop is immediately
stopped and any messages in the message queue are deleted (without being
processed). Note that, in this case, <code class="methodname">Quit()</code>
doesn't return since the calling thread is dead.
</p><p>
When called from another thread, <code class="methodname">Quit()</code> waits
until all messages currently in the queue have been handled before it kills
the message loop. It returns after the <code class="classname">BLooper</code> has
been deleted.
</p><p>
If you're quitting a <code class="classname">BLooper</code> from some other thread,
you should send the object a
<a class="link" href="TheApplicationKit_MessageConstants.html#B_QUIT_REQUESTED" title="B_QUIT_REQUESTED"><code class="constant">B_QUIT_REQUESTED</code></a>
message rather than calling <code class="methodname">Quit()</code> directly.
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Run"></a>Run()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">thread_id </span><span class="methodname">Run</span>();</code><p>
Spawns the message loop thread and starts it running.
<code class="methodname">Run()</code> expects the <code class="classname">BLooper</code>
to be locked (once only!) when it's called; it unlocks the object before it
returns. Keep in mind that a <code class="classname">BLooper</code> is locked when
it's constructed.
</p><div class="admonition caution"><div class="title">Caution</div><div class="graphic"><img class="icon" alt="Caution" width="32" src="./images/admonitions/Warning_32.png" /><div class="text"><p>Calling <code class="methodname">Run()</code> on a <code class="classname">BLooper</code>
that's already running will dump you into the debugger.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term">Positive values.</span></p></td><td><p>
The thread was successfully spawned and started; this is
the <span class="type">thread_id</span> for the thread.
</p></td></tr><tr><td><p><span class="term">Thread errors.</span></p></td><td><p>
See <a class="link" href="TheKernelKit_ThreadsAndTeams.html#spawn_thread" title="spawn_thread()"><code class="function">spawn_thread()</code></a> and <a class="link" href="TheKernelKit_ThreadsAndTeams.html#resume_thread" title="resume_thread()"><code class="function">resume_thread()</code></a>.
</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>
See <a class="link" href="TheKernelKit_Ports.html#create_port" title="create_port()"><code class="function">create_port()</code></a>.
</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_SetPreferredHandler"></a><a id="BLooper_PreferredHandler"></a>
SetPreferredHandler(), PreferredHandler()</h4></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">SetPreferredHandler</span>(<span class="methodparam"><span class="type">BHandler* </span><span class="parameter">handler</span></span>) <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">BHandler* </span><span class="methodname">PreferredHandler</span>();</code><p>
These functions set and return the <code class="classname">BLooper</code>'s
preferred handler—the <a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a> object that
should handle messages not specifically targetted to another <a class="link" href="BHandler.html" title="BHandler"><code class="classname">BHandler</code></a>.
</p><p>
To designate the current preferred handler, whatever object that may be, as
the target of a message, pass <code class="constant">NULL</code> for the target
handler to <a class="link" href="BLooper.html#BLooper_PostMessage" title="PostMessage()"><code class="methodname">PostMessage()</code></a>
or to the <a class="link" href="BMessenger.html#BMessenger_Constructor" title="BMessenger()"><code class="methodname">BMessenger
constructor</code></a>.
</p><p>
Posting or sending messages to the preferred handler can be useful. For
example, in the <a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a>, <a class="link" href="BWindow.html" title="BWindow"><code class="classname">BWindow</code></a> objects name the
current focus view as the preferred handler. This makes it possible for
other objects, such as <a class="link" href="BMenuItem.html" title="BMenuItem"><code class="classname">BMenuItem</code></a>s and <a class="link" href="BButton.html" title="BButton"><code class="classname">BButtons</code></a>, to target
messages to the <a class="link" href="BView.html" title="BView"><code class="classname">BView</code></a>
that's currently in focus, without knowing what view that might be. For
example, by posting its messages to the window's preferred handler, a
<span class="guimenuitem">Cut</span> menu item can make sure that it always acts
on whatever view contains the current selection. See the chapter on the
<a class="link" href="TheInterfaceKit.html" title="The Interface Kit">Interface Kit</a> for information on
windows, views, and the role of the focus view.
</p><p>
By default, <code class="classname">BLooper</code>s don't have a preferred handler;
until one is set, <code class="methodname">PreferredHandler()</code> returns
<code class="constant">NULL</code>. Note however, that messages targeted to the
preferred handler are dispatched to the <code class="classname">BLooper</code>
whenever the preferred handler is <code class="constant">NULL</code>. In other
words, the <code class="classname">BLooper</code> acts as default preferred
handler, even though the default is formally <code class="constant">NULL</code>.
</p><p>
See also: <a class="link" href="BInvoker.html#BInvoker_SetTarget" title="SetTarget(), Target(), IsTargetLocal(), Messenger()"><code class="methodname">BInvoker::SetTarget()</code></a>,
<a class="link" href="BLooper.html#BLooper_PostMessage" title="PostMessage()"><code class="methodname">PostMessage()</code></a>
</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Thread"></a><a id="BLooper_Team"></a>
Thread(), Team()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">thread_id </span><span class="methodname">Thread</span>() <span class="modifier">const</span>;</code><code class="methodsynopsis cpp"><span class="type">team_id </span><span class="methodname">Team</span>() <span class="modifier">const</span>;</code><p>
These functions identify the thread that runs the message loop and the team
to which it belongs. <code class="methodname">Thread()</code> returns
<code class="constant">B_ERROR</code> if <a class="link" href="BLooper.html#BLooper_Run" title="Run()"><code class="methodname">Run()</code></a> hasn't yet been
called to spawn the thread and begin the loop.
<code class="methodname">Team()</code> always returns the application's
<span class="type">team_id</span>.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_StaticFunctions"></a>Static Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_LooperForThread"></a>LooperForThread()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">static </span><span class="type">BLooper* </span><span class="methodname">LooperForThread</span>(<span class="methodparam"><span class="type">thread_id </span><span class="parameter">thread</span></span>);</code><p>
Returns the <code class="classname">BLooper</code> object that spawned the
specified thread, or <code class="constant">NULL</code> if the thread doesn't belong
to a <code class="classname">BLooper</code>.
</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BLooper_Constants"></a>Constants</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="B_LOOPER_PORT_DEFAULT_CAPACITY"></a>B_LOOPER_PORT_DEFAULT_CAPACITY</h4></div></div></div><a id="id697876" class="indexterm"></a><pre class="programlisting definition c">#define <code class="constant">B_LOOPER_PORT_DEFAULT_CAPACITY</code> 100</pre><p>
The default capacity of the port that holds incoming messages before
they're placed in the <code class="classname">BLooper</code>'s <a class="link" href="BMessageQueue.html" title="BMessageQueue"><code class="classname">BMessageQueue</code></a>. The
capacity is set in the <code class="classname">BLooper</code>
<a class="link" href="BLooper.html#BLooper_Constructor" title="BLooper()">constructor</a>.
</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BInvoker.html">BInvoker</a>  Up: <a href="TheApplicationKit.html">The Application Kit</a>  Next: <a href="BMessage.html">BMessage</a> </div><div id="footerB"><div id="footerBL"><a href="BInvoker.html" title="BInvoker"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheApplicationKit.html" title="The Application Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BMessage.html" title="BMessage"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
