<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Be Book - Classes And Methods - The Media Kit</title><link rel="stylesheet" href="be_book.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_book_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><meta name="keywords" content="Access, BeOS, BeBook, API" /><link rel="start" href="index.html" title="The Be Book" /><link rel="up" href="TheMediaKit.html" title="The Media Kit" /><link rel="prev" href="BBuffer.html" title="BBuffer" /><link rel="next" href="BBufferGroup.html" title="BBufferGroup" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="BBuffer.html" title="BBuffer"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="BBufferGroup.html" title="BBufferGroup"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="navigindex"><a accesskey="i" href="ClassIndex.html" title="Index">I</a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">The Be Book - Classes And Methods - The Media Kit</div></div><div id="headerB">Prev: <a href="BBuffer.html">BBuffer</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BBufferGroup.html">BBufferGroup</a></div><hr /></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer"></a>BBufferConsumer</h2></div></div></div><a id="id1118705" class="indexterm"></a><div class="classheader"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Derived From:</td><td><a class="link" href="BMediaNode.html" title="BMediaNode"><code class="classname">BMediaNode</code></a></td></tr><tr><td>Mix-in Classes:</td><td>–</td></tr><tr><td>Declared In:</td><td><code class="filename">media/BBufferConsumer.h</code></td></tr><tr><td>Library:</td><td><code class="filename">libmedia.so</code></td></tr><tr><td>Allocation:</td><td>Constructor only</td></tr></tbody></table></td><td>
<a class="link overview" href="BBufferConsumer_Overview.html" title="BBufferConsumer">Class Overview</a>
<div class="toc"><ul><li><span class="section"><a href="BBufferConsumer.html#BBufferConsumer_ConstructorDestructor">Constructor and Destructor</a></span></li><li><span class="section"><a href="BBufferConsumer.html#BBufferConsumer_HookFunctions">Hook Functions</a></span></li><li><span class="section"><a href="BBufferConsumer.html#BBufferConsumer_MemberFunctions">Member Functions</a></span></li></ul></div>
</td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_ConstructorDestructor"></a>Constructor and Destructor</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_Constructor"></a>BBufferConsumer()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="constructorsynopsis cpp"><span class="methodname">BBufferConsumer</span>(<span class="methodparam"><span class="type">media_type </span><span class="parameter">consumerType</span></span>);</code><p>The <code class="classname">BBufferConsumer</code> constructor. Specify
as <code class="parameter">consumerType</code> the type of data
the <code class="classname">BBufferConsumer</code> accepts.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>In BeOS Release 4.5.2 and earlier <code class="parameter">consumerType</code> has a default value. It
no longer does. You'll have to actually specify the media type from now
on.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_Destructor"></a>~BBufferConsumer</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="destructorsynopsis cpp"><span class="methodname">~BBufferConsumer</span>();</code><p>The <code class="classname">BBufferConsumer</code> destructor. You can augment
this to handle whatever closing-out your consumer node requires.</p><p>If your node has created and set
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>s
for any producers, you
should delete them in the destructor.</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_HookFunctions"></a>Hook Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_AcceptFormat"></a>AcceptFormat()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">AcceptFormat</span>(<span class="methodparam"><span class="type">const media_destination &amp; </span><span class="parameter">destination</span></span>,<br />                              <span class="methodparam"><span class="type">media_format* </span><span class="parameter">format</span></span>) <span class="modifier"> = 0</span>;</code><p>Implement this hook function to check that the specified format is
reasonable for the specified destination, and to fill in any wildcard
fields for which your <code class="classname">BBufferConsumer</code> has specific requirements.</p><p>If the format isn't reasonable (or is of a class that's unsuitable for
<code class="parameter">destination</code>), return <code class="constant">B_MEDIA_BAD_FORMAT</code>.</p><p>When <code class="methodname">AcceptFormat()</code> returns
<code class="constant">B_OK</code>, the Media Kit will expect a connection
request on <code class="parameter">destination</code> with the specified
<code class="parameter">format</code> not to fail due to a
format incompatibility.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>Don't try to ask the upstream producer about the format; it's waiting
synchronously for your response, and doing so will cause deadlock.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_BufferReceived"></a>BufferReceived()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">BufferReceived</span>(<span class="methodparam"><span class="type"><span class="classname">BBuffer</span>* </span><span class="parameter">buffer</span></span>) <span class="modifier"> = 0</span>;</code><p>When a
<a class="link" href="BBufferProducer.html" title="BBufferProducer"><code class="classname">BBufferProducer</code></a>
sends buffers to one of your <code class="classname">BBufferConsumer</code>'s
inputs, it will eventually arrive here, at the
<code class="methodname">BufferReceived()</code> function
(usually after first being dispatched by
<a class="link" href="BBufferConsumer.html#BBufferConsumer_HandleMessage" title="HandleMessage()"><code class="methodname">HandleMessage()</code></a>).</p><p>Override this hook function to add the <code class="parameter">buffer</code> to your internal playback
queue, or to do whatever your node needs to do with buffers you consume.
If you implement both
<a class="link" href="BBufferProducer.html" title="BBufferProducer"><code class="classname">BBufferProducer</code></a> and
<code class="classname">BBufferConsumer</code>,
it's possible you might examine or alter the data in the <code class="parameter">buffer</code> and then call
<a class="link" href="BBufferProducer.html#BBufferProducer_SendBuffer" title="SendBuffer()"><code class="methodname">BBufferProducer::SendBuffer()</code></a>
to send it along to someone else.</p><p>If your processing of the buffer is long enough to cause the buffer to
become late, you should still process it as usual, but you should also
call <a class="link" href="BBufferConsumer.html#BBufferConsumer_NotifyLateProducer" title="NotifyLateProducer()"><code class="methodname">NotifyLateProducer()</code></a>
to let the producer know things are starting to lag.</p><p>Information about the contents and timing requirements of the buffer can
be obtained by calling
<a class="link" href="BBuffer.html#BBuffer_Header" title="Header()"><code class="methodname">BBuffer::Header()</code></a>
on it.</p><div class="admonition warning"><div class="title">Warning</div><div class="graphic"><img class="icon" alt="Warning" width="32" src="./images/admonitions/Stop_32.png" /><div class="text"><p>If you're writing a node, and receive a buffer with the
<code class="constant">B_SMALL_BUFFER</code>
flag set, you must recycle the buffer before returning.</p></div></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_Connected"></a>Connected()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">Connected</span>(<span class="methodparam"><span class="type">const media_source &amp; </span><span class="parameter">destination</span></span>,<br />                           <span class="methodparam"><span class="type">const media_format* </span><span class="parameter">format</span></span>,<br />                           <span class="methodparam"><span class="type">media_input* </span><span class="parameter">outInput</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called when a connection is being established to
your input destination from the specified source producer. The connection
will be composed of media data with the specified format (which you've
previously accepted via
<a class="link" href="BBufferConsumer.html#BBufferConsumer_AcceptFormat" title="AcceptFormat()"><code class="methodname">AcceptFormat()</code></a>).</p><p>Your implementation of <code class="methodname">Connected()</code> should do whatever preparation you
need to do to handle data input on the connection, and fill out the
<code class="parameter">outInput</code> buffer with information about the connection from your node's
point-of-view. You can set <code class="parameter">outInput</code>'s destination field different from
destination if destination is a global connection-establishing input
that's used to negotiate a connection, then create a new input to
actually handle the data stream.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Since your <code class="classname">BBufferConsumer</code> has already had the opportunity to reject
the specified format, it's poor form to return an error from this
function. You should only return an error if the resources needed to
establish the connection have become unavailable prior to the time
<code class="methodname">Connected()</code> was called.</p></div></div></div><p>On entry, <code class="parameter">outInput</code>'s name field contains the name given the connection by
the producer (this may be an empty string if the producer didn't assign a
name). Your consumer should always make sure there's a valid name here,
because it's a bad thing to have unnamed connections, and there's no
guarantee that the producer will fill this in. If you don't have a good,
descriptive name for a connection, the name should minimally contain the
name of the node and a number that makes the connection's name unique
(such as "MyNode Input 1" or "MyNode Output 3").</p><p>If you want the producer to use a specific
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
(for example, if you want a video producer to fill
<a class="link" href="BDirectWindow.html" title="BDirectWindow"><code class="classname">BDirectWindow</code></a>
buffers), you should create the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a> here, then call
<a class="link" href="BBufferProducer.html#BBufferProducer_SetBufferGroup" title="SetBufferGroup()"><code class="methodname">BBufferProducer::SetBufferGroup()</code></a>
to set the producer's buffer group:</p><pre class="programlisting example cpp"><code class="classname">BBufferGroup</code> *<code class="varname">buffers</code> = new <code class="classname">BBufferGroup</code>;
<code class="classname">BMediaRoster</code>::<code class="methodname">Roster</code>()-&gt;<code class="methodname">SetOutputBuffersFor</code>(<code class="varname">producer</code>, <code class="varname">buffers</code>);</pre><p>Return <code class="constant">B_OK</code> if the connection is started
safely, otherwise, return an appropriate error code.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_Disconnected"></a>Disconnected()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">Disconnected</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">producer</span></span>,<br />                          <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">whichInput</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called when a connection is being terminated. You
should do whatever needs to be done in order to ensure that future
inquiries about the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_source" title="media_source"><span class="type">media_source</span></a>
connected to the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_input" title="media_input"><span class="type">media_input</span></a>
indicated by <code class="parameter">whichInput</code> reference
<span class="type">media_source</span>::<span class="type">null</span> (or, if another connection is
later established on the input, that producer).</p><p>If your consumer node has created and set a
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
for the producer, you shouldn't delete or reclaim it here, because the producer
has a clone of the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
that references the same buffers; deleting the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
would free those buffers, leaving the producer
in deadlock. Instead, delete (or reclaim) the when
<a class="link" href="BBufferConsumer.html#BBufferConsumer_Connected" title="Connected()"><code class="methodname">Connected()</code></a>
is called again, and be sure to delete any remaining
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>s
in your destructor.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_DisposeInputCookie"></a>DisposeInputCookie()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">DisposeInputCookie</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">cookie</span></span>) <span class="modifier"> = 0</span>;</code><p>If the cookie value you return in
<a class="link" href="BBufferConsumer.html#BBufferConsumer_GetNextInput" title="GetNextInput()"><code class="methodname">GetNextInput()</code></a>
is a pointer to an object that needs to be deleted when the iteration
process is completed, be sure to implement
<code class="methodname">DisposeInputCookie()</code> to do so.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_GetLatencyFor"></a>GetLatencyFor()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetLatencyFor</span>(<span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">forWhom</span></span>,<br />                               <span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">outLatency</span></span>,<br />                               <span class="methodparam"><span class="type">media_node_id* </span><span class="parameter">outTimeSource</span></span>) <span class="modifier"> = 0</span>;</code><p>Implement this hook function to calculate the total latency for the
<a class="link" href="TheMediaKit_DefinedTypes.html#media_destination" title="media_destination"><span class="type">media_destination</span></a>
specified by <code class="parameter">forWhom</code> and store the resulting value in
<code class="parameter">outLatency</code>. Also, return the time source your node is slaved to in
<code class="parameter">outTimeSource</code>.</p><p>If your node is a
<a class="link" href="BBufferProducer.html" title="BBufferProducer"><code class="classname">BBufferProducer</code></a></p><p>Return <code class="constant">B_OK</code> if you successfully compute
the latency; otherwise, return an appropriate error.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_GetNextInput"></a>GetNextInput()</h4></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">GetNextInput</span>(<span class="methodparam"><span class="type">int32 * </span><span class="parameter">cookie</span></span>,<br />                              <span class="methodparam"><span class="type">media_input* </span><span class="parameter">outInput</span></span>) <span class="modifier"> = 0</span>;</code><p>The first time a client calls this function, the value pointed to by
cookie will be 0. You should fill the buffer pointed to by <code class="parameter">outInput</code> with
information about your first input, and set the value at <code class="parameter">cookie</code> to
something (other than zero) that will let you keep track of what to
return the next time <code class="methodname">GetNextInput()</code> is called.</p><p>Each successive call to <code class="methodname">GetNextInput()</code>
will pass back, in <code class="parameter">cookie</code>, the
value you returned in <code class="parameter">cookie</code> the last time the function was called by
that client, and you should fill <code class="parameter">outInput</code> with information about the next
input, and store a new value in <code class="parameter">cookie</code> to continue to track your progress
through the inputs.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Whenever this function is called with a value of zero in cookie, you
must start over with the first input.</p></div></div></div><p>When you reach the last input, return <code class="constant">B_BAD_INDEX</code> to indicate that there
aren't any more inputs.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_HandleMessage"></a>HandleMessage()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">HandleMessage</span>(<span class="methodparam"><span class="type">int32 </span><span class="parameter">message</span></span>,<br />                               <span class="methodparam"><span class="type">const void* </span><span class="parameter">data</span></span>,<br />                               <span class="methodparam"><span class="type">size_t </span><span class="parameter">size</span></span>);</code><p>When your node derived from <code class="classname">BBufferConsumer</code> receives a message on its
control port, you should try dispatching it by calling
<code class="methodname">HandleMessage()</code>.
If <code class="classname">BBufferConsumer</code> doesn't understand
the message, it'll return <code class="constant">B_ERROR</code> and you can try dispatching it to
another class from which your node is derived, or handle it yourself.</p><p>If this function returns <code class="constant">B_OK</code>, the message has been handled.</p><p>See also:
<a class="link" href="BMediaNode.html#BMediaNode_HandleMessage" title="HandleMessage()"><code class="methodname">BMediaNode::HandleMessage()</code></a>,
"<a class="xref" href="TheMediaKit_Overview_Introduction.html#TheMediaKit_AboutMultipleVirtualInheritance" title="About Multiple Virtual Inheritance">About Multiple Virtual Inheritance</a>"</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_ProducerDataStatus"></a>ProducerDataStatus()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="void">void </span><span class="methodname">ProducerDataStatus</span>(<span class="methodparam"><span class="type">const media_destination &amp; </span><span class="parameter">destination</span></span>,<br />                                <span class="methodparam"><span class="type">int32 </span><span class="parameter">status</span></span>,<br />                                <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">atPerformanceTime</span></span>) <span class="modifier"> = 0</span>;</code><p>This hook function is called to inform your consumer about changes in the
availability of buffers from the producer that's connected to the input
destination. The status argument specifies what change has occurred, and
<code class="parameter">atPerformanceTime</code> indicates when the change happened (or when it will
happen).</p><p>This lets you keep track of which inputs you should await data from; for
example, if your consumer is processing data arriving from four
producers, and one of them stops sending buffers to the consumer, the
producer that's stopping will cause a call to
<code class="methodname">ProducerDataStatus()</code> to let
you know not to await buffers anymore. This way, you know that when
buffers have arrived from the other three inputs, it's okay to begin
processing the buffers.</p><table class="variablelist constants"><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_DATA_NOT_AVAILABLE</code></span></p></td><td><p>The producer doesn't have any data available.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_DATA_AVAILABLE</code></span></p></td><td><p>The producer has data available.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_PRODUCER_STOPPED</code></span></p></td><td><p>The producer has been stopped.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_SeekTagRequested"></a>SeekTagRequested()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">SeekTagRequested</span>(<span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                                  <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">inTargetTime</span></span>,<br />                                  <span class="methodparam"><span class="type">uint32 </span><span class="parameter">inFlags</span></span>,<br />                                  <span class="methodparam"><span class="type">media_seek_tag* </span><span class="parameter">outSeekTag</span></span>,<br />                                  <span class="methodparam"><span class="type">bigtime_t* </span><span class="parameter">outTaggedTime</span></span>,<br />                                  <span class="methodparam"><span class="type">uint32* </span><span class="parameter">outFlags</span></span>);</code><p>This function is provided to aid in supporting media formats in which the
outer encapsulation layer doesn't supply timing information. Producers
will tag the buffers they generate with seek tags; these tags can be used
to locate key frames in the media data.</p><p>It's the consumer's job to match up seek tags with performance times. As
the consumer processes each incoming buffer, it should cache the seek tag
and the performance time at which it occurs (if there's a tag on the
buffer). When the producer needs to know the seek tag and corresponding
time that's closest to a given performance time, this function is
resonsible for returning that information.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>No error.</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>Depend on the node's implementation.</p></td></tr></tbody></table><p>See also:
"<a class="xref" href="BBufferProducer_Overview.html#BBufferProducer_Overview_SeekTags" title="Seek Tags">Seek Tags</a>"</p></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><hr /><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_MemberFunctions"></a>Member Functions</h3></div></div></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_ConsumerType"></a>ConsumerType()</h4></div></div></div><code class="methodsynopsis cpp"><span class="type">media_type </span><span class="methodname">ConsumerType</span>();</code><p>Returns the type of media the <code class="classname">BBufferConsumer</code> consumes.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_NotifyLateProducer"></a>NotifyLateProducer()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">static</h5></div></div></div><code class="methodsynopsis cpp"><span class="void">void </span><span class="methodname">NotifyLateProducer</span>(<span class="methodparam"><span class="type">const media_source &amp; </span><span class="parameter">source</span></span>,<br />                        <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">howLate</span></span>,<br />                        <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">performanceTime</span></span>);</code><p>Notifies the
<a class="link" href="BBufferProducer.html" title="BBufferProducer"><code class="classname">BBufferProducer</code></a>
specified by source that it's running late
by <code class="parameter">howLate</code> microseconds; the notification conditions as of the specified
<code class="parameter">performanceTime</code>. Call this function when you detect that data is arriving
too late and the run mode is <code class="constant">B_DECREASE_PRECISION</code>,
<code class="constant">B_INCREASE_LATENCY</code>, or
<code class="constant">B_DROP_DATA</code> (any of which permits adjustment of the media playback to
maintain timeliness).</p><p>The producer should process this notification immediately and take the
appropriate action.</p></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_RegionToClipData"></a>RegionToClipData()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">static </span><span class="type">status_t </span><span class="methodname">RegionToClipData</span>(<span class="methodparam"><span class="type">const BRegion* </span><span class="parameter">region</span></span>,<br />                                 <span class="methodparam"><span class="type">int32* </span><span class="parameter">format</span></span>,<br />                                 <span class="methodparam"><span class="type">int32* </span><span class="parameter">ioSize</span></span>,<br />                                 <span class="methodparam"><span class="type">void* </span><span class="parameter">data</span></span>);</code><p>Converts a
<a class="link" href="BRegion.html" title="BRegion"><code class="classname">BRegion</code></a>
into the clipping format used internally by the Media
Kit. Prior to calling <code class="methodname">RegionToClipData()</code>,
<code class="parameter">ioSize</code> is set to the size of
the buffer pointed to by <code class="parameter">data</code>. On return,
<code class="parameter">format</code> is the format of the
clipping data, <code class="parameter">ioSize</code> is changed to the actual number of bytes of data
returned, and <code class="parameter">data</code> contains the actual clipping data.</p><p>The clip data format is described in the section
"<a class="xref" href="BBufferProducer_Overview.html#BBufferProducer_Overview_VideoClipping" title="Video Clipping">Video Clipping</a>".</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>Clip data returned without errors.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_NO_MEMORY</code>.</span></p></td><td><p>The data buffer isn't big enough.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_RequestAdditionalBuffer"></a>RequestAdditionalBuffer()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><div class="synopsisgroup">
<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">RequestAdditionalBuffer</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                                 <span class="methodparam"><span class="type">BBuffer* </span><span class="parameter">previousBuffer</span></span>,<br />                                 <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>

<code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">RequestAdditionalBuffer</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                                 <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">startTime</span></span>,<br />                                 <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code>
</div><p>Asks the upstream producer specified by <code class="parameter">source</code> to immediately send the
next buffer, instead of waiting until the appropriate time. The most
obvious use for this function is in cases where a codec requires multiple
buffers in order to decode a frame of output
(<acronym class="acronym">MPEG</acronym> is a good example).</p><p>The requested buffer can be identified either by a <code class="parameter">startTime</code> parameter,
which indicates the time for which a buffer is requested, or by a
<code class="parameter">previousBuffer</code>, which specifies the buffer prior to the one being
requested.</p><p>This function will cause the producer's
<a class="link" href="BBufferProducer.html#BBufferProducer_AdditionalBufferRequested" title="AdditionalBufferRequested()"><code class="methodname">AdditionalBufferRequested()</code></a>
function to be called.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The change was requested successfully.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_SOURCE</code>.</span></p></td><td><p>The source isn't valid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_BAD_VALUE</code>.</span></p></td><td><p>The <code class="parameter">previousBuffer</code>
pointer is <code class="constant">NULL</code>.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TIMEOUT</code>.</span></p></td><td><p>The request to the Media Server timed out.</p></td></tr><tr><td><p><span class="term"><code class="constant">Port errors</code>.</span></p></td><td><p>An error occurred communicating with the Media Server.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_RequestFormatChange"></a><a id="BBufferConsumer_FormatChanged"></a>
RequestFormatChange(), FormatChanged()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">RequestFormatChange</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                             <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                             <span class="methodparam"><span class="type">media_format&amp; </span><span class="parameter">toFormat</span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">userData</span></span>,<br />                             <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">changeTag</span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><code class="methodsynopsis cpp"><span class="modifier">virtual </span><span class="type">status_t </span><span class="methodname">FormatChanged</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                               <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                               <span class="methodparam"><span class="type">media_format&amp; </span><span class="parameter">newFormat</span></span>) <span class="modifier"> = 0</span>;</code><p><code class="methodname">RequestFormatChange()</code>
requests that the producer <code class="parameter">source</code> connected to
the consumer <code class="parameter">destination</code> change the format it
produces to the format specified by <code class="parameter">toFormat</code>.
The Media Kit returns in <code class="parameter">changeTag</code> the tag value that will be received by
your
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
function once the change
takes effect; the change tag lets you match up the call to
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
with this request. This function will receive a
<a class="link" href="TheMediaKit_DefinedTypes.html#media_request_info" title="media_request_info"><span class="type">media_request_info</span></a>
structure with the indicated <code class="parameter">userData</code>
and <code class="parameter">changeTag</code>.</p><p><code class="methodname">FormatChanged()</code>
is called by the upstream producer when the media format
your node will be receiving changes, and indicates the new format in
<code class="parameter">newFormat</code> and the change tag value at which the new format will take
effect in <code class="parameter">changeTag</code>. You should implement this function so your node will
know that the data format is going to change. Note that this may be
called in response to your
<a class="link" href="BBufferConsumer.html#BBufferConsumer_AcceptFormat" title="AcceptFormat()"><code class="methodname">AcceptFormat()</code></a>
call, if your
<a class="link" href="BBufferConsumer.html#BBufferConsumer_AcceptFormat" title="AcceptFormat()"><code class="methodname">AcceptFormat()</code></a>
call alters any wildcard fields in the specified format.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Because <code class="methodname">FormatChanged()</code> is
called by the producer, you don't need to
(and shouldn't) ask it if the new format is acceptable.</p></div></div></div><p>If the format change isn't possible, return an appropriate error from
<code class="methodname">FormatChanged()</code>; this error will be passed back to the producer that
initiated the new format negotiation in the first place.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>No error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_SOURCE</code>.</span></p></td><td><p>The specified <code class="parameter">source</code> isn't valid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_DESTINATION</code>.</span></p></td><td><p>The specified <code class="parameter">destination</code> is invalid.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>See Ports.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_SendLatencyChange"></a>SendLatencyChange()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SendLatencyChange</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                           <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                           <span class="methodparam"><span class="type">bigtime_t </span><span class="parameter">newLatency</span></span>,<br />                           <span class="methodparam"><span class="type">uint32 </span><span class="parameter">flags</span><span class="initializer"> = 0</span></span>);</code><p>Lets the upstream producer know that the consumer node's latency has
changed. <code class="parameter">newLatency</code> indicates your new latency, in microseconds. The
flags are currently unused and should always be 0.</p><p>You should call this whenever something happens to cause a change in your
latency.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>No error.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_SOURCE</code>.</span></p></td><td><p>The <code class="parameter">source</code> is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_DESTINATION</code>.</span></p></td><td><p>The <code class="parameter">destination</code> is invalid.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_TIMED_OUT</code>.</span></p></td><td><p>The attempt to communicate with the Media Server timed
out.</p></td></tr><tr><td><p><span class="term">Port errors.</span></p></td><td><p>An error occurred communicating with the Media Server.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_SetOutputBuffersFor"></a>SetOutputBuffersFor()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetOutputBuffersFor</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                             <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                             <span class="methodparam"><span class="type"><span class="classname">BBufferGroup</span>* </span><span class="parameter">group</span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">userData</span></span>,<br />                             <span class="methodparam"><span class="type">int32* </span><span class="parameter">changeTag</span></span>,<br />                             <span class="methodparam"><span class="type">bool </span><span class="parameter">willReclaim</span><span class="initializer"> = <span class="constant">false</span></span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><p>Specifies that the
<a class="link" href="BBufferGroup.html" title="BBufferGroup"><code class="classname">BBufferGroup</code></a>
group will provide the buffers for the
connection between source and destination. If <code class="parameter">willReclaim</code>
is <code class="constant">false</code>, the
Media Kit will dispose of the group for you; you can forget about it once
this call returns. Otherwise, you're informing the Media Server that you
want the group back, and that you'll delete it when you're done with it.</p><p>The Media Kit returns in <code class="parameter">changeTag</code> the tag
value that will be received by your
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
function once the change takes effect; the change
tag lets you match up the call to
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
with this request. This function will receive a
<a class="link" href="TheMediaKit_DefinedTypes.html#media_request_info" title="media_request_info"><span class="type">media_request_info</span></a>
structure with the indicated <code class="parameter">userData</code> and
<code class="parameter">changeTag</code>.</p><p>The ability to request that certain buffers be used by a particular
output can save you from having to perform unnecessary copies; you might
be able to use
<a class="link" href="BBuffer.html" title="BBuffer"><code class="classname">BBuffer</code></a>s
that represent a graphics card frame buffer, for
example, so that a video producer's output goes directly to video memory.</p><div class="admonition note"><div class="title">Note</div><div class="graphic"><img class="icon" alt="Note" width="32" src="./images/admonitions/Info_32.png" /><div class="text"><p>Before reclaiming your buffers, be sure to call
<span class="code"><code class="methodname">SetOutputBuffersFor</code>(<code class="varname">output</code>, <code class="constant">NULL</code>)</span>
to let the Media Kit know your producer
no longer has permission to use them. If you forget this step, the
producer will hang onto the buffers until it's deleted, and your
<a class="link" href="BBufferGroup.html#BBufferGroup_ReclaimAllBuffers" title="ReclaimAllBuffers()"><code class="methodname">BBufferGroup::ReclaimAllBuffers()</code></a>
call will hang, possibly forever.</p></div></div></div><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The change was requested successfully.</p></td></tr><tr><td><p><span class="term">Other errors.</span></p></td><td><p>The change could not be made.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_SetOutputEnabled"></a>SetOutputEnabled()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="modifier">static </span><span class="type">status_t </span><span class="methodname">SetOutputEnabled</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">source</span></span>,<br />                                 <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                                 <span class="methodparam"><span class="type">bool </span><span class="parameter">enabled</span></span>,<br />                                 <span class="methodparam"><span class="type">void* </span><span class="parameter">userData</span></span>,<br />                                 <span class="methodparam"><span class="type">int32* </span><span class="parameter">changeTag</span></span>,<br />                                 <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><p>Specifies whether or not the specified output should be transmitting
buffers to the destination. If <code class="parameter">enabled</code> is
<code class="constant">true</code>, the producer should
transmit buffers; otherwise it should not.</p><p>The Media Kit returns in <code class="parameter">changeTag</code> the tag value that will be received by
your <a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
function once the change takes effect; the change
tag lets you match up the call to
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
with this request.
This function will receive a
<span class="type">media_request_info</span>
structure with the
indicated <code class="parameter">userData</code> and <code class="parameter">changeTag</code>.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The change was requested successfully.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_SOURCE</code></span></p></td><td><p>The source is invalid.</p></td></tr></tbody></table></div><div class="section"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="BBufferConsumer_SetVideoClippingFor"></a>SetVideoClippingFor()</h4></div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="subtitle">protected</h5></div></div></div><code class="methodsynopsis cpp"><span class="type">status_t </span><span class="methodname">SetVideoClippingFor</span>(<span class="methodparam"><span class="type">const media_source&amp; </span><span class="parameter">output</span></span>,<br />                             <span class="methodparam"><span class="type">const media_destination&amp; </span><span class="parameter">destination</span></span>,<br />                             <span class="methodparam"><span class="modifier">const </span><span class="type">int16* </span><span class="parameter">shortsList</span></span>,<br />                             <span class="methodparam"><span class="type">int32 </span><span class="parameter">shortCount</span></span>,<br />                             <span class="methodparam"><span class="modifier">const </span><span class="type">media_video_display_info&amp; </span><span class="parameter">display</span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">userData</span></span>,<br />                             <span class="methodparam"><span class="type">int32* </span><span class="parameter">changeTag</span></span>,<br />                             <span class="methodparam"><span class="type">void* </span><span class="parameter">_reserved_</span><span class="initializer"> = <span class="constant">NULL</span></span></span>);</code><p>This function requests that video buffers sent by the specified output to
the specified destination clip all its writing in buffers it sends to the
<code class="classname">BBufferConsumer</code> to the clipping region
described by <code class="parameter">shortsList</code> and
<code class="parameter">shortCount</code>. The clip data format is described in
the section
"<a class="xref" href="BBufferProducer_Overview.html#BBufferProducer_Overview_VideoClipping" title="Video Clipping">Video Clipping</a>".</p><p>The Media Kit returns in changeTag the tag value that will be received by
your <a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
function once the change takes effect; the change
tag lets you match up the call to
<a class="link" href="BMediaNode.html#BMediaNode_RequestCompleted" title="RequestCompleted()"><code class="methodname">RequestCompleted()</code></a>
with this request. This function will receive a
<a class="link" href="TheMediaKit_DefinedTypes.html#media_request_info" title="media_request_info"><span class="type">media_request_info</span></a>
structure with the indicated <code class="parameter">userData</code> and
<code class="parameter">changeTag</code>.</p><p>The
<a class="link" href="TheMediaKit_DefinedTypes.html#media_video_display_info" title="media_video_display_info"><span class="type">media_video_display_info</span></a>
structure referenced by display describes
the current configuration of the video in terms of color space,
resolution, and so forth.</p><table class="variablelist returncodes"><thead><tr><th>Return Code</th><th>Description</th></tr></thead><tbody><tr><td><p><span class="term"><code class="constant">B_OK</code>.</span></p></td><td><p>The clipping request has been sent without errors.</p></td></tr><tr><td><p><span class="term"><code class="constant">B_MEDIA_BAD_CLIP_FORMAT</code></span></p></td><td><p>The clipping data isn't formatted correctly.</p></td></tr><tr><td><p><span class="term">Port errors</span></p></td><td><p>See <a class="xref" href="TheKernelKit_Ports_Overview.html" title="Ports">Ports</a>.</p></td></tr></tbody></table></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="BBuffer.html">BBuffer</a>  Up: <a href="TheMediaKit.html">The Media Kit</a>  Next: <a href="BBufferGroup.html">BBufferGroup</a> </div><div id="footerB"><div id="footerBL"><a href="BBuffer.html" title="BBuffer"><img src="./images/navigation/prev.png" alt="Prev" /></a> <a href="TheMediaKit.html" title="The Media Kit"><img src="./images/navigation/up.png" alt="Up" /></a> <a href="BBufferGroup.html" title="BBufferGroup"><img src="./images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="http://www.haiku-os.org"><img src="./images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index.html"><img src="./images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="./images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="./LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, 'https://metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body></html>
